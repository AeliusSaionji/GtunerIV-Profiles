#pragma METAINFO("uJSM.gpc", 1, 0, "Aelius")

/*

END USER CUSTOMIZATION GUIDE - README
* Create a mapping for GYRO_OFF = TRUE to ratchet the controller.
-- if (is_active(yourbutton)) {GYRO_OFF();}
* Initiate a recalibration with combo_run(recalibrate).
-- You may need to do this periodically.
-- Place controller on a flat and steady surface before calibrating.
-- The combo will wait two seconds to give you time to get your hands off.
* SMOOTH_BUFFER_SIZE controls how many samples the smoothing function collects.
-- More smoothing means more latency.
* HID output protocol still outputs the controller!
-- And the XIM does see it!

NOTES
- The TitanTwo maps gyro data onto a range of 0.00-102.399994 rather than reporting angular velocity.
- Beware math functions which may exceed fix32 range (check calls to pythag)

TODO
GYRO_SENS X Y
add player lean player space
add world space as an option
kalman 1d?
in heavybullets, jsm roughly 2x as sensitive given same settings?
document the blink timing thing
possibly use blinkerSync to map joystick curve, predict UNPOWER setting
finish liveAdjust()
--blink color per setting?
do the various sens functions still take accel into account?
--what did I mean by this
read out 'gyro' to seg disp
add a config.h to include
--gyro off needs to be configurable
does override outer work for virtual_scale? It should.
implement checks for calls that exceed data type (and definitely put the check in pythag)
press start r2 r1 to start recalibrate combo
revisit globally dividing gyro vals by -25
possibly leverage IC config memory for user presets
xim specific axis fix?
fix left stick output (hold)
user configurable smoothing buffer size in IC?
flickstick
--mouse
--joystick
--translate flickstick joystick hold to aim? feels like regular gyro aim cuts off too fast. check how jsm feels
revisit winding flickstick
--add haptic bump when leaving 0/deadzone
optimize variables and memory usage
--offsetSamples and the local count are SO SIMILAR
--apply simpler if logic where possible (reference blinkerSync(), liveAdjust())
--possibly convert thresholds to uint
mouse_ring and mouse_area and scroll_wheel
figure out why higher than 2ms kills cpu
--implement function profiling
validate accel sign against steam controller dsu
*/

#include <mouse.gph>
#include <keyboard.gph>
#include <display.gph>
#define SMOOTH_BUFFER_SIZE 32 //>45 May lag CPU, >90 very limited memory available

//Misc Globals
uint16 offsetSamples;
uint32 mouseSamples;
fix32 gyroVelocity[3];//0 is Yaw (Z), 1 is Pitch (X), 2 is roll (Y)
fix32 accelGrav[3];// Using order Z X Y again
fix32 calibratedGyro[3];
fix32 gyroCalibration[3];
fix32 accumulatedOffset[3];
fix32 camera[2];
fix32 gyroStickX;
fix32 gyroStickY;
bool configMode = FALSE;
const bool DEBUG = TRUE;
bool LOGGING = TRUE;
const bool PROFILE = TRUE;
uint32 profileAccum;

//Settings with initial defaults
const uint8 gyro_output = 1; //0:mouse, 1:right stick, 2:left stick
const uint8 outProtocol = 0;
const bool calibrating = TRUE;
const bool outerStickOverride = TRUE;
const bool stickDisable = FALSE;
const bool winding = FALSE;
uint8 gyro_space = '0';//0:LOCAL, 1:PLAYER_TURN
uint16 maxStickGameSpeed = 360;
fix32 min_gyro_sens = 1.0;
fix32 max_gyro_sens = 1.0;
fix32 unpower = 0.0;
fix32 virtual_scale = 1.0;
//mouseCalibration = (REAL_WORLD_CALIBRATION) / os_mouse_speed / IN_GAME_SENS);
fix32 mouseCalibration = 1.0;
//candidates for uint to save on mem
fix32 undeadzone_inner = 0.0;
fix32 undeadzone_outer = 0.0;
fix32 gyro_smooth_threshold = 0.0;
fix32 gyro_tight_threshold = 0.0;
fix32 min_gyro_threshold = 0.0;
fix32 max_gyro_threshold = 0.0;

init {
  pmem_load();

  //uint8 only
  gyro_output        = pmem_read(0);
  gyro_space         = pmem_read(5);
  outProtocol        = pmem_read(50);
  //bools
  outerStickOverride = (pmem_read(25)>>1) & 0b1;
  calibrating        = (pmem_read(25)>>3) & 0b1;
  //flickstick       = (pmem_read(25)>>3) & 0b1;
  stickDisable       = (pmem_read(25)>>5) & 0b1;
  //fix32s & int16s
  pmem_read(17, &undeadzone_inner);
  pmem_read(21, &undeadzone_outer);
  pmem_read(5,  &virtual_scale);
  pmem_read(13, &unpower);
  pmem_read(9,  &maxStickGameSpeed);
  pmem_read(34, &min_gyro_threshold);
  pmem_read(38, &max_gyro_threshold);
  pmem_read(26, &min_gyro_sens);
  pmem_read(30, &max_gyro_sens);
  pmem_read(42, &gyro_tight_threshold);
  pmem_read(46, &gyro_smooth_threshold);
  min_gyro_threshold /= 25.0;//divide thresholds by a guestimated number,
  max_gyro_threshold /= 25.0;//such that they correspond to angular velocity
  gyro_tight_threshold /= 25.0;//(using same number as accel normalized to grav)
  gyro_smooth_threshold /= 25.0;

  switch (outProtocol) {
    case 1:  port_connect(PORT_USB_C, PROTOCOL_AUTO);   break;
    case 2:  port_connect(PORT_USB_C, PROTOCOL_PS4);    break;
    case 3:  port_connect(PORT_USB_C, PROTOCOL_XB360);  break;
    case 4:  port_connect(PORT_USB_C, PROTOCOL_HID);    break;
    case 5:  port_connect(PORT_BT_C,  PROTOCOL_HID);    break;
    case 6:  port_connect(PORT_BT_C,  PROTOCOL_PS3);    break;
    case 7:  port_connect(PORT_BT_C,  PROTOCOL_PS4);    break;
    case 8:  port_connect(PORT_BT_C,  PROTOCOL_XB360);  break;
    case 9:  port_connect(PORT_BT_C,  PROTOCOL_XB1);    break;
    case 10: port_connect(PORT_BT_C,  PROTOCOL_SWITCH); break;
    case 11: port_connect(PORT_BT_C,  PROTOCOL_WII);    break;
    default: break;
  }

  if (DEBUG) {
    LOGGING = FALSE;
    gyro_output = 1;
    outerStickOverride = FALSE;
    calibrating = TRUE;
    undeadzone_inner = 0.0;
    undeadzone_outer = 0.0;
    virtual_scale = 1.0;
    unpower = 0.0;
    maxStickGameSpeed = 194;
    min_gyro_sens = 1.0;
    max_gyro_sens = 1.0;
    gyro_tight_threshold = 0.0;
    gyro_smooth_threshold = 0.0;
    gyro_space = 0;
    winding = FALSE;
  }
}

main {
  if (TRUE) {
    //temp binds for testing
    if (is_active(BUTTON_4)) {
      mouse_set(MBUTTON_1, TRUE);
    } else if (is_release(BUTTON_4)) {
      mouse_set(MBUTTON_1, FALSE);
    }
    if (is_active(BUTTON_5)) {
      key_set(KEY_SPACEBAR, TRUE);
    } else if (is_release(BUTTON_5)) {
      key_set(KEY_SPACEBAR, FALSE);
    }
    if (is_active(BUTTON_4) && event_active(BUTTON_7) && (abs(get_actual(ACCEL_1_Z)) < 3.0)) {
      configMode = configMode ? FALSE : TRUE;
      if (configMode) {
        ffb_set(FFB_1, 100.0, 50);
        printf("Entered live config",0);
      } else {
        ffb_set(FFB_2, 100.0, 250);
        printf("Exited live config & saved settings",0);
        commitSettings();
      }
    }
  }

  if (configMode) liveAdjust();

  static uint8 delay;
  delay += (uint8)elapsed_time();
  if (delay >= 2) {//loop 500Hz fastest, or Titan will be sad
    //True Hz detection thanks to consoletuner discord member ME.
    static fix32 old_gyros;
    //int16 gX, gY, gZ;
    if (calibrating) {
      fix32 f_gX = get_actual(GYRO_1_X);
      fix32 f_gY = get_actual(GYRO_1_Y);
      fix32 f_gZ = get_actual(GYRO_1_Z);
      fix32 gyros = sqrt(sq(f_gX) + sq(f_gY) + sq(f_gZ));
      //Check for new values from sensor
      if (old_gyros != gyros) {
        old_gyros = gyros;
        /*gX = GetRaw(f_gX);*/
        /*gY = GetRaw(f_gY);*/
        /*gZ = GetRaw(f_gZ);*/
        processInput();//collect only uinque samples in calibration
      }
    }
    accelGrav[0] = get_actual(ACCEL_1_Z)/-25.0;//Normalize gravity to 1
    accelGrav[1] = get_actual(ACCEL_1_X)/-25.0;//Sign from titan seem incorrect?
    accelGrav[2] = get_actual(ACCEL_1_Y)/-25.0;
    gyroVelocity[0] = get_actual(GYRO_1_Z);
    gyroVelocity[1] = get_actual(GYRO_1_X);
    gyroVelocity[2] = get_actual(GYRO_1_Y);
    //gyroVelocity[0] = (fix32)gZ/-25.0;//On first blush, divide by 25 seems close to degrees/s.
    //gyroVelocity[1] = (fix32)gX/-25.0;//That would make sense, because 
    //gyroVelocity[2] = (fix32)gY/-25.0;//it would be in line with accel

    //Process input on regular intervals regardless of dupes
    if (!calibrating) processInput();//"only unique samples" probably just negates titan's internal deltaTime
    if (gyro_output == 1) {//Right stick

      if (winding) flickRotate();

      //Logic from JSM operates on a scale of 0-1
      if (processGyroStick(get_val(STICK_1_X)/100.0, get_val(STICK_1_Y)/100.0)) {} //returns a bool
    }
    if (gyro_output == 2) {//Left stick
      //Logic from JSM operates on a scale of 0-1
      if (processGyroStick(get_val(STICK_2_X)/100.0, get_val(STICK_2_Y)/100.0)) {} //returns a bool
    }
    delay = 0;
  }

  //set_val must be outside the polling loop!
  //lest values bounce back to 0 every cycle

  if  (gyro_output) {
    if ((min_gyro_sens == 0.0 && max_gyro_sens == 0.0) && gyro_output == 1) {
      //hack to help with finding deadzones more quickly
      set_val(STICK_1_X, undeadzone_inner * 100.0);

      //hack to help with finding max stick game speed
      if (!calibrating && !configMode) blinkerSync();

    } else if (gyro_output == 1) {
      set_val(STICK_1_X, gyroStickX * 100.0);
      set_val(STICK_1_Y, gyroStickY * 100.0);
    } else if (gyro_output == 2) {
      set_val(STICK_2_X, gyroStickX * 100.0);
      set_val(STICK_2_Y, gyroStickY * 100.0);
    }
    //Hack for games with accel boost at outer zone:
    //skip outer deadzone logic for the actual joystick
    //Gyro is still subject to deadzone and thus remains linear,
    //but stick now has access to game's accel for snappy stick turning
    if (outerStickOverride == TRUE && winding == FALSE) {
      if (get_actual(STICK_1_X) >= 95.0) {
        set_val(STICK_1_X, (gyroStickX + undeadzone_outer) * 100.0);
      } else if (get_actual(STICK_1_X) <= -95.0) {
        set_val(STICK_1_X, (gyroStickX - undeadzone_outer) * 100.0);
      } else if (get_actual(STICK_1_Y) >= 95.0) {
        set_val(STICK_1_Y, (gyroStickY + undeadzone_outer) * 100.0);
      } else if (get_actual(STICK_1_Y) <= -95.0) {
        set_val(STICK_1_Y, (gyroStickY - undeadzone_outer) * 100.0);
      }
    } else if (outerStickOverride == TRUE && winding == TRUE) flickRotate2();
  }

  if (gyro_output == 0) {//mouse
    processMouse(camera[0], camera[1]);
    //Controller is still passed as a joystick in HID output, it may be active
    if (stickDisable) {
      set_val(STICK_1_X, 0.0);//disable right joystick
      set_val(STICK_1_Y, 0.0);
    } else if (virtual_scale != 1.0) {//Apply virtual_scale aka stickSensitivity
      set_val(STICK_1_X, get_actual(STICK_1_X) * virtual_scale);
      set_val(STICK_1_Y, get_actual(STICK_1_Y) * virtual_scale);
    }
  }
}

//thanks to consoletuner discord member ME.
int16 GetRaw(fix32 val) {
  return (int16)ceil(lerp(-32768f, 32767f, -((val + 100f) / 200f)));
}

#define B_S 4 //rolling average array size
void blinkerSync() {
  static uint16 blinkHz = 1000;//start at 1 blink per 1000ms
  if (led_vmget(LED_1) == 0) {
    led_vmset(LED_1, 50, blinkHz - 50, 2);
  }

  int8 incHz;
  if (incHz =
  (event_active(BUTTON_10) ? -10 : 0) +//D-UP: faster
  (event_active(BUTTON_11) ?  10 : 0) +//D-DOWN: slower
  (event_active(BUTTON_12) ?   1 : 0) +//D-LEFT: slower
  (event_active(BUTTON_13) ?  -1 : 0)) {//D-RIGHT: faster
    blinkHz += (int16)incHz;
    printf("<br>Current interval: %dms<br>\
    Suggested VIRTUAL_STICK_CALIBRATION: %d degrees/s", blinkHz, 360000/blinkHz);
  }
  if (event_active(BUTTON_14)) {//North: reset phase
    led_vmset(LED_1, 50, blinkHz - 50, 2);
    printf("<br>blinkHz phase reset.<br>\
    Suggested VIRTUAL_STICK_CALIBRATION: %d degrees/s", 360000/blinkHz);
  }
  if (event_active(BUTTON_16)) {//South: calculate rolling average
    static uint16 lastTime = 0;
    static uint16 timeDiff[B_S];//store B_S samples
    static uint8 currentIndex = -1;
    currentIndex = (currentIndex + 1) % B_S;
    if (lastTime != 0) timeDiff[currentIndex] = (uint16)system_time() - lastTime;
    lastTime = system_time();
    uint8 i;
    for (blinkHz = i = 0; i < B_S; i++) {
      blinkHz += timeDiff[i];
    }
    blinkHz /= B_S;
    led_vmset(LED_1, 50, blinkHz - 50, 2);//reset phase
    printf("<br>Current interval (rolling average of 4): %dms (last 1: %dms)<br>\
    Suggested VIRTUAL_STICK_CALIBRATION: %d degrees/s", blinkHz, timeDiff[currentIndex], 360000/blinkHz);
  }

  maxStickGameSpeed = 360000 / clamp(blinkHz, 100, 6000);//degrees per second
  if (event_active(BUTTON_3)) {//START,+,SHARE, whathaveyou button
    pmem_write(9, maxStickGameSpeed);
    pmem_save();
    printf("Saved",0);
  }
}

void liveAdjust() {
  static fix32 *adjustPtr = &min_gyro_sens;//Assignment doesn't actually seem to take?
  static uint16 clampHigh;
  static uint8 incDiv;
  static uint8 settingsIndex = 0;
  static uint8 memOffset = 26;
  //printf("ptr %d", adjustPtr);//DEBUG
  if (event_active(BUTTON_16)) {//South
    settingsIndex  = (settingsIndex  + 1) % 10;
    switch (settingsIndex) {
      case 0: {//brackets because gtuner won't "reindent" switch/case alone
        adjustPtr = &undeadzone_inner;
        memOffset = 61;
        clampHigh = 1;
        incDiv = 100;
        printf("Adjusting UNDEADZONE_INNER. Current: %.2f", *adjustPtr);
        break;
      }
      case 1: {
        adjustPtr = &min_gyro_sens;
        memOffset = 26;
        clampHigh = 10;
        incDiv = 100;
        printf("Adjusting MIN_GYRO_SENS. Current: %.2f", *adjustPtr);
        break;
      }
      case 2: {
        adjustPtr = &max_gyro_sens;
        memOffset = 30;
        clampHigh = 10;
        incDiv = 100;
        printf("Adjusting MAX_GYRO_SENS. Current: %.2f", *adjustPtr);
        break;
      }
      case 3: {
        adjustPtr = &min_gyro_threshold;
        memOffset = 34;
        clampHigh = 1000;
        incDiv = 1;
        printf("Adjusting MIN_GYRO_THRESHOLD. Current: %.2f", *adjustPtr);
        break;
      }
      case 4: {
        adjustPtr = &max_gyro_threshold;
        memOffset = 38;
        clampHigh = 1000;
        incDiv = 1;
        printf("Adjusting MAX_GYRO_THRESHOLD. Current: %.2f", *adjustPtr);
        break;
      }
      case 5: {
        adjustPtr = &gyro_smooth_threshold;
        memOffset = 46;
        clampHigh = 1000;
        incDiv = 1;
        printf("Adjusting GYRO_SMOOTH_THRESHOLD. Current: %.2f", *adjustPtr);
        break;
      }
      case 6: {
        adjustPtr = &gyro_tight_threshold;
        memOffset = 42;
        clampHigh = 1000;
        incDiv = 1;
        printf("Adjusting gyro_tight_threshold. Current: %.2f", *adjustPtr);
        break;
      }
      case 7: {
        adjustPtr = &unpower;
        memOffset = 57;
        clampHigh = 2;
        incDiv = 100;
        printf("Adjusting UNPOWER. Current: %.2f", *adjustPtr);
        break;
      }
      case 8: {
        adjustPtr = &virtual_scale;
        memOffset = 53;
        clampHigh = 10;
        incDiv = 100;
        printf("Adjusting VIRTUAL_SCALE. Current: %.2f", *adjustPtr);
        break;
      }
      case 9: {
        adjustPtr = &gyro_space;
        memOffset = 5;
        printf("Adjusting GYRO_SPACE.", 0);
        break;
      }
    }
  }

  int8 incPtr;
  if (incPtr =
  (event_active(BUTTON_10) ?  10 : 0) +
  (event_active(BUTTON_11) ? -10 : 0) +
  (event_active(BUTTON_12) ?  -1 : 0) +
  (event_active(BUTTON_13) ?   1 : 0)) {
    if (adjustPtr == &gyro_space) {
      int8 *spacePtr = &gyro_space;//need to match ptr type?
      const char *spaceOpts[] = { "LOCAL", "PLAYER_TURN", "PLAYER_LEAN", "WORLD_TURN", "WORLD_LEAN"};
      *spacePtr = incPtr >= 0 ? (*spacePtr + 1) % 5 : *spacePtr;//Usual circular mod logic
      *spacePtr = incPtr <= 0 ? (*spacePtr + 4) % 5 : *spacePtr;//same logic in reverse
      printf(spaceOpts[*spacePtr]);
      return;
    }
    *adjustPtr = clamp(*adjustPtr + (fix32)incPtr/(fix32)incDiv, 0.0, (fix32)clampHigh);
    printf("Current: %.2f", *adjustPtr);
    if (*adjustPtr == 0.0 || *adjustPtr == (fix32)clampHigh) led_vmset(LED_2, 50, 50, 10);
  }

  if (event_active(BUTTON_15)) {//East
    //reload setting stored from pmem
    pmem_read(memOffset, adjustPtr);
    printf("Reverted to initial value: %.2f", *adjustPtr);
  }
}

void commitSettings() {
  pmem_write(26, min_gyro_sens);
  pmem_write(30, max_gyro_sens);
  pmem_write(34, min_gyro_threshold);
  pmem_write(38, max_gyro_threshold);
  pmem_write(42, gyro_tight_threshold);
  pmem_write(46, gyro_smooth_threshold);
  pmem_write(53, virtual_scale);
  pmem_write(57, unpower);
  pmem_write(61, undeadzone_inner);
  pmem_write(5,  gyro_space);
  pmem_save();
  if (min_gyro_sens != max_gyro_sens) {
    printf("You have MIN_GYRO_SENS and MAX_GYRO_SENS set to different values.<br>\
    Remember, this will linearly accelerate between the two values at the configured thresholds.<br>\
    Give them both the same value to disable acceleration.");
  }
}

void processMouse(fix32 x, fix32 y) {
  static fix32 diffX, diffY;
  fix32 mouseXint, mouseYint;
  x /= mouseCalibration;
  y /= mouseCalibration;
  mouseXint = round(x + diffX);//add value lost from previous rounding
  mouseYint = round(y + diffY);//then round to nearest int
  diffX = (x + diffX) - mouseXint;//store diff lost to rounding
  diffY = (y + diffY) - mouseYint;
  diffX -= 0.01 * diffX;//offset accumulation of sensor noise
  diffY -= 0.01 * diffY;
  mouse_set(MOUSE_X, (int32)mouseXint);
  mouse_set(MOUSE_Y, (int32)mouseYint);
}

void flickRotate() {
  static fix32 unwrap;
  //flick-rotate logic
  fix32 x = get_actual(STICK_1_X);
  fix32 y = get_actual(STICK_1_Y);
  fix32 length = pythag(x,y);
  fix32 lengthRad = atan2(x, -y)/PI*100.0;
  //unwrap = lengthRad - round((lengthRad - unwrap)/200.0)*200.0;//LUNS
  //if (abs(unwrap) > 150.0) unwrap = lengthRad;
  //fix32 clip = unwrap > 100.0 ? 100.0 : unwrap<-100.0 ?-100.0 : unwrap;
  if (length >= 10.0) {
    //lengthRad = abs(lengthRad) < 50.0 ? clamp(lengthRad * 3.0, -100.0, 100.0) : lengthRad;
    set_val(STICK_1_X, 0.0);
    set_val(STICK_1_Y, 0.0);
    set_val(STICK_1_X, lengthRad);
  }
}

void flickRotate2() {
  //currently just breaks outder deadzone
  fix32 x = get_val(STICK_1_X);
  fix32 y = get_val(STICK_1_Y);
  fix32 undeadzone_outerNew = undeadzone_outer * 100.0;
  if (x >= 98.0 - undeadzone_outerNew) {
    set_val(STICK_1_X, x + undeadzone_outerNew);
  }
  if (x <= -98.0 + undeadzone_outerNew) {
    set_val(STICK_1_X, x - undeadzone_outerNew);
  }
}

bool GYRO_OFF() {
  if (is_active(STICK_1_X) || is_active(STICK_1_Y)) {
    return FALSE;
  } 
  return FALSE;
}

void processInput() {
  //calibrating
  if (calibrating) {
    static uint16 count = 0;
    static int16 calibrationCount = -1;
    if (calibrationCount == -1) pmem_read(51, &calibrationCount);
    offsetSamples++;
    accumulatedOffset[0] += gyroVelocity[0];
    accumulatedOffset[1] += gyroVelocity[1];
    accumulatedOffset[2] += gyroVelocity[2];
    const uint8 disp[] = { _0_, _1_, _2_, _3_, _4_, _5_, _6_, _7_, _8_, _9_, _G_};
    if (count % (calibrationCount/10) == 0) {//exec on integer progress
      if (led_vmget(LED_1) != -1) led_vmset(LED_3, 50, 250, -1);//blink green
      uint8 dispf = count/(calibrationCount/10);//0-10
      display_overlay(disp[dispf], 1000);//0-10 on titantwo display
      printf("calibrating! %d%%", count/(calibrationCount/100));//0-100
    }
    count++;
    if (count > calibrationCount) {
      led_reset();
      led_vmset(LED_3, 50, 50, 10);
      calibrating = FALSE;
    }
  }

  gyroCalibration[0] = getCalibrationOffset(0);
  gyroCalibration[1] = getCalibrationOffset(1);
  gyroCalibration[2] = getCalibrationOffset(2);
  calibratedGyro[0] = (gyroVelocity[0] - gyroCalibration[0]);
  calibratedGyro[1] = (gyroVelocity[1] - gyroCalibration[1]);
  calibratedGyro[2] = (gyroVelocity[2] - gyroCalibration[2]);
  //fix32 *Zptr, *Xptr, *Yptr;
  //Zptr = &calibratedGyro[0];
  //Xptr = &calibratedGyro[1];
  //Yptr = &calibratedGyro[2];


  //smoothing (from wiki)
  if (gyro_smooth_threshold > 0.0) {
    getTieredSmoothedInput(&calibratedGyro[0], &calibratedGyro[1], gyro_smooth_threshold/2.0, gyro_smooth_threshold);
  }

  //cutoff/recovery... and maybe the jsm smoothing
  //calibratedGyro[0] = smoothJSM0(calibratedGyro[0], calibratedGyro[1], 0.0, 0.000001);
  //calibratedGyro[1] = smoothJSM1(calibratedGyro[0], calibratedGyro[1], 0.0, 0.000001);

  //tightening
  if (gyro_tight_threshold > 0.0) {
    getTightenedInput(&calibratedGyro[0], &calibratedGyro[1], gyro_tight_threshold);
  }

  //accelerating
  if (min_gyro_sens != max_gyro_sens) {
    processGyroAccel(calibratedGyro[0], calibratedGyro[1], calibratedGyro[2],
    accelGrav[0], accelGrav[1], accelGrav[2],
    min_gyro_sens, max_gyro_sens, min_gyro_threshold, max_gyro_threshold);
  } else {
    processGyroInput(calibratedGyro[0], calibratedGyro[1], calibratedGyro[2],
    accelGrav[0], accelGrav[1], accelGrav[2], min_gyro_sens);
  }
}

void processGyroInput(fix32 calibratedGyro0, fix32 calibratedGyro1, fix32 calibratedGyro2,
fix32 accelGrav0, fix32 accelGrav1, fix32 accelGrav2, fix32 gyroSensitivity) {
  // gyro: 012 == z x y == yaw pitch roll
  // accel: 012 == z x y == ???
  switch (gyro_space) {
    case 0: {//LOCAL
      camera[0] = calibratedGyro0 * gyroSensitivity;
      camera[1] = calibratedGyro1 * gyroSensitivity;
      break;
    }
    case 1: {//PLAYER_TURN (from JSM)
      // use world yaw for yaw direction, local combined yaw for magnitude
      fix32 worldYaw = calibratedGyro2 * accelGrav2 + calibratedGyro0 * accelGrav0; // dot product but just yaw and roll
      fix32 worldYawSign = worldYaw < 0.0 ? -1.0 : 1.0;
      fix32 yawRelaxFactor = 2.0;
      camera[0] = worldYawSign
      * min(abs(worldYaw) * yawRelaxFactor, pythag(calibratedGyro2, calibratedGyro0))
      * gyroSensitivity;
      // player space still uses local pitch:
      camera[1] = calibratedGyro1 * gyroSensitivity;
      break;
    }
    case 2: {//PLAYER_LEAN (from JSM)
      //TODO
      break;
    }
    case 3: {//WOLD_TURN
      //TODO
      break;
    }
    case 4: {//WORLD_LEAN
      //TODO
      break;
    }

    if (GYRO_OFF()) camera[0] = camera[1] = 0.0;
  }
}

//accel
void processGyroAccel(fix32 calibratedGyro0, fix32 calibratedGyro1, fix32 calibratedGyro2,
fix32 accelGrav0, fix32 accelGrav1, fix32 accelGrav2,
fix32 minGyroSens, fix32 maxGyroSens, fix32 minGyroThreshold, fix32 maxGyroThreshold) {
  // apply calibration factor
  // get input velocity
  fix32 magnitude = pythag(calibratedGyro0, calibratedGyro1);
  // calculate position on min_gyro_threshold to max_gyro_threshold scale
  magnitude -= minGyroThreshold;
  if (magnitude < 0.0) {
    magnitude = 0.0;
  }
  fix32 denom = maxGyroThreshold - minGyroThreshold;
  fix32 newSensitivity;
  if (denom <= 0.0) {
    newSensitivity = magnitude > 0.0 ? 1.0 : 0.0; // if min threshold overlaps max threshold, pop up to
    // max lowSens as soon as we're above min threshold
  } else {
    newSensitivity = magnitude / denom;
  }
  if (newSensitivity > 1.0) {
    newSensitivity = 1.0;
  }
  // interpolate between low sensitivity and high sensitivity
  newSensitivity = lerp(minGyroSens, maxGyroSens, newSensitivity);
  processGyroInput(calibratedGyro0, calibratedGyro1, calibratedGyro2,
  accelGrav0, accelGrav1, accelGrav2, newSensitivity);
}

fix32 getCalibrationOffset(int32 n) {
  if (offsetSamples == 0) {
    return 0.0;
  }
  if (n==0) {
    return accumulatedOffset[0] / (fix32)offsetSamples;
  } else if (n==1) {
    return accumulatedOffset[1] / (fix32)offsetSamples;
  }//flow dictates next line is technically else if
  return accumulatedOffset[2] / (fix32)offsetSamples;
}

void resetCalibration() {
  offsetSamples = 0;
  accumulatedOffset = 0.0;
}

combo recalibrate {
  resetCalibration();
  wait(0);
  wait(2000); //wait 2s for the user to take hands off controller
  calibrating = TRUE;
}

// smoothing buffer - adapted from blog
void getSmoothedInput(fix32 *avg) {
  static uint8 CurrentInputIndex = -1;
  CurrentInputIndex = (CurrentInputIndex + 1) % SMOOTH_BUFFER_SIZE;

  static fix32 InputBuffer0[SMOOTH_BUFFER_SIZE];
  static fix32 InputBuffer1[SMOOTH_BUFFER_SIZE];

  InputBuffer0[CurrentInputIndex] = avg[0];
  InputBuffer1[CurrentInputIndex] = avg[1];

  uint8 i;
  for (i = 0; i < SMOOTH_BUFFER_SIZE; i++) {
    avg[0] += InputBuffer0[i];
    avg[1] += InputBuffer1[i];
  }
  avg[0] /= (fix32)SMOOTH_BUFFER_SIZE;
  avg[1] /= (fix32)SMOOTH_BUFFER_SIZE;
}

void getTieredSmoothedInput(fix32 *input0, fix32 *input1, fix32 threshold1, fix32 threshold2) {
  fix32 inputMagnitude = pythag(*input0, *input1);
  fix32 directWeight = (inputMagnitude - threshold1) / (threshold2 - threshold1);
  directWeight = clamp(directWeight, 0.0, 1.0);
  fix32 avg[2];
  avg[0] = *input0 * (1.0 - directWeight);
  avg[1] = *input1 * (1.0 - directWeight);
  getSmoothedInput(&avg);
  *input0 = (*input0 * directWeight) + avg[0];
  *input1 = (*input1 * directWeight) + avg[1];
}

/*//smoothing from jsm

}*/

void getTightenedInput(fix32 *input0, fix32 *input1, fix32 threshold) {
  fix32 inputMagnitude = pythag(*input0, *input1);
  if (inputMagnitude < threshold) {
    fix32 inputScale = inputMagnitude / threshold;
    *input0 *= inputScale;
    *input1 *= inputScale;
  }
}

fix32 pythag(fix32 a, fix32 b) {
  //uint32 sqRoot;
  //sqRoot = (uint32)(round(100.0 * sqrt( sq(a) + sq(b))));//store result in larger type
  //printf("%d",sqRoot);
  //if (sqRoot > 3276700) {
  //printf("pythag return exceeded fix32");
  //return -1;
  //}
  //must test function before commiting to new returns
  //is floating point preserved within operation for typecast to even work this way?
  //return (fix32)sqRoot/100.0;
  return sqrt( sq(a) + sq(b) );
}

bool processGyroStick(fix32 stickX, fix32 stickY) {
  //GPC has all axis represented in -100 to 100
  //This is not the case with JSM
  fix32 stickLength = pythag(stickX, stickY);
  fix32 livezoneSize = 1.0 - undeadzone_outer - undeadzone_inner;
  //in order to correctly combine gyro and stick, we need to calculate what the stick
  //aiming is supposed to be doing, add gyro result to it, and convert back to stick
  if (unpower == 0.0) {
    unpower = 1.0;
  }

  fix32 stickVelocity = pow(clamp((stickLength - undeadzone_inner) / livezoneSize, 0.0, 1.0), unpower) * (fix32)maxStickGameSpeed * virtual_scale;
  fix32 expectedX = 0.0;
  fix32 expectedY = 0.0;
  gyroStickX = 0.0;
  gyroStickY = 0.0;

  if (stickVelocity > 0.0) {
    expectedX = (stickX / stickLength) * stickVelocity;
    expectedY = (stickY / stickLength) * stickVelocity;
  }

  //The original JSM function translates in-game turn velocity into units equivalent
  //to real world turn velocity, because a gyroscope reports real velocity.
  //TitanTwo reports everything including gyro on a scale of -100 to 100, so we need to work around this.
  expectedX += camera[0]*3.6; //the gyro readings top out at roughly 100.
  expectedY += camera[1]*3.6; //100 * 3.6 = 360.

  fix32 targetGyroVelocity = pythag(expectedX/100.0, expectedY/100.0) * 100.0; //sq(expected) exceeds fix32 range, oops!

  // map gyro velocity to achievable range in 0-1
  fix32 gyroInStickStrength = targetGyroVelocity >= (fix32)maxStickGameSpeed ? 1.0 : targetGyroVelocity / (fix32)maxStickGameSpeed;
  // UNPOWER curve
  if (unpower != 0.0) {
    gyroInStickStrength = pow(gyroInStickStrength, 1.0 / unpower);
  }

  // remap to between inner and outer deadzones
  if (gyroInStickStrength > 0.010) {
    gyroInStickStrength = undeadzone_inner + gyroInStickStrength * livezoneSize;
    gyroStickX = (expectedX / targetGyroVelocity) * gyroInStickStrength;
    gyroStickY = (expectedY / targetGyroVelocity) * gyroInStickStrength;
  }

  if (LOGGING) logger(camera[0], camera[1], stickX, stickY, stickLength, stickVelocity, expectedX,
  expectedY, targetGyroVelocity, gyroInStickStrength, gyroStickX, gyroStickY);

  return stickLength > undeadzone_inner;
}

/* void processRotational() {
//handleFlickStick(float calX, float calY, float lastCalX, float lastCalY, float mouseCalibrationFactor)
isMouse = FALSE;
fix32 camSpeedX = 0.0;
fix32 lastOffsetX = lastCalX;
fix32 lastOffsetY = lastCalY;
fix32 lastStickAngle = atan2f(-lastOffsetX, lastOffsetY);
fix32 angleChange = stickAngle - lastStickAngle;
// https://stackoverflow.com/a/11498248/1130520
angleChange = mod(angleChange + PI, 2.0 * PI);
if (angleChange < 0) {
angleChange += 2.0 * PI;
}
angleChange -= PI;
flick_rotation_counter += angleChange; // track all rotation for this flick
fix32 flickSpeedConstant = isMouse ? REAL_WORLD_CALIBRATION * mouseCalibrationFactor / IN_GAME_SENS : 1.0;
fix32 flickSpeed = -(angleChange * flickSpeedConstant);
int maxSmoothingSamples = min(jc->NumSamples, (int)ceil(64.0 / tick_time.get())); // target a max smoothing window size of 64ms
//fix32 stepSize = 0.01;                                                            // and we only want full on smoothing when the stick change each time we poll it is approximately the minimum stick resolution
// the fact that we're using radians makes this really easy
fix32 rotate_smooth_override = 0.0; //ROTATE_SMOOTH_OVERRIDE;
if (rotate_smooth_override < 0.0) {
//camSpeedX = jc->GetSmoothedStickRotation(flickSpeed, flickSpeedConstant * stepSize * 2.0, flickSpeedConstant * stepSize * 4.0, maxSmoothingSamples);
} else {
//camSpeedX = jc->GetSmoothedStickRotation(flickSpeed, flickSpeedConstant * rotate_smooth_override, flickSpeedConstant * rotate_smooth_override * 2.0, maxSmoothingSamples);
}

if (!isMouse) {
// convert to a velocity
camSpeedX *= 180.0 / (PI * 0.001;// * tick_time.get());
}
fix32 secondsSinceFlick = ((float)chrono::duration_cast<chrono::microseconds>(jc->time_now - jc->started_flick).count()) / 1000000.0f;
fix32 maxStickGameSpeed = jc->getSetting(SettingID::VIRTUAL_STICK_CALIBRATION);
fix32 flickTime = abs(jc->delta_flick) / (maxStickGameSpeed * PI / 180.f);

if (secondsSinceFlick <= flickTime)
{
camSpeedX -= jc->delta_flick >= 0 ? maxStickGameSpeed : -maxStickGameSpeed;
}
}
*/

uint32 profiler(char func, uint32 startTime) {
  uint32 elapsed = startTime - system_time();
  printf("func %d", elapsed);
  return elapsed;
}

void logger(fix32 camera0, fix32 camera1, fix32 stickX, fix32 stickY, fix32 stickLength,
fix32 stickVelocity, fix32 expectedX, fix32 expectedY, fix32 targetGyroVelocity,
fix32 gyroInStickStrength, fix32 gyroStickX, fix32 gyroStickY) {
  static uint8 delayLog = 0;
  delayLog++;
  if (delayLog >= 75) {
    printf("<big><br>\
    camera0: %.1f<br>\
    camera1: %.1f<br>\
    stickX: %.2f<br>\
    stickY: %.2f<br>\
    stickLength: %.2f<br>\
    stickVelocity: %.2f<br>\
    expectedX: %.2f<br>\
    expectedY: %.2f<br>\
    targetGyroVelocity: %.2f<br>\
    gyroInStickStrength: %.2f<br>\
    gyroStickX: %.2f<br>\
    gyroStickY: %.2f", camera0, camera1, stickX, stickY, stickLength, stickVelocity,
    expectedX, expectedY, targetGyroVelocity, gyroInStickStrength, gyroStickX, gyroStickY);
    delayLog = 0;
  }
}

void logger2(fix32 input1, fix32 input2, fix32 input3) {
  static uint8 delayLog = 0;
  delayLog++;
  if (delayLog >= 75) {
    printf("<big><br>\
    %.2f<br>\
    %.2f<br>\
    %.2f", input1, input2, input3);
    delayLog = 0;
  }
}
/* Interactive Config
I make use of empty [sections] to be heading titles in the GUI.
Then I group [detailed-config-name] elements under those empty sections.
This allows me to have nice GUI titles, while also allowing for accurate
and readable config names in IC-ByteTable.

<shortdesc>
Use your controller's gyro to aim! Supports outputting as mouse or joystick. See interactive config for help.
</shortdesc>

<keywords>
gyro mouse flickstick jsm joyshockmapper dualsense steamcontroller dualshock ds4 joycon motion
</keywords>

<cfgdesc>
[Presets]
shortdesc =
control = config
item        = Steam Controller:#19:08#33:00FA
item        = Deadzone and VIRTUAL_STICK_CALIBRATION Finder:0100000000#19:000000000000000000#3D:00190000
item        = Acceleration Example:#01:00000000#1A:00008000000200000014000003200000
item        = Threshold Testing Example (Motion only above 500 degrees per second):#01:00000000#1A:000000000001000001F4000001F50000
item        = User Preset 1:
item        = User Preset 2:
[Layout]
[GYRO_OUTPUT]
shortdesc = GYRO_OUTPUT
byteoffset = 0
bitsize = 8
bitoffset = 0
control = radiobox
default = 0
item = MOUSE
item = RIGHT_STICK
item = LEFT_STICK (incomplete)
group = true
[Layout Flickstick checkbox]
shortdesc = 
byteoffset = 25
bitsize = 1
bitoffset = 4
control = checkbox
default = 0
item = Flickstick
groupcol = true
[Layout windingStick checkbox]
shortdesc = 
byteoffset = 25
bitsize = 1
bitoffset = 6
control = checkbox
default = 0
item = Rotational stick aim
group = true
[Layout stickDisable checkbox]
shortdesc = 
byteoffset = 25
bitsize = 1
bitoffset = 5
control = checkbox
default = 0
item = Disable right joystick in mouse mode
group = true

[Sensitivities]
[Acceleration]
[MIN_GYRO_SENS]
shortdesc = MIN_GYRO_SENS
byteoffset = 26
bitsize = 32
bitoffset = 0
control = spinboxf
decimals = 2
default = 00100
minimum = 00000
maximum = 10000
step = 001
group = true
[MAX_GYRO_SENS]
shortdesc = MAX_GYRO_SENS
byteoffset = 30
bitsize = 32
bitoffset = 0
control = spinboxf
decimals = 2
default = 00100
minimum = 00000
maximum = 10000
step = 001
group = true
[MIN_GYRO_THRESHOLD]
shortdesc = MIN_GYRO_THRESHOLD
byteoffset = 34
bitsize = 32
bitoffset = 0
control = spinboxf
decimals = 2
default = 000000
minimum = 000000
maximum = 100000
step = 001
groupcol = true
[MAX_GYRO_THRESHOLD]
shortdesc = MAX_GYRO_THRESHOLD
byteoffset = 38
bitsize = 32
bitoffset = 0
control = spinboxf
decimals = 2
default = 000000
minimum = 000000
maximum = 100000
step = 0010
group = true

[Virtual Controller Stick Config]
[UNDEADZONE_INNER]
shortdesc = UNDEADZONE_INNER
byteoffset = 61
bitsize = 32
bitoffset = 0
control = spinboxf
default = 000
decimals = 2
step = 005
minimum = 000
maximum = 100
groupcol = true
[SPACE UNDEADZONE_OUTER]
control = space
default = 5
group = true
[UNDEADZONE_OUTER]
shortdesc = UNDEADZONE_OUTER
byteoffset = 65
bitsize = 32
bitoffset = 0
control = spinboxf
default = 000
decimals = 2
step = 005
minimum = 000
maximum = 100
group = true
[SPACE VIRTUAL_SCALE]
control = space
default = 25
group = true
[VIRTUAL_SCALE]
shortdesc = VIRTUAL_SCALE
byteoffset = 53
bitsize = 32
bitoffset = 0
control = spinboxf
decimals = 2
default = 0100
minimum = 0001
maximum = 1000
step = 001
group = true
[SPACE UNPOWER]
control = space
default = 25
group = true
[UNPOWER]
shortdesc = UNPOWER
byteoffset = 57
bitsize = 32
bitoffset = 0
control = spinboxf
decimals = 2
default = 000
minimum = 000
maximum = 200
step = 010
group = true
[mini info UNDEADZONE]
shortdesc = Prevent game deadzone from interfering with gyro aim
control = info
groupcol = true
[SPACE mini info VIRTUAL_SCALE]
control = space
default = 60
group = true
[mini info VIRTUAL_SCALE]
shortdesc = Scale virtual stick output
control = info
group = true
[SPACE mini info UNPOWER]
control = space
default = 25
group = true
[mini info UNPOWER]
shortdesc = Counter game power curve
control = info
group = true

[VIRTUAL_STICK_CALIBRATION]
shortdesc = VIRTUAL_STICK_CALIBRATION
byteoffset = 9
bitsize = 16
bitoffset = 0
control = spinbox
default = 360
minimum = 0001
maximum = 1000
step = 000010
[mini info VIRTUAL_STICK_CALIBRATION]
shortdesc = The maximum speed you can look around in game, in degrees per second
control = info
groupcol = true

[Misc]
[Calibrate gyro on startup]
shortdesc = 
byteoffset = 25
bitsize = 1
bitoffset = 3
control = checkbox
default = 1
item = Calibrate gyro on startup
group = true
[Calibration samples]
shortdesc = Calibration samples
byteoffset = 51
bitsize = 16
bitoffset = 0
control = dial
default = 01000
minimum = 00100
maximum = 05000
step = 50
group = true
[gyro_tight_threshold]
shortdesc = Tightening threshold
byteoffset = 42
bitsize = 32
bitoffset = 0
control = spinboxf
decimals = 2
default = 0
minimum = 000000
maximum = 100000
step = 100
groupcol = true
[GYRO_SMOOTH_THRESHOLD]
shortdesc = GYRO_SMOOTH_THRESHOLD
byteoffset = 46
bitsize = 32
bitoffset = 0
control = spinboxf
decimals = 2
default = 0
minimum = 000000
maximum = 100000
step = 100
group = true
[Outer deadzone override]
shortdesc = 
byteoffset = 25
bitsize = 1
bitoffset = 1
control = checkbox
default = 0
item = stick outer deadzone
group = true

[GYRO_SPACE]
shortdesc = The logic by which we interpret the gyro
bitsize = 8
byteoffset = 5
control = combobox
default = 0
item = LOCAL
item = PLAYER_TURN
item = PLAYER_LEAN
item = WORLD_TURN
item = WORLD_LEAN

[Output Protocol]
shortdesc = Remember this output next time you run the script
bitsize = 8
byteoffset = 50
control = combobox
default = 0
item = TitanTwo configured global default
item = PROTOCOL_AUTO
item = PROTOCOL_PS4
item = PROTOCOL_XB360
item = PROTOCOL_HID (HID required for mouse)
item = Bluetooth PROTOCOL_HID (HID required for mouse)
item = Bluetooth PROTOCOL_PS3
item = Bluetooth PROTOCOL_PS4
item = Bluetooth PROTOCOL_XB360
item = Bluetooth PROTOCOL_XB1
item = Bluetooth PROTOCOL_SWITCH
item = Bluetooth PROTOCOL_WII

[Info: uJSM?]
shortdesc = <<<MULTILINE
A significant chunk of this script was adapted from the PC software <a href=https://github.com/Electronicks/JoyShockMapper>JoyShockMapper</a>. Given that I've only implemented a subset of JSM features, and since the target platform is an embedded device (TitanTwo), I felt uJSM (micro JSM) was an appropriate name.
If you have any interest in using gyro aim on PC, go check out JoyShockMapper! I've intentionally kept all the settings in uJSM the same as they appear in JSM, so basic configuration should feel familiar :)

Anything capitalized works exactly the same in the PC JoyShockMapper. If it's not capitalized, then it's either not in JoyShockMapper, or it's configured in a different way.
MULTILINE
control = info

[Info: Mouse vs Joystick?]
shortdesc = <<<MULTILINE
Gyro is functionally equivalent to mouse, and is best experienced when mapped to a mouse.
Of course, you won't be able to use mouse mode on most console games, but mouse mode does work pretty well when paired with a XIM.

Joystick out is emulating a joystick, but how this feels will vary from game to game. In fact, since gyro is basically a mouse, it will feel a lot like you're trying to map a mouse to the joystick! This code is not as comprehensive as XIM smart translators, though.

NOTE: the HID output protocol still outputs the whole controller as a joystick, and the XIM does see it! Controller remaps will still take effect. Disable the right joystick to prevent double output where it may occur.
Alternatively, you can use Gtuner to configure device options and check "Disable Joystick from Multi Interface HID output".
MULTILINE
control = info

[Info: Flickstick]
shortdesc = <<<MULTILINE
The new aim method that I believe will one day replace traditional stick aim!
MULTILINE
control = info

[Info: Rotational stick aim]
shortdesc = <<<MULTILINE
Since flickstick on joystick output is severely compromised, I have implemented a component of flickstick: rotation. This keeps normal left/right stick aim, but allows for fine precision aim by pushing the stick forward and moving left or right. This allows you to keep using sensitivities that would otherwise be too high for a stick (which is a prerequisite for XIM). Normal left/right will allow for snappy turns, rotation allows for precise slow aim. Disables Y axis, so you'll want to map GYRO_OFF to something to re-orient yourself vertically.
MULTILINE
control = info

[Info: Sensitivities]
shortdesc = <<<MULTILINE
Gyro Sensitivity gets multiplied against sensor data to increase or decrease the output speed.

Stick sensitivity configures the sensitivity of the joystick in the same way, independently of gyro motion.

Unpower: If a game processes the joystick with a power curve, setting the exponent of the curve here will cancel out that curve for gyro output.
MULTILINE
control = info

[Info: Virtual Controller]
shortdesc = <<<MULTILINE
VIRTUAL_STICK_CALIBRATION
MULTILINE
control = info

[Info: Max Stick Game Speed]
shortdesc = <<<MULTILINE
Max stick game speed is a concept from JSM; it's supposed to represent how fast (in degrees/s) the game allows you to look around using the stick. If you set it correctly in JSM, (game stick logic permitting) the motion of the controller will be translated 1:1 to the game. Additionally, this allows you to translate your preferred sensitivity between different games.

However! Most games have a low max speed which will clip fast movements (you know this if you've used mouse input on your Titan), the TitanTwo does not report gyro data to the script in degrees/s, and the specific number (unique per game) is pretty difficult to determine with precision. 

What this setting does in abstract is scale your motion to the range of the virtual joystick. Lower values will reach 100% output quicker- allowing you to easily hit the fastest turn speed with minimal motion, but move too fast and the game camera won't keep up. Higher values allow more room for quicker and more aggressive motion (like quick panic flicks), but you start to lose precision for slower movements.

You can guestimate the game's value with a timer. Set inner deadzone to 100% and enable Deadzone Finder. This will cause you to spin around in game at max speed. Look down at the ground in game and find a line to pivot around. Start the timer and count the number of complete rotations your character does in a given amount of time. The longer you let the timer run, the more accurate your estimate will be. Multiply [number of rotations]*360, and divide that by [seconds] to get your max stick game speed. If you spun around 12 times in 20 seconds, then (12*360)/20=216.
MULTILINE
control = info

[Info: Un-Deadzone]
shortdesc = <<<MULTILINE
Each game has its own joystick inner deadzone set by the developers.
If this script knows where the deadzone is, it can use that as the starting point for gyro outpoint, effectively eliminating the inner deadzone.

The outer deadzone can be used to avoid non-linear jumps in sensitivity programmed into the game, which feel unnatural with gyro aim.

Note that outer deadzone config option is asking for the size of the deadzone, not where the deadzone starts.
If there's a jump in acceleration at 92% stick tilt, you want an 8% outer deadzone.

Deadzone Finder helps precisely find inner deadzone. Titan will tilt the joystick at the configured inner deadzone. Find the highest value of inner deadzone where the camera DOESN'T move. Start at 25% and work your way up or down from there.

Stick overrides outer deadzone: Some games have a sharp jump in acceleration when the joystick is tilted near 100%.
This is undesirable for gyro aim, but might be desirable while using the stick because it helps you turn around faster in game.
MULTILINE
control = info

[Info: Acceleration]
shortdesc = <<<MULTILINE
Define a linear acceleration between the two sensitivities at the given movement speed thresholds.
There will be no acceleration below the min threshold nor above the max threshold.
MULTILINE
control = info

[Info: Misc]
shortdesc = <<<MULTILINE
Calibrate gyro on startup: Place the controller on a flat surface and do not touch it until the LEDs stop flashing: they'll turns green when finished.
The script is averaging sensor data to filter out unwanted sensor noise: this helps fight drift.
NOTE! Steam controller will enter an idle mode after about 6 seconds. You may have to touch one of the pads to get calibration to continue. Do so very gently, so as to not accidentally add any movement during calibration.

Calibration samples: How many samples to collect during calibration. The controller's true polling rate will limit how fast samples are collected.

Tightening squishes output towards zero below the threshold, used to help prevent jitter when trying to hold still at higher sensitivities.

Smoothing helps reduce jitter below the threshold, useful for unsteady hands, or to smooth out noise with higher sensitivities.
MULTILINE
control = info

[Info: Speed Thresholds?]
shortdesc = <<<MULTILINE
Configure thresholds in values of degrees per second: how fast you are turning the controller. Unfortunately the TitanTwo doesn't present raw gyro data in this way, so the threshold number here is imperfect. I've tried to play with the numbers to make it close to reality, but you may find the settings are not exactly the same as what you'd use in JSM for PC.
Try values like 10 when trying to set a threshold that activates when moving as slow as possible. The highest sensible values is somewhere under 1000.

You can test where a threshold is by enabling acceleration with MIN_GYRO_SENS 0, MAX_GYRO_SENS 1. Then set MIN_GYRO_THRESHOLD to the desired test number, MAX_GYRO_THRESHOLD to one above that, and see how fast you must move the controller to get a response.
MULTILINE
control = info

[Credits]
shortdesc = <<<MULTILINE
Most of the concepts used and a lot of the code came from Jibb Smart's gyro wiki:
<a href=http://gyrowiki.jibbsmart.com>http://gyrowiki.jibbsmart.com</a>
As well as the JoyShockMapper project by Jibb Smart and Electronicks:
<a href=https://github.com/Electronicks/JoyShockMapper>https://github.com/Electronicks/JoyShockMapper</a>
Thank you!
MULTILINE
control = info
</cfgdesc>
*/
