#pragma METAINFO("uJSM.gpc", 1, 0, "Aelius")

/*

END USER CUSTOMIZATION GUIDE - README
* Create a mapping for GYRO_OFF() to ratchet the controller.
-- if (is_active(yourbutton)) {GYRO_OFF();}
* Initiate a recalibration with combo_run(recalibrate).
-- You may need to do this periodically.
-- Place controller on a flat and steady surface before calibrating.
-- The combo will wait two seconds to give you time to get your hands off.
* SMOOTH_BUFFER_SIZE controls how many samples the smoothing function collects.
-- More smoothing means more latency.
* HID output protocol still outputs the controller!
-- And the XIM does see it!

NOTES
- The TitanTwo maps gyro data onto a range of 0.00-102.399994 rather than reporting angular velocity.
- Beware math functions which may exceed fix32 range (check calls to pythag)

TODO
GYRO_SENS X Y
read out 10s digit to segdisp in liveAdjust
titan deltaTime internal? Resolve mystery once and for all.
rename camera[] to two variables that make sense
--same with calibratedGyro
why did pythag cause a flip in world(?) space (retest with new pythag)
why do I have a mystery pitch axis flip in world space
kalman 1d?
in heavybullets, jsm roughly 2x as sensitive given same settings?
document the blink timing thing
possibly use blinkerSync to map joystick curve, predict UNPOWER setting
do the various sens functions still take accel into account?
--what did I mean by this
read out 'gyro' to seg disp
add a config.h to include
--gyro off needs to be configurable
does override outer work for virtual_scale? It should.
implement checks for calls that exceed data type (and definitely put the check in pythag)
press start r2 r1 to start recalibrate combo
revisit globally dividing gyro vals by -25
possibly leverage IC config memory for user presets
xim specific axis fix?
fix left stick output (hold)
user configurable smoothing buffer size in IC?
flickstick
--mouse
--joystick
--translate flickstick joystick hold to aim? feels like regular gyro aim cuts off too fast. check how jsm feels
revisit winding flickstick
--runs get_actual; surely it can pull from another area we already poll the stick
--add haptic bump when leaving 0/deadzone
optimize variables and memory usage
--offsetSamples and the local count are SO SIMILAR
--apply simpler if logic where possible (reference blinkerSync(), liveAdjust())
--possibly convert thresholds to uint
--world space (and maybe player space) has redundant variables
mouse_ring and mouse_area and scroll_wheel
figure out why higher than 2ms kills cpu
--implement function profiling
validate accel sign against steam controller dsu
check that += camera is really not necessary
removed the "gyro on while joystick held" code, needs to be readded
logger needs variable argument list length
make GYRO_OFF work as a one liner instead of this if then true else false nonsense.
Just add sticks as a variable in the polling loop?
*/

#include <mouse.gph>
#include <keyboard.gph>
#include <display.gph>
#define SMOOTH_BUFFER_SIZE 32 //>45 May lag CPU, >90 very limited memory available
#define OFF_GO 0  // 1byte // GYRO_OUTPUT
#define OFF_GS 1  // 1byte // GYRO_SPACE
#define OFF_OP 2  // 1byte // output_protocol
#define OFF_CC 3  // 2byte // calibrationCount aka num of cal samples
#define OFF_MS 5  // 2byte // maxStickGameSpeed aka VIRTUAL_STICK_CALIBRATION
#define OFF_OO 7  // 1bit  // outerStickOverride
#define OFF_CB 7  // 1bit  // calibrating
#define OFF_SD 7  // 1bit  // stickDisable
#define OFF_FS 7  // 1bit  // flickstick
#define OFF_WS 7  // 1bit  // winding
#define OFF_NT 10 // 4byte // MIN_GYRO_THRESHOLD
#define OFF_XT 14 // 4byte // MAX_GYRO_THRESHOLD
#define OFF_NS 18 // 4byte // MIN_GYRO_SENS
#define OFF_XS 22 // 4byte // MAX_GYRO_SENS
#define OFF_UI 26 // 4byte // UNDEADZONE_INNER
#define OFF_UO 30 // 4byte // UNDEADZONE_OUTER
#define OFF_VS 34 // 4byte // VIRTUAL_SCALE
#define OFF_UN 38 // 4byte // UNPOWER
#define OFF_TT 42 // 4byte // gyro_tight_threshold
#define OFF_ST 46 // 4byte // GYRO_SMOOTH_THRESHOLD

//Misc Globals
uint16 offsetSamples;
uint32 mouseSamples;
fix32 gyroVelocity[3];//0 is Yaw (Z), 1 is Pitch (X), 2 is roll (Y)
fix32 accelGrav[3];// Using order Z X Y again
fix32 calibratedGyro[3];
fix32 accumulatedOffset[3];
fix32 camera[2];
fix32 gyroStickX;
fix32 gyroStickY;
bool configMode = FALSE;
const bool DEBUG = TRUE;
bool LOGGING = FALSE;
const bool PROFILE = FALSE;
uint32 profileAccum;
uint8 ERR;
bool gyroBlocked;

//Settings with initial defaults
const uint8 gyro_output = 1; //0:mouse, 1:right stick, 2:left stick
const uint8 outProtocol = 0;
const bool calibrating = TRUE;
const bool outerStickOverride = TRUE;
const bool stickDisable = FALSE;
const bool flickstick = FALSE;
const bool winding = FALSE;
uint8 gyro_space = 0;
uint16 maxStickGameSpeed = 360;
fix32 min_gyro_sens = 1.0;
fix32 max_gyro_sens = 1.0;
fix32 unpower = 0.0;
fix32 virtual_scale = 1.0;
//mouseCalibration = (REAL_WORLD_CALIBRATION) / os_mouse_speed / IN_GAME_SENS);
fix32 mouseCalibration = 1.0;
//candidates for uint to save on mem
fix32 undeadzone_inner = 0.0;
fix32 undeadzone_outer = 0.0;
fix32 gyro_smooth_threshold = 0.0;
fix32 gyro_tight_threshold = 0.0;
fix32 min_gyro_threshold = 0.0;
fix32 max_gyro_threshold = 0.0;

init {
  pmem_load();

  //uint8 only
  gyro_output        = pmem_read(OFF_GO);
  gyro_space         = pmem_read(OFF_GS);
  outProtocol        = pmem_read(OFF_OP);
  //bools
  outerStickOverride = (pmem_read(OFF_OO)>>0) & 0b1;
  calibrating        = (pmem_read(OFF_CB)>>1) & 0b1;
  stickDisable       = (pmem_read(OFF_SD)>>2) & 0b1;
  flickstick         = (pmem_read(OFF_FS)>>3) & 0b1;
  winding            = (pmem_read(OFF_WS)>>4) & 0b1;

  //fix32s & int16s
  pmem_read(OFF_UI, &undeadzone_inner);
  pmem_read(OFF_UO, &undeadzone_outer);
  pmem_read(OFF_VS, &virtual_scale);
  pmem_read(OFF_UN, &unpower);
  pmem_read(OFF_MS, &maxStickGameSpeed);
  pmem_read(OFF_NT, &min_gyro_threshold);
  pmem_read(OFF_XT, &max_gyro_threshold);
  pmem_read(OFF_NS, &min_gyro_sens);
  pmem_read(OFF_XS, &max_gyro_sens);
  pmem_read(OFF_TT, &gyro_tight_threshold);
  pmem_read(OFF_ST, &gyro_smooth_threshold);
  min_gyro_threshold /= 25.0;//divide thresholds by a guestimated number,
  max_gyro_threshold /= 25.0;//such that they correspond to angular velocity
  gyro_tight_threshold /= 25.0;//(using same number as accel normalized to grav)
  gyro_smooth_threshold /= 25.0;

  switch (outProtocol) {
    case 1:  port_connect(PORT_USB_C, PROTOCOL_AUTO);   break;
    case 2:  port_connect(PORT_USB_C, PROTOCOL_PS4);    break;
    case 3:  port_connect(PORT_USB_C, PROTOCOL_XB360);  break;
    case 4:  port_connect(PORT_USB_C, PROTOCOL_HID);    break;
    case 5:  port_connect(PORT_BT_C,  PROTOCOL_HID);    break;
    case 6:  port_connect(PORT_BT_C,  PROTOCOL_PS3);    break;
    case 7:  port_connect(PORT_BT_C,  PROTOCOL_PS4);    break;
    case 8:  port_connect(PORT_BT_C,  PROTOCOL_XB360);  break;
    case 9:  port_connect(PORT_BT_C,  PROTOCOL_XB1);    break;
    case 10: port_connect(PORT_BT_C,  PROTOCOL_SWITCH); break;
    case 11: port_connect(PORT_BT_C,  PROTOCOL_WII);    break;
    default: break;
  }

  if (DEBUG) {
    LOGGING = FALSE;
    gyro_output = 1;
    outerStickOverride = FALSE;
    calibrating = TRUE;
    undeadzone_inner = 0.51;
    undeadzone_outer = 0.0;
    virtual_scale = 1.0;
    unpower = 0.0;
    maxStickGameSpeed = 194;
    min_gyro_sens = 1.0;
    max_gyro_sens = 1.0;
    gyro_tight_threshold = 0.0;
    gyro_smooth_threshold = 0.0;
    gyro_space = 0;
    winding = FALSE;
    configMode = FALSE;
  }
}

main {
  if (DEBUG) {
    //temp binds for testing
    if (is_active(BUTTON_4)) {
      mouse_set(MBUTTON_1, TRUE);
    } else if (is_release(BUTTON_4)) {
      mouse_set(MBUTTON_1, FALSE);
    }
    if (is_active(BUTTON_5)) {
      key_set(KEY_SPACEBAR, TRUE);
    } else if (is_release(BUTTON_5)) {
      key_set(KEY_SPACEBAR, FALSE);
    }
    if (is_active(BUTTON_15)) GYRO_OFF(TRUE);
    else GYRO_OFF(FALSE);
  }

  //Bind to enter config mode
  if (is_active(BUTTON_4)//while R1 is held...
  && event_active(BUTTON_7)//press L1...
  && (abs(get_actual(ACCEL_1_Z)) < 3.0)) {//when controller is held sideways
    configMode = configMode ? FALSE : TRUE;
    if (configMode) {
      ffb_set(FFB_1, 100.0, 50);
      printf("Entered live config",0);
    } else {
      ffb_set(FFB_2, 100.0, 250);
      printf("Exited live config & saved settings",0);
      commitSettings();
    }
  }

  if (configMode) liveAdjust();

  static uint8 delay;
  delay += (uint8)elapsed_time();
  if (delay >= 2) {//loop 500Hz fastest, or Titan will be sad
    //True Hz detection thanks to consoletuner discord member ME.
    static fix32 old_gyros;
    //int16 gX, gY, gZ;
    if (calibrating) {
      fix32 f_gX = get_actual(GYRO_1_X);
      fix32 f_gY = get_actual(GYRO_1_Y);
      fix32 f_gZ = get_actual(GYRO_1_Z);
      fix32 gyros = sqrt(sq(f_gX) + sq(f_gY) + sq(f_gZ));
      //Check for new values from sensor
      if (old_gyros != gyros) {
        old_gyros = gyros;
        /*gX = GetRaw(f_gX);*/
        /*gY = GetRaw(f_gY);*/
        /*gZ = GetRaw(f_gZ);*/
        processInput();//collect only uinque samples in calibration
      }
    }
    accelGrav[0]    = get_actual(ACCEL_1_Z);//GPC swaps Y and Z axis.
    accelGrav[1]    = get_actual(ACCEL_1_X);//What I expect:
    accelGrav[2]    = get_actual(ACCEL_1_Y);//accel: Y up/down, Z front/back
    gyroVelocity[0] = get_actual(GYRO_1_Z);//gyro: Y yaw, Z roll
    gyroVelocity[1] = get_actual(GYRO_1_X);
    gyroVelocity[2] = get_actual(GYRO_1_Y);
    //gyroVelocity[0] = (fix32)gZ/-25.0;//Divide by 25 seems near degrees/s.
    //gyroVelocity[1] = (fix32)gX/-25.0;//That makes a sense, since it aligns
    //gyroVelocity[2] = (fix32)gY/-25.0;//with accel's 25=gravity.

    //Process input on a regular interval, regardless of duplicate readings.
    //Filtering for unique samples appears to undo what is probably Titan's
    //internally managed deltaTime.
    if (!calibrating) processInput();
    if (gyro_output == 1) {//Right stick
      if (winding) flickRotate();
      //div100 because logic from JSM operates on a scale of 0-1
      if (processGyroStick(get_val(STICK_1_X) / 100.0, get_val(STICK_1_Y) / 100.0)) {} //returns a bool
    }
    if (gyro_output == 2) {//Left stick
      //div100 because logic from JSM operates on a scale of 0-1
      if (processGyroStick(get_val(STICK_2_X) / 100.0, get_val(STICK_2_Y) / 100.0)) {} //returns a bool
    }
    delay = 0;
  }

  /* set_val must be outside polling loop! Lest values bounce to 0 every cycle */

  if  (gyro_output) {//nonzero means joystick, not mouse
    if ((min_gyro_sens == 0.0 && max_gyro_sens == 0.0) && gyro_output == 1) {
      //hack to help with finding deadzones more quickly
      set_val(STICK_1_X, undeadzone_inner * 100.0);

      //hack to help with finding max stick game speed
      if (!calibrating && !configMode) blinkerSync();

    } else if (gyro_output == 1) {
      set_val(STICK_1_X, gyroStickX * 100.0);
      set_val(STICK_1_Y, gyroStickY * 100.0);
    } else if (gyro_output == 2) {
      set_val(STICK_2_X, gyroStickX * 100.0);
      set_val(STICK_2_Y, gyroStickY * 100.0);
    }
    //Hack for games with accel boost at outer zone:
    //skip outer deadzone logic for the actual joystick
    //Gyro is still subject to deadzone and thus remains linear,
    //but stick now has access to game's accel for snappy stick turning
    #define OUTER_OVERRIDE_VAL 95.0
    if (outerStickOverride == TRUE && winding == FALSE) {
      fix32 stickX = get_actual(STICK_1_X);
      fix32 stickY = get_actual(STICK_1_Y);
      if (abs(stickX) >= OUTER_OVERRIDE_VAL) {
        int8 signX = stickX > 0.0 ? 1 : -1;
        set_val(STICK_1_X, (gyroStickX + (undeadzone_outer * (fix32)signX)) * 100.0);
      }
      if (abs(stickY) >= OUTER_OVERRIDE_VAL) {
        int8 signY = stickY > 0.0 ? 1 : -1;
        set_val(STICK_1_Y, (gyroStickY + (undeadzone_outer * (fix32)signY)) * 100.0);
      }
    } else if (outerStickOverride == TRUE && winding == TRUE) flickRotate2();
  }

  if (gyro_output == 0) {//mouse
    processMouse(camera[0], camera[1]);
    //Controller is still passed as a joystick in HID output, it may be active
    if (stickDisable) {
      set_val(STICK_1_X, 0.0);//disable right joystick
      set_val(STICK_1_Y, 0.0);
    } else if (virtual_scale != 1.0) {//Apply virtual_scale aka stickSensitivity
      set_val(STICK_1_X, get_actual(STICK_1_X) * virtual_scale);
      set_val(STICK_1_Y, get_actual(STICK_1_Y) * virtual_scale);
    }
  }
}

//thanks to consoletuner discord member ME.
int16 GetRaw(fix32 val) {
  return (int16)ceil(lerp(-32768f, 32767f, -((val + 100f) / 200f)));
}

#define B_S 4 //rolling average array size
void blinkerSync() {
  static uint16 blinkHz = 1000;//start at 1 blink per 1000ms
  if (led_vmget(LED_1) == 0) {
    led_vmset(LED_1, 50, blinkHz - 50, 2);
  }

  int8 incHz;
  if (incHz =
  (event_active(BUTTON_10) ? -10 : 0) +//D-UP: faster
  (event_active(BUTTON_11) ?  10 : 0) +//D-DOWN: slower
  (event_active(BUTTON_12) ?   1 : 0) +//D-LEFT: slower
  (event_active(BUTTON_13) ?  -1 : 0)) {//D-RIGHT: faster
    blinkHz += (int16)incHz;
    printf("<br>Current interval: %dms<br>\
    Suggested VIRTUAL_STICK_CALIBRATION: %d degrees/s", blinkHz, 360000 / blinkHz);
  }
  if (event_active(BUTTON_14)) {//North: reset phase
    led_vmset(LED_1, 50, blinkHz - 50, 2);
    printf("<br>blinkHz phase reset.<br>\
    Suggested VIRTUAL_STICK_CALIBRATION: %d degrees/s", 360000 / blinkHz);
  }
  if (event_active(BUTTON_16)) {//South: calculate rolling average
    static uint16 lastTime = 0;
    static uint16 timeDiff[B_S];//store B_S samples
    static uint8 currentIndex = -1;
    currentIndex = (currentIndex + 1) % B_S;
    if (lastTime != 0) timeDiff[currentIndex] = (uint16)system_time() - lastTime;
    lastTime = system_time();
    uint8 i;
    for (blinkHz = i = 0; i < B_S; i++) {
      blinkHz += timeDiff[i];
    }
    blinkHz /= B_S;
    led_vmset(LED_1, 50, blinkHz - 50, 2);//reset phase
    printf("<br>Current interval (rolling average of 4): %dms (last 1: %dms)<br>\
    Suggested VIRTUAL_STICK_CALIBRATION: %d degrees/s", blinkHz, timeDiff[currentIndex], 360000 / blinkHz);
  }

  maxStickGameSpeed = 360000 / clamp(blinkHz, 100, 6000);//degrees per second
  if (event_active(BUTTON_3)) {//START,+,SHARE, whathaveyou button
    pmem_write(OFF_MS, maxStickGameSpeed);
    pmem_save();
    printf("Saved",0);
  }
}

combo flashBlueRed {
  led_reset();
  led_vmset(LED_1, 200, 800, -1);
  wait(0);
  wait(200);
  led_vmset(LED_2, 200, 800, -1);
}
combo flashRedBlue {
  led_reset();
  led_vmset(LED_2, 200, 800, -1);
  wait(0);
  wait(200);
  led_vmset(LED_1, 200, 800, -1);
}
combo flashBlueGreen {
  led_reset();
  led_vmset(LED_1, 200, 800, -1);
  wait(0);
  wait(200);
  led_vmset(LED_3, 200, 800, -1);
}
combo flashGreenBlue {
  led_reset();
  led_vmset(LED_3, 200, 800, -1);
  wait(0);
  wait(200);
  led_vmset(LED_1, 200, 800, -1);
}
combo flashRedGreen {
  led_reset();
  led_vmset(LED_2, 200, 800, -1);
  wait(0);
  wait(200);
  led_vmset(LED_3, 200, 800, -1);
}
combo flashGreenRed {//for undeadzone_outer, if added to liveAdjust
  led_reset();
  led_vmset(LED_3, 200, 800, -1);
  wait(0);
  wait(200);
  led_vmset(LED_2, 200, 800, -1);
}

void liveAdjust() {
  static fix32 *adjustPtr = &min_gyro_sens;//Assignment doesn't actually seem to take?
  static uint16 clampHigh;
  static uint8 incDiv;
  static uint8 settingsIndex = 0;
  static uint8 memOffset = OFF_NS;
  if (event_active(BUTTON_16)) {//South
    settingsIndex  = (settingsIndex  + 1) % 11;//change me to match total case count!
    switch (settingsIndex) {
      case 1: {//brackets because gtuner won't "reindent" switch/case alone
        adjustPtr = &min_gyro_sens;
        memOffset = OFF_NS;
        clampHigh = 10;
        incDiv = 100;
        combo_run(flashBlueRed);
        printf("Adjusting MIN_GYRO_SENS. Current: %.2f", *adjustPtr);
        break;
      }
      case 2: {
        adjustPtr = &max_gyro_sens;
        memOffset = OFF_XS;
        clampHigh = 10;
        incDiv = 100;
        combo_run(flashRedBlue);
        printf("Adjusting MAX_GYRO_SENS. Current: %.2f", *adjustPtr);
        break;
      }
      case 3: {
        adjustPtr = &min_gyro_threshold;
        memOffset = OFF_NT;
        clampHigh = 1000;
        incDiv = 1;
        combo_run(flashBlueGreen);
        printf("Adjusting MIN_GYRO_THRESHOLD. Current: %.2f", *adjustPtr);
        break;
      }
      case 4: {
        adjustPtr = &max_gyro_threshold;
        memOffset = OFF_XT;
        clampHigh = 1000;
        incDiv = 1;
        combo_run(flashGreenBlue);
        printf("Adjusting MAX_GYRO_THRESHOLD. Current: %.2f", *adjustPtr);
        break;
      }
      case 5: {
        adjustPtr = &gyro_smooth_threshold;
        memOffset = OFF_ST;
        clampHigh = 1000;
        incDiv = 1;
        led_reset();
        led_vmset(LED_1, 200, 800, -1);
        led_vmset(LED_3, 400, 600, -1);//cyan green
        printf("Adjusting GYRO_SMOOTH_THRESHOLD. Current: %.2f", *adjustPtr);
        break;
      }
      case 6: {
        adjustPtr = &gyro_tight_threshold;
        memOffset = OFF_TT;
        clampHigh = 1000;
        incDiv = 1;
        led_reset();
        led_vmset(LED_2, 200, 800, -1);
        led_vmset(LED_3, 400, 600, -1);//yellow green
        printf("Adjusting gyro_tight_threshold. Current: %.2f", *adjustPtr);
        break;
      }
      case 7: {
        adjustPtr = &unpower;
        memOffset = OFF_UN;
        clampHigh = 2;
        incDiv = 100;
        led_reset();
        led_vmset(LED_1, 200, 800, -1);
        led_vmset(LED_2, 400, 600, -1);//purple red
        printf("Adjusting UNPOWER. Current: %.2f", *adjustPtr);
        break;
      }
      case 8: {
        adjustPtr = &virtual_scale;
        memOffset = OFF_VS;
        clampHigh = 10;
        incDiv = 100;
        led_reset();
        led_vmset(LED_2, 200, 800, -1);
        led_vmset(LED_1, 400, 600, -1);//purple blue
        printf("Adjusting VIRTUAL_SCALE. Current: %.2f", *adjustPtr);
        break;
      }
      case 9: {
        adjustPtr = &gyro_space;
        memOffset = OFF_GS;
        led_reset();
        led_vmset(LED_3, 200, 800, -1);
        led_vmset(LED_1, 400, 600, -1);//cyan blue
        printf("Adjusting GYRO_SPACE.", 0);
        break;
      }
      case 10: {
        adjustPtr = &undeadzone_inner;
        memOffset = OFF_UI;
        clampHigh = 1;
        incDiv = 100;
        combo_run(flashRedGreen);
        printf("Adjusting UNDEADZONE_inner. Current: %.2f", *adjustPtr);
        break;
      }
      case 0: {//yes, this is case 0. Putting outer next to inner
        adjustPtr = &undeadzone_outer;
        memOffset = OFF_UO;
        clampHigh = 1;
        incDiv = 100;
        combo_run(flashGreenRed);
        printf("Adjusting UNDEADZONE_OUTER. Current: %.2f", *adjustPtr);
        break;
      }
    }
  }

  int8 incPtr;
  int8 *spacePtr = &gyro_space;//need to match ptr type?
  if (incPtr =
  (event_active(BUTTON_10) ?  10 : 0) +
  (event_active(BUTTON_11) ? -10 : 0) +
  (event_active(BUTTON_12) ?  -1 : 0) +
  (event_active(BUTTON_13) ?   1 : 0)) {
    if (adjustPtr == &gyro_space) {
      spacePtr = &gyro_space;
      const char *spaceOpts[] = { "LOCAL", "PLAYER_TURN", "PLAYER_LEAN", "WORLD_TURN", "WORLD_LEAN"};
      const uint8 dispSpace[] = {_L_, _P_, _P_, _W_, _W_};
      *spacePtr = incPtr >= 0 ? (*spacePtr + 1) % 5 : *spacePtr;//Usual circular mod logic
      *spacePtr = incPtr <= 0 ? (*spacePtr + 4) % 5 : *spacePtr;//same logic in reverse
      display_overlay(dispSpace[*spacePtr], 1000);
      printf(spaceOpts[*spacePtr]);
      return;
    }
    *adjustPtr = clamp(*adjustPtr + (fix32)incPtr/(fix32)incDiv, 0.0, (fix32)clampHigh);
    *adjustPtr = round(*adjustPtr * 100.0) / 100.0;//shave off thousands values that mysteriously appear
    printf("Current: %.2f", *adjustPtr);
    if (*adjustPtr == 0.0 || *adjustPtr == (fix32)clampHigh) led_vmset(LED_2, 50, 50, 10);
  }

  if (event_active(BUTTON_15)) {//East
    //reload setting stored from pmem
    if (adjustPtr == &gyro_space) {
      pmem_read(memOffset, spacePtr);
      printf("Reverted to initial value.", 0);
      return;
    }
    pmem_read(memOffset, adjustPtr);
    printf("Reverted to initial value: %.2f", *adjustPtr);
  }
}

void commitSettings() {
  pmem_write(OFF_NS, min_gyro_sens);
  pmem_write(OFF_XS, max_gyro_sens);
  pmem_write(OFF_NT, min_gyro_threshold);
  pmem_write(OFF_XT, max_gyro_threshold);
  pmem_write(OFF_TT, gyro_tight_threshold);
  pmem_write(OFF_ST, gyro_smooth_threshold);
  pmem_write(OFF_VS, virtual_scale);
  pmem_write(OFF_UN, unpower);
  pmem_write(OFF_UI, undeadzone_inner);
  pmem_write(OFF_UO, undeadzone_outer);
  pmem_write(OFF_GS, gyro_space);
  pmem_save();
  if (min_gyro_sens < max_gyro_sens) {
    printf("You have MIN_GYRO_SENS and MAX_GYRO_SENS set to different values.<br>\
    Remember, this will linearly accelerate between the two values at the configured thresholds.<br>\
    Give them both the same value to disable acceleration.");
  }
}

void processMouse(fix32 x, fix32 y) {
  static fix32 diffX, diffY;
  fix32 mouseXint, mouseYint;
  x /= mouseCalibration;
  y /= mouseCalibration;

  if (DEBUG) x += IN_FlickStick();//flickstick test

  mouseXint = round(x + diffX);//add value lost from previous rounding
  mouseYint = round(y + diffY);//then round to nearest int
  diffX = (x + diffX) - mouseXint;//store diff lost to rounding
  diffY = (y + diffY) - mouseYint;
  diffX -= 0.01 * diffX;//offset accumulation of sensor noise
  diffY -= 0.01 * diffY;
  mouse_set(MOUSE_X, (int32)mouseXint);
  mouse_set(MOUSE_Y, (int32)mouseYint);
}

void flickRotate() {
  static fix32 unwrap;
  //flick-rotate logic
  fix32 x = get_actual(STICK_1_X);
  fix32 y = get_actual(STICK_1_Y);
  fix32 length = pythag(x, y);
  fix32 lengthRad = atan2(x, -y) / PI * 100.0;
  //unwrap = lengthRad - round((lengthRad - unwrap) / 200.0)*200.0;//LUNS
  //if (abs(unwrap) > 150.0) unwrap = lengthRad;
  //fix32 clip = unwrap > 100.0 ? 100.0 : unwrap<-100.0 ?-100.0 : unwrap;
  if (length >= 10.0) {
    //lengthRad = abs(lengthRad) < 50.0 ? clamp(lengthRad * 3.0, -100.0, 100.0) : lengthRad;
    set_val(STICK_1_X, 0.0);
    set_val(STICK_1_Y, 0.0);
    set_val(STICK_1_X, lengthRad);
  }
}

void flickRotate2() {
  //currently just breaks outder deadzone
  fix32 x = get_val(STICK_1_X);
  fix32 y = get_val(STICK_1_Y);
  fix32 undeadzone_outerNew = undeadzone_outer * 100.0;
  if (x >= 98.0 - undeadzone_outerNew) {
    set_val(STICK_1_X, x + undeadzone_outerNew);
  }
  if (x <= -98.0 + undeadzone_outerNew) {
    set_val(STICK_1_X, x - undeadzone_outerNew);
  }
}

void GYRO_OFF(bool val) {
  if (val) gyroBlocked = TRUE;
  else gyroBlocked = FALSE;
  //accelGrav[0] = get_actual(ACCEL_1_Z);
  //accelGrav[1] = get_actual(ACCEL_1_X);//GPC eroneously swaps Y and Z axis
  //accelGrav[2] = get_actual(ACCEL_1_Y);//accel: Y should be up/down, Z should be front/back
  //gyroVelocity[0] = get_actual(GYRO_1_Z);//gyro: Y should be yaw, Z should be roll
  //gyroVelocity[1] = get_actual(GYRO_1_X);
  //gyroVelocity[2] = get_actual(GYRO_1_Y);
}

void processInput() {
  //calibrating
  if (calibrating) {
    static uint16 count = 0;
    static int16 calibrationCount = -1;
    if (calibrationCount == -1) pmem_read(OFF_CC, &calibrationCount);
    offsetSamples++;
    accumulatedOffset[0] += gyroVelocity[0];
    accumulatedOffset[1] += gyroVelocity[1];
    accumulatedOffset[2] += gyroVelocity[2];
    const uint8 disp[] = { _0_, _1_, _2_, _3_, _4_, _5_, _6_, _7_, _8_, _9_, _G_};
    if (count % (calibrationCount / 10) == 0) {//exec on integer progress
      if (led_vmget(LED_1) != -1) led_vmset(LED_3, 50, 250, -1);//blink green
      uint8 dispf = count / (calibrationCount / 10);//0-10
      display_overlay(disp[dispf], 1000);//0-10 on titantwo display
      printf("calibrating! %d%%", count / (calibrationCount / 100));//0-100
    }
    count++;
    if (count > calibrationCount) {
      led_reset();
      led_vmset(LED_3, 50, 50, 10);
      calibrating = FALSE;
    }
  }

  calibratedGyro[0] = gyroVelocity[0] - getCalibrationOffset(0);
  calibratedGyro[1] = gyroVelocity[1] - getCalibrationOffset(1);
  calibratedGyro[2] = gyroVelocity[2] - getCalibrationOffset(2);

  //smoothing (from wiki)
  if (gyro_smooth_threshold > 0.0) {
    getTieredSmoothedInput(&calibratedGyro[0], &calibratedGyro[1], gyro_smooth_threshold / 2.0, gyro_smooth_threshold);
  }

  //tightening
  if (gyro_tight_threshold > 0.0) {
    getTightenedInput(&calibratedGyro[0], &calibratedGyro[1], gyro_tight_threshold);
  }

  //accelerating
  if (min_gyro_sens < max_gyro_sens) {//only when valid
    processGyroAccel(calibratedGyro[0], calibratedGyro[1], calibratedGyro[2],
    accelGrav[0], accelGrav[1], accelGrav[2],
    min_gyro_sens, max_gyro_sens, min_gyro_threshold, max_gyro_threshold);
  } else {
    processGyroInput(calibratedGyro[0], calibratedGyro[1], calibratedGyro[2],
    accelGrav[0], accelGrav[1], accelGrav[2], min_gyro_sens);
  }
}

void processGyroInput(fix32 calibratedGyro0, fix32 calibratedGyro1, fix32 calibratedGyro2,
fix32 accelGrav0, fix32 accelGrav1, fix32 accelGrav2, fix32 gyroSensitivity) {
  // gyro: [0]y [1]x [2]z == [yaw] [pitch] [roll]
  //accel: [0]y [1]x [2]z == [left/right] [up/down] [front/back]
  if (gyro_space == 0) {//LOCAL
    camera[0] = calibratedGyro0;
    camera[1] = calibratedGyro1;
  } else {//prep for player space and world space
    fix32 gravLength = sqrt(sq(accelGrav0) + sq(accelGrav1) + sq(accelGrav2));
    fix32 normGravX = 0.0;
    fix32 normGravY = 0.0;
    fix32 normGravZ = 0.0;
    if (gravLength > 0.0) {//accel on a scale of -1:1
      normGravY = accelGrav0 * (1.0 / gravLength);
      normGravX = accelGrav1 * (1.0 / gravLength);
      normGravZ = accelGrav2 * (1.0 / gravLength);
    }
    fix32 flatness = abs(normGravY);
    fix32 upness = abs(normGravZ);
    fix32 sideReduction = clamp((max(flatness, upness) - 0.125) / 0.125, 0.0, 1.0);
    //parade of variables where GPC compiler hates what JSM source does
    fix32 worldYaw, pitchAxisX, pitchAxisY, pitchAxisZ, pitchAxisLengthSquared,
    rollAxisX, rollAxisY, rollAxisZ, rollAxisLengthSquared;
    #define gravDotPitchAxis normGravX//shave off a fix32 via macro

    if (gyro_space == 1 || gyro_space == 2) {
      if (gyro_space == 1) {//PLAYER_TURN (from JSM)
        // grav dot gyro axis (but only Y (yaw) and Z (roll))
        worldYaw = -(normGravY * calibratedGyro0
        + normGravZ * calibratedGyro2);/*sign flip appeases mystery GPC wrath*/
        int8 worldYawSign = worldYaw < 0.0 ? -1 : 1;
        #define yawRelaxFactor 2.0//shave off a fix32 via macro
        //const fix32 yawRelaxFactor = 2.0; // 60 degree buffer
        //const fix32 yawRelaxFactor = 1.41; // 45 degree buffer
        //const fix32 yawRelaxFactor = 1.15; // 30 degree buffer
        camera[0] = (fix32)worldYawSign
        * min(abs(worldYaw) * yawRelaxFactor
        , pythag(calibratedGyro0, calibratedGyro2));//TODO test with pythag
      } else {//PLAYER_LEAN (from JSM)
        // project local pitch axis (X) onto gravity plane
        // super simple since our point is only non-zero in one axis
        pitchAxisX = 1.0 - normGravX * gravDotPitchAxis;
        pitchAxisY = -normGravY * gravDotPitchAxis;
        pitchAxisZ = -normGravZ * gravDotPitchAxis;
        // normalize
        pitchAxisLengthSquared = sq(pitchAxisX) + sq(pitchAxisY) + sq(pitchAxisZ);
        if (pitchAxisLengthSquared > 0.0) {
          // world roll axis is cross (yaw, pitch)
          rollAxisX = pitchAxisY * normGravZ - pitchAxisZ * normGravY;
          rollAxisY = pitchAxisZ * normGravX - pitchAxisX * normGravZ;
          rollAxisZ = pitchAxisX * normGravY - pitchAxisY * normGravX;

          // normalize
          rollAxisLengthSquared = sq(rollAxisX) + sq(rollAxisY) + sq(rollAxisZ);
          if (rollAxisLengthSquared > 0.0) {
            rollAxisX *= 1.0 / sqrt(rollAxisLengthSquared);//lengthReciprocal
            rollAxisY *= 1.0 / sqrt(rollAxisLengthSquared);//lengthReciprocal
            rollAxisZ *= 1.0 / sqrt(rollAxisLengthSquared);//lengthReciprocal

            fix32 worldRoll = rollAxisY * calibratedGyro0 + rollAxisZ * calibratedGyro2;
            int8 worldRollSign = worldRoll < 0.0 ? -1 : 1;
            #define rollRelaxFactor 1.41 //shave off a fix32 via macro
            //const fix32 rollRelaxFactor = 2.0; // 60 degree buffer
            //const fix32 rollRelaxFactor = 1.41; // 45 degree buffer
            //const fix32 rollRelaxFactor = 1.15; // 30 degree buffer
            camera[0] = sideReduction
            * ((fix32)worldRollSign
            * min(abs(worldRoll) * rollRelaxFactor
            , pythag(calibratedGyro0, calibratedGyro2)));//TODO test with pythag
          }
        }
      }
      camera[1] = calibratedGyro1;//player space still uses local pitch

    } else {//WORLD_TURN or WORLD_LEAN (from JSM)
      //prep for world space
      // grav dot gyro axis
      worldYaw = normGravX * calibratedGyro1 + normGravY * calibratedGyro0 + normGravZ * calibratedGyro2;
      // project local pitch axis (X) onto gravity plane
      // super simple since our point is only non-zero in one axis
      pitchAxisX = 1.0 - normGravX * gravDotPitchAxis;
      pitchAxisY = -normGravY * gravDotPitchAxis;
      pitchAxisZ = -normGravZ * gravDotPitchAxis;
      // normalize
      pitchAxisLengthSquared = sq(pitchAxisX) + sq(pitchAxisY) + sq(pitchAxisZ);
      if (pitchAxisLengthSquared > 0.0) {
        pitchAxisX *= 1.0 / sqrt(pitchAxisLengthSquared);//lengthReciprocal
        pitchAxisY *= 1.0 / sqrt(pitchAxisLengthSquared);//lengthReciprocal
        pitchAxisZ *= 1.0 / sqrt(pitchAxisLengthSquared);//lengthReciprocal

        // get global pitch factor (dot)
        camera[1] = +(pitchAxisX * calibratedGyro1
        + pitchAxisY * calibratedGyro0
        + pitchAxisZ * calibratedGyro2);/*sign flip appeases mystery GPC wrath*/
        // by the way, pinch it towards the nonsense limit
        camera[1] *= sideReduction;

        if (gyro_space == 4) {//WORLD_LEAN
          // world roll axis is cross (yaw, pitch)
          rollAxisX = pitchAxisY * normGravZ - pitchAxisZ * normGravY;
          rollAxisY = pitchAxisZ * normGravX - pitchAxisX * normGravZ;
          rollAxisZ = pitchAxisX * normGravY - pitchAxisY * normGravX;

          // normalize
          rollAxisLengthSquared = sq(rollAxisX) + sq(rollAxisY) + sq(rollAxisZ);
          if (rollAxisLengthSquared > 0.0) {
            rollAxisX *= 1.0 / sqrt(rollAxisLengthSquared);//lengthReciprocal
            rollAxisY *= 1.0 / sqrt(rollAxisLengthSquared);//lengthReciprocal
            rollAxisZ *= 1.0 / sqrt(rollAxisLengthSquared);//lengthReciprocal

            // get global roll factor (dot)
            camera[0] = rollAxisX * calibratedGyro1
            + rollAxisY * calibratedGyro0
            + rollAxisZ * calibratedGyro2;
            // by the way, pinch because we rely on a good pitch vector here
            camera[0] *= sideReduction;
          }
        }
      }

      if (gyro_space == 3) {//WORLD_TURN
        camera[0] = -(worldYaw);/*sign flip appeases mystery GPC wrath*/
      }
    }
  }
  camera[0] *= gyroSensitivity;/*Apply sens regardless of space*/
  camera[1] *= gyroSensitivity;
  if (gyroBlocked) camera[0] = camera[1] = 0.0;
}

//accel
void processGyroAccel(fix32 calibratedGyro0, fix32 calibratedGyro1, fix32 calibratedGyro2,
fix32 accelGrav0, fix32 accelGrav1, fix32 accelGrav2,
fix32 minGyroSens, fix32 maxGyroSens, fix32 minGyroThreshold, fix32 maxGyroThreshold) {
  // apply calibration factor
  // get input velocity
  fix32 magnitude = pythag(calibratedGyro0, calibratedGyro1);
  // calculate position on min_gyro_threshold to max_gyro_threshold scale
  magnitude -= minGyroThreshold;
  if (magnitude < 0.0) {
    magnitude = 0.0;
  }
  fix32 denom = maxGyroThreshold - minGyroThreshold;
  fix32 newSensitivity;
  if (denom <= 0.0) {
    newSensitivity = magnitude > 0.0 ? 1.0 : 0.0; // if min threshold overlaps max threshold, pop up to
    // max lowSens as soon as we're above min threshold
  } else {
    newSensitivity = magnitude / denom;
  }
  if (newSensitivity > 1.0) {
    newSensitivity = 1.0;
  }
  // interpolate between low sensitivity and high sensitivity
  newSensitivity = lerp(minGyroSens, maxGyroSens, newSensitivity);
  //newSensitivityX = lerp(minGyroSensX, maxGyroSensX, newSensitivity);
  //newSensitivityY = lerp(minGyroSensY, maxGyroSensY, newSensitivity);
  processGyroInput(calibratedGyro0, calibratedGyro1, calibratedGyro2,
  accelGrav0, accelGrav1, accelGrav2, newSensitivity);
}

fix32 getCalibrationOffset(int32 n) {
  if (offsetSamples == 0) {
    return 0.0;
  }
  if (n==0) {
    return accumulatedOffset[0] / (fix32)offsetSamples;
  } else if (n==1) {
    return accumulatedOffset[1] / (fix32)offsetSamples;
  }
  return accumulatedOffset[2] / (fix32)offsetSamples;
}

void resetCalibration() {
  offsetSamples = 0;
  accumulatedOffset = 0.0;
}

combo recalibrate {
  resetCalibration();
  wait(0);
  wait(2000); //wait 2s for the user to take hands off controller
  calibrating = TRUE;
}

// smoothing buffer - adapted from blog
void getSmoothedInput(fix32 *avg) {
  static uint8 CurrentInputIndex = -1;
  CurrentInputIndex = (CurrentInputIndex + 1) % SMOOTH_BUFFER_SIZE;

  static fix32 InputBuffer0[SMOOTH_BUFFER_SIZE];
  static fix32 InputBuffer1[SMOOTH_BUFFER_SIZE];

  InputBuffer0[CurrentInputIndex] = avg[0];
  InputBuffer1[CurrentInputIndex] = avg[1];

  uint8 i;
  for (i = 0; i < SMOOTH_BUFFER_SIZE; i++) {
    avg[0] += InputBuffer0[i];
    avg[1] += InputBuffer1[i];
  }
  avg[0] /= (fix32)SMOOTH_BUFFER_SIZE;
  avg[1] /= (fix32)SMOOTH_BUFFER_SIZE;
}

void getTieredSmoothedInput(fix32 *input0, fix32 *input1, fix32 threshold1, fix32 threshold2) {
  fix32 inputMagnitude = pythag(*input0, *input1);
  fix32 directWeight = (inputMagnitude - threshold1) / (threshold2 - threshold1);
  directWeight = clamp(directWeight, 0.0, 1.0);
  fix32 avg[2];
  avg[0] = *input0 * (1.0 - directWeight);
  avg[1] = *input1 * (1.0 - directWeight);
  getSmoothedInput(&avg);
  *input0 = (*input0 * directWeight) + avg[0];
  *input1 = (*input1 * directWeight) + avg[1];
}

/*//smoothing from jsm
fix32 gyroLength = pythag(calibratedGyro0, calibratedGyro1);
// do gyro smoothing
// convert gyro smooth time to number of samples
uint16 numGyroSamples = GYRO_SMOOTH_TIME * 1000.0 / tick_time.get();
if (numGyroSamples < 1) numGyroSamples = 1; // need at least 1 sample
uint16 threshold = GYRO_SMOOTH_THRESHOLD;
jc->GetSmoothedGyro(gyroX, gyroY, gyroLength, threshold / 2.0f, threshold, int(numGyroSamples), gyroX, gyroY);

// now, honour gyro_cutoff_speed
gyroLength = sqrt(sq(gyroX) + sq(gyroY));//TODO test with pythag
auto speed = GYRO_CUTOFF_SPEED;
auto recovery = GYRO_CUTOFF_RECOVERY;
if (recovery > speed) {
// we can use gyro_cutoff_speed
float gyroIgnoreFactor = (gyroLength - speed) / (recovery - speed);
if (gyroIgnoreFactor < 1.0f) {
if (gyroIgnoreFactor <= 0.0f) {
gyroX = gyroY = gyroLength = 0.0f;
} else {
gyroX *= gyroIgnoreFactor;
gyroY *= gyroIgnoreFactor;
gyroLength *= gyroIgnoreFactor;
}
}
}
else if (speed > 0.0f && gyroLength < speed) {
// gyro_cutoff_recovery is something weird, so we just do a hard threshold
gyroX = gyroY = gyroLength = 0.0f;
}

void GetSmoothedGyro(fix32 x, fix32 y, fix32 length, fix32 bottomThreshold, fix32 topThreshold, int maxSamples, fix32 &outX, fix32 &outY) {
// this is basically the same as we use for smoothing flick-stick rotations, but because this deals in vectors, it's a slightly different function. Not worth abstracting until it'll be used in more ways
// which item in the circular smoothing buffer will we write over?
_frontGyroSample--;
if (_frontGyroSample < 0)
_frontGyroSample = MaxGyroSamples - 1;
float immediateFactor;
if (topThreshold <= bottomThreshold) {
immediateFactor = length < bottomThreshold ? 0.0f : 1.0f;
} else {
immediateFactor = (length - bottomThreshold) / (topThreshold - bottomThreshold);
}
// clamp to [0, 1] range
if (immediateFactor < 0.0f) immediateFactor = 0.0f;
else if (immediateFactor > 1.0f) immediateFactor = 1.0f;
float smoothFactor = 1.0f - immediateFactor;
// now we can push the smooth sample (or as much of it as we want smoothed)
FloatXY frontSample = _gyroSamples[_frontGyroSample] = { x * smoothFactor, y * smoothFactor };
// and now calculate smoothed result
float xResult = frontSample.x() / maxSamples;
float yResult = frontSample.y() / maxSamples;
for (int i = 1; i < maxSamples; i++) {
int rotatedIndex = (_frontGyroSample + i) % MaxGyroSamples;
frontSample = _gyroSamples[rotatedIndex];
xResult += frontSample.x() / maxSamples;
yResult += frontSample.y() / maxSamples;
}
// finally, add immediate portion
outX = xResult + x * immediateFactor;
outY = yResult + y * immediateFactor;
}*/

void getTightenedInput(fix32 *input0, fix32 *input1, fix32 threshold) {
  fix32 inputMagnitude = pythag(*input0, *input1);
  if (inputMagnitude < threshold) {
    fix32 inputScale = inputMagnitude / threshold;
    *input0 *= inputScale;
    *input1 *= inputScale;
  }
}

fix32 ipythag(uint32 a, uint32 b) {//ipythag thanks to ME. (and wikipedia)
  a = (a*a) + (b*b);
  int32 c, d = 0x40000000;
  while (d > a) d >>= 2;
  while (d) {
    if (a >= c + d) {
      a -= c + d;
      c >>= 1;
      c += d;
    } else {
      c >>= 1;
    }
    d >>= 2;
  }

  return (fix32)c;
}

fix32 pythag(fix32 a, fix32 b) {
  if (abs((int)a) <= 128 && abs((int)b) <= 128) return sqrt(sq(a) + sq(b));
  if (abs((int)a) <= 23170 && abs((int)b) <= 23170) return ipythag((int)a, (int)b);
  printf("pythag return exceeded fix32");
  return - 1.0;
}

bool processGyroStick(fix32 stickX, fix32 stickY) {
  //GPC has all axis represented in -100 to 100
  //This is not the case with JSM
  fix32 stickLength = pythag(stickX, stickY);
  fix32 livezoneSize = 1.0 - undeadzone_outer - undeadzone_inner;
  //in order to correctly combine gyro and stick, we need to calculate what the stick
  //aiming is supposed to be doing, add gyro result to it, and convert back to stick
  if (unpower == 0.0) {
    unpower = 1.0;
  }

  fix32 stickVelocity = pow(clamp((stickLength - undeadzone_inner) / livezoneSize, 0.0, 1.0), unpower) * (fix32)maxStickGameSpeed * virtual_scale;
  fix32 expectedX = 0.0;
  fix32 expectedY = 0.0;
  gyroStickX = 0.0;
  gyroStickY = 0.0;

  if (stickVelocity > 0.0) {
    expectedX = (stickX / stickLength) * stickVelocity;
    expectedY = (stickY / stickLength) * stickVelocity;
  }

  //The original JSM function translates in-game turn velocity into units equivalent
  //to real world turn velocity, because a gyroscope reports real velocity.
  //TitanTwo reports everything including gyro on a scale of -100 to 100, so we need to work around this.
  expectedX += camera[0] * 3.6; //the gyro readings top out at roughly 100.
  expectedY += camera[1] * 3.6; //100 * 3.6 = 360.

  fix32 targetGyroVelocity = pythag(expectedX / 100.0, expectedY / 100.0) * 100.0; //sq(expected) exceeds fix32 range, oops!

  // map gyro velocity to achievable range in 0-1
  fix32 gyroInStickStrength = targetGyroVelocity >= (fix32)maxStickGameSpeed ? 1.0 : targetGyroVelocity / (fix32)maxStickGameSpeed;
  // UNPOWER curve
  if (unpower != 0.0) {
    gyroInStickStrength = pow(gyroInStickStrength, 1.0 / unpower);
  }

  // remap to between inner and outer deadzones
  if (gyroInStickStrength > 0.010) {
    gyroInStickStrength = undeadzone_inner + gyroInStickStrength * livezoneSize;
    gyroStickX = (expectedX / targetGyroVelocity) * gyroInStickStrength;
    gyroStickY = (expectedY / targetGyroVelocity) * gyroInStickStrength;
  }

  if (LOGGING) logger(camera[0], camera[1], stickX, stickY, stickLength, stickVelocity, expectedX,
  expectedY, targetGyroVelocity, gyroInStickStrength, gyroStickX, gyroStickY);

  return stickLength > undeadzone_inner;
}

//flickstick from yquake2
#define FLICK_TIME 1
static fix32 target_angle;
static uint8 flick_progress = FLICK_TIME;
fix32 IN_FlickStick() {
  static bool is_flicking;
  static fix32 last_stick_angle;
  //fix32 procesed = stick;
  fix32 angle_change = 0.0;

  fix32 stickX = get_actual(STICK_1_X);
  fix32 stickY = get_actual(STICK_1_Y);
  fix32 mag = pythag(stickX, stickY);

  if (mag > 99.0) {// flick!
    fix32 stick_angle = (180.0 / PI) * atan2(stickX, -stickY);

    if (!is_flicking) {
      // Flicking begins now, with a new target
      is_flicking = TRUE;
      flick_progress = 0;
      target_angle = stick_angle;
    } else {
      // Was already flicking, just turning now
      angle_change = stick_angle - last_stick_angle;

      // angle wrap: https://stackoverflow.com/a/11498248/1130520
      angle_change = mod(angle_change + 180.0, 360.0);
      if (angle_change < 0.0) {
        angle_change += 360.0;
      }
      angle_change -= 180.0;
    }

    last_stick_angle = stick_angle;
  } else {
    is_flicking = FALSE;
  }

  // Flick Stick: flick in progress, changing the yaw angle to the target progressively
  if (flick_progress < FLICK_TIME) {
    camera[0] += target_angle;// * rotation_factor[flick_progress];
    flick_progress++;
  }

  return angle_change *10.0;
}



/*//jsm flick
// settings
fix32 flickStickThreshold = 99;//TODO convert to uint8 later
fix32 FlickTime = 0.1;
fix32 TurnSmoothThreshold = 0.1;

fix32 handleFlickStick() {
  bool isFlicking;
  bool ROTATE_ONLY;
  uint8 flick_snap_mode = 0;
  fix32 flick_rotation_counter;
  #define FLICK_DEADZONE_ANGLE 0
  fix32 stickX = get_actual(STICK_1_X);
  fix32 stickY = get_actual(STICK_1_Y);
  fix32 stickLength = pythag(stickX, stickY);

  if (isFlicking) flickStickThreshold *= 0.9;
  if (stickLength >= flickStickThreshold) {
    fix32 stickAngle = atan2(-stickX, stickY);
    if (!isFlicking) {
      // bam! new flick!
      isFlicking = TRUE;
      if (!ROTATE_ONLY) {
        if (flick_snap_mode > 0) {
          //snapmode
        }
        if (abs(stickAngle) * (180.0 / PI) < FLICK_DEADZONE_ANGLE) stickAngle 0.0;
        uint32 started_flick = system_time();
        fix32 delta_flick = stickAngle;
        fix32 flick_percent_done = 0.0;
        //jc->ResetSmoothSample();
        flick_rotation_counter = stickAngle; // track all rotation for this flick
        //COUT << "Flick: " << setprecision(3) << stickAngle * (180.0f / (float)PI) << " degrees" << endl;
      }
    } else {
      if (!FLICK_ONLY) {
        // not new? turn camera?
        fix32 lastStickAngle = atan2f(-lastOffsetX, lastOffsetY);
        fix32 angleChange = stickAngle - lastStickAngle;
        // https://stackoverflow.com/a/11498248/1130520
        angleChange = mod(angleChange + PI, 2.0 * PI);
        if (angleChange < 0) angleChange += 2.0 * PI;
        angleChange -= PI;
        flick_rotation_counter += angleChange; // track all rotation for this flick
        fix32 flickSpeedConstant = isMouse ? REAL_WORLD_CALIBRATION * mouseCalibrationFactor / IN_GAME_SENS : 1.0;
        fix32 flickSpeed = -(angleChange * flickSpeedConstant);
        int8 maxSmoothingSamples = min(NumSamples, (int)ceil(64.0 / tick_time.get ));// target a max smoothing window size of 64ms
        fix32 stepSize = 0.01;// and we only want full on smoothing when the stick change each time we poll it is approximately the minimum stick resolution
        // the fact that we're using radians makes this really easy

        //ROTATE_SMOOTH_OVERRIDE would go here if we implemented it

        if (!isMouse) {
          // convert to a velocity
          camSpeedX *= 180.0 / (PI * 0.001 * tick_time.get);
        }
      }
    }
  } else if (isFlicking) {
    // was a flick! how much was the flick and rotation?
    if (!FLICK_ONLY && !ROTATE_ONLY) {
      fix32 last_flick_and_rotation = abs(flick_rotation_counter) / (2.0 * PI);
    }
    isFlicking = false;
  }
  // do the flicking. this works very differently if it's mouse vs stick
  if (isMouse) {
    fix32 secondsSinceFlick = ((float)chrono::duration_cast<chrono::microseconds>(jc->time_now - jc->started_flick).count()) / 1000000.0;
    fix32 newPercent = secondsSinceFlick / 0.1; //getSetting(SettingID::FLICK_TIME);

    // don't divide by zero
    if (abs(delta_flick) > 0.0) {
      newPercent /= abs(delta_flick) / PI;
    }

    if (newPercent > 1.0) newPercent = 1.0;
    // warping towards 1.0
    fix32 oldShapedPercent = 1.0 - flick_percent_done;
    oldShapedPercent *= oldShapedPercent;
    oldShapedPercent = 1.0 - oldShapedPercent;
    flick_percent_done = newPercent;
    newPercent = 1.0 - newPercent;
    newPercent *= newPercent;
    newPercent = 1.0 - newPercent;
    fix32 camSpeedChange = (newPercent - oldShapedPercent) * delta_flick * REAL_WORLD_CALIBRATION * -mouseCalibrationFactor / IN_GAME_SENS;
    camSpeedX += camSpeedChange;

    return camSpeedX;
  } else {
    fix32 secondsSinceFlick = ((float)chrono::duration_cast<chrono::microseconds>(jc->time_now - jc->started_flick).count()) / 1000000.0;
    fix32 flickTime = abs(delta_flick) / (maxStickGameSpeed * PI / 180.f);

    if (secondsSinceFlick <= flickTime) {
      camSpeedX -= delta_flick >= 0 ? maxStickGameSpeed : -maxStickGameSpeed;
    }

    if (gyroOutput == flickStickOutput) {
      gyroXVelocity += camSpeedX;
      processGyroStick(jc, 0.f, 0.f, 0.f, flickStickOutput == GyroOutput::LEFT_STICK ? StickMode::LEFT_STICK : StickMode::RIGHT_STICK, false);
    } else {
      fix32 tempGyroXVelocity = gyroXVelocity;
      fix32 tempGyroYVelocity = gyroYVelocity;
      gyroXVelocity = camSpeedX;
      gyroYVelocity = 0.0;
      processGyroStick(jc, 0.f, 0.f, 0.f, flickStickOutput == GyroOutput::LEFT_STICK ? StickMode::LEFT_STICK : StickMode::RIGHT_STICK, true);
      gyroXVelocity = tempGyroXVelocity;
      gyroYVelocity = tempGyroYVelocity;
    }

    return 0.0;
  }
}*/

uint32 profiler(char func, uint32 startTime) {
  uint32 elapsed = startTime - system_time();
  printf("func %d", elapsed);
  return elapsed;
}

void logger(fix32 camera0, fix32 camera1, fix32 stickX, fix32 stickY, fix32 stickLength,
fix32 stickVelocity, fix32 expectedX, fix32 expectedY, fix32 targetGyroVelocity,
fix32 gyroInStickStrength, fix32 gyroStickX, fix32 gyroStickY) {
  static uint8 delayLog = 0;
  delayLog++;
  if (delayLog >= 75) {
    printf("<big><br>\
    camera0: %.1f<br>\
    camera1: %.1f<br>\
    stickX: %.2f<br>\
    stickY: %.2f<br>\
    stickLength: %.2f<br>\
    stickVelocity: %.2f<br>\
    expectedX: %.2f<br>\
    expectedY: %.2f<br>\
    targetGyroVelocity: %.2f<br>\
    gyroInStickStrength: %.2f<br>\
    gyroStickX: %.2f<br>\
    gyroStickY: %.2f", camera0, camera1, stickX, stickY, stickLength, stickVelocity,
    expectedX, expectedY, targetGyroVelocity, gyroInStickStrength, gyroStickX, gyroStickY);
    delayLog = 0;
  }
}

void logger2(fix32 input1, fix32 input2, fix32 input3) {
  static uint8 delayLog = 0;
  delayLog++;
  if (delayLog >= 75) {
    printf("<big><br>\
    %.2f<br>\
    %.2f<br>\
    %.2f", input1, input2, input3);
    delayLog = 0;
  }
}
/* Interactive Config
I make use of empty [sections] to be heading titles in the GUI.
Then I group [detailed-config-name] elements under those empty sections.
This allows me to have nice GUI titles, while also allowing for accurate
and readable config names in IC-ByteTable.

<shortdesc>
Use your controller's gyro to aim! Supports outputting as mouse or joystick. See interactive config for help.
</shortdesc>

<keywords>
gyro mouse flickstick jsm joyshockmapper dualsense steamcontroller dualshock ds4 joycon motion
</keywords>

<cfgdesc>
[Presets]
shortdesc =
control = config
item        = Steam Controller:#19:08#33:00FA
item        = Deadzone and VIRTUAL_STICK_CALIBRATION Finder:0100000000#19:000000000000000000#3D:00190000
item        = Acceleration Example:#01:00000000#1A:00008000000200000014000003200000
item        = Threshold Testing Example (Motion only above 500 degrees per second):#01:00000000#1A:000000000001000001F4000001F50000
item        = User Preset 1:
item        = User Preset 2:
[Layout]
[GYRO_OUTPUT]
shortdesc = GYRO_OUTPUT
byteoffset = OFF_GO
bitsize = 8
bitoffset = 0
control = radiobox
default = 0
item = MOUSE
item = RIGHT_STICK
item = LEFT_STICK (incomplete)
group = true
[Layout Flickstick checkbox]
shortdesc = 
byteoffset = OFF_FS
bitsize = 1
bitoffset = 3
control = checkbox
default = 0
item = Flickstick
groupcol = true
[Layout windingStick checkbox]
shortdesc = 
byteoffset = OFF_WS
bitsize = 1
bitoffset = 4
control = checkbox
default = 0
item = Rotational stick aim
group = true
[Layout stickDisable checkbox]
shortdesc = 
byteoffset = OFF_SD
bitsize = 1
bitoffset = 2
control = checkbox
default = 0
item = Disable right joystick in mouse mode
group = true

[Sensitivities]
[Acceleration]
[MIN_GYRO_SENS]
shortdesc = MIN_GYRO_SENS
byteoffset = OFF_NS
bitsize = 32
bitoffset = 0
control = spinboxf
decimals = 2
default = 00100
minimum = 00000
maximum = 10000
step = 001
group = true
[MAX_GYRO_SENS]
shortdesc = MAX_GYRO_SENS
byteoffset = OFF_XS
bitsize = 32
bitoffset = 0
control = spinboxf
decimals = 2
default = 00100
minimum = 00000
maximum = 10000
step = 001
group = true
[MIN_GYRO_THRESHOLD]
shortdesc = MIN_GYRO_THRESHOLD
byteoffset = OFF_NT
bitsize = 32
bitoffset = 0
control = spinboxf
decimals = 2
default = 000000
minimum = 000000
maximum = 100000
step = 001
groupcol = true
[MAX_GYRO_THRESHOLD]
shortdesc = MAX_GYRO_THRESHOLD
byteoffset = OFF_XT
bitsize = 32
bitoffset = 0
control = spinboxf
decimals = 2
default = 000000
minimum = 000000
maximum = 100000
step = 0010
group = true

[Virtual Controller Stick Config]
[UNDEADZONE_INNER]
shortdesc = UNDEADZONE_INNER
byteoffset = OFF_UI
bitsize = 32
bitoffset = 0
control = spinboxf
default = 000
decimals = 2
step = 005
minimum = 000
maximum = 100
groupcol = true
[SPACE UNDEADZONE_OUTER]
control = space
default = 5
group = true
[UNDEADZONE_OUTER]
shortdesc = UNDEADZONE_OUTER
byteoffset = OFF_UO
bitsize = 32
bitoffset = 0
control = spinboxf
default = 000
decimals = 2
step = 005
minimum = 000
maximum = 100
group = true
[SPACE VIRTUAL_SCALE]
control = space
default = 25
group = true
[VIRTUAL_SCALE]
shortdesc = VIRTUAL_SCALE
byteoffset = OFF_VS
bitsize = 32
bitoffset = 0
control = spinboxf
decimals = 2
default = 0100
minimum = 0001
maximum = 1000
step = 001
group = true
[SPACE UNPOWER]
control = space
default = 25
group = true
[UNPOWER]
shortdesc = UNPOWER
byteoffset = OFF_UN
bitsize = 32
bitoffset = 0
control = spinboxf
decimals = 2
default = 000
minimum = 000
maximum = 200
step = 010
group = true
[mini info UNDEADZONE]
shortdesc = Prevent game deadzone from interfering with gyro aim
control = info
groupcol = true
[SPACE mini info VIRTUAL_SCALE]
control = space
default = 60
group = true
[mini info VIRTUAL_SCALE]
shortdesc = Scale virtual stick output
control = info
group = true
[SPACE mini info UNPOWER]
control = space
default = 25
group = true
[mini info UNPOWER]
shortdesc = Counter game power curve
control = info
group = true

[VIRTUAL_STICK_CALIBRATION]
shortdesc = VIRTUAL_STICK_CALIBRATION
byteoffset = OFF_MS
bitsize = 16
bitoffset = 0
control = spinbox
default = 360
minimum = 0001
maximum = 1000
step = 000010
[mini info VIRTUAL_STICK_CALIBRATION]
shortdesc = The maximum speed you can look around in game, in degrees per second
control = info
groupcol = true

[Misc]
[Calibrate gyro on startup]
shortdesc = 
byteoffset = OFF_CB
bitsize = 1
bitoffset = 1
control = checkbox
default = 1
item = Calibrate gyro on startup
group = true
[Calibration samples]
shortdesc = Calibration samples
byteoffset = OFF_CC
bitsize = 16
bitoffset = 0
control = dial
default = 01000
minimum = 00100
maximum = 05000
step = 50
group = true
[gyro_tight_threshold]
shortdesc = Tightening threshold
byteoffset = OFF_TT
bitsize = 32
bitoffset = 0
control = spinboxf
decimals = 2
default = 0
minimum = 000000
maximum = 100000
step = 100
groupcol = true
[GYRO_SMOOTH_THRESHOLD]
shortdesc = GYRO_SMOOTH_THRESHOLD
byteoffset = OFF_ST
bitsize = 32
bitoffset = 0
control = spinboxf
decimals = 2
default = 0
minimum = 000000
maximum = 100000
step = 100
group = true
[Outer deadzone override]
shortdesc = 
byteoffset = OFF_OO
bitsize = 1
bitoffset = 0
control = checkbox
default = 0
item = stick outer deadzone
group = true

[GYRO_SPACE]
shortdesc = The logic by which we interpret the gyro
bitsize = 8
byteoffset = OFF_GS
control = combobox
default = 0
item = LOCAL
item = PLAYER_TURN
item = PLAYER_LEAN
item = WORLD_TURN
item = WORLD_LEAN

[Output Protocol]
shortdesc = Remember this output next time you run the script
bitsize = 8
byteoffset = OFF_OP
control = combobox
default = 0
item = TitanTwo configured global default
item = PROTOCOL_AUTO
item = PROTOCOL_PS4
item = PROTOCOL_XB360
item = PROTOCOL_HID (HID required for mouse)
item = Bluetooth PROTOCOL_HID (HID required for mouse)
item = Bluetooth PROTOCOL_PS3
item = Bluetooth PROTOCOL_PS4
item = Bluetooth PROTOCOL_XB360
item = Bluetooth PROTOCOL_XB1
item = Bluetooth PROTOCOL_SWITCH
item = Bluetooth PROTOCOL_WII

[Info: uJSM?]
shortdesc = <<<MULTILINE
A significant chunk of this script was adapted from the PC software <a href=https://github.com/Electronicks/JoyShockMapper>JoyShockMapper</a>. Given that I've only implemented a subset of JSM features, and since the target platform is an embedded device (TitanTwo), I felt uJSM (micro JSM) was an appropriate name.
If you have any interest in using gyro aim on PC, go check out JoyShockMapper! I've intentionally kept all the settings in uJSM the same as they appear in JSM, so basic configuration should feel familiar :)

Anything capitalized works exactly the same in the PC JoyShockMapper. If it's not capitalized, then it's either not in JoyShockMapper, or it's configured in a different way.
MULTILINE
control = info

[Info: Mouse vs Joystick?]
shortdesc = <<<MULTILINE
Gyro is functionally equivalent to mouse, and is best experienced when mapped to a mouse.
Of course, you won't be able to use mouse mode on most console games, but mouse mode does work pretty well when paired with a XIM.

Joystick out is emulating a joystick, but how this feels will vary from game to game. In fact, since gyro is basically a mouse, it will feel a lot like you're trying to map a mouse to the joystick! This code is not as comprehensive as XIM smart translators, though.

NOTE: the HID output protocol still outputs the whole controller as a joystick, and the XIM does see it! Controller remaps will still take effect. Disable the right joystick to prevent double output where it may occur.
Alternatively, you can use Gtuner to configure device options and check "Disable Joystick from Multi Interface HID output".
MULTILINE
control = info

[Info: Flickstick]
shortdesc = <<<MULTILINE
The new aim method that I believe will one day replace traditional stick aim!
MULTILINE
control = info

[Info: Rotational stick aim]
shortdesc = <<<MULTILINE
Since flickstick on joystick output is severely compromised, I have implemented a component of flickstick: rotation. This keeps normal left/right stick aim, but allows for fine precision aim by pushing the stick forward and moving left or right. This allows you to keep using sensitivities that would otherwise be too high for a stick (which is a prerequisite for XIM). Normal left/right will allow for snappy turns, rotation allows for precise slow aim. Disables Y axis, so you'll want to map GYRO_OFF to something to re-orient yourself vertically.
MULTILINE
control = info

[Info: Sensitivities]
shortdesc = <<<MULTILINE
Gyro Sensitivity gets multiplied against sensor data to increase or decrease the output speed.

Stick sensitivity configures the sensitivity of the joystick in the same way, independently of gyro motion.

Unpower: If a game processes the joystick with a power curve, setting the exponent of the curve here will cancel out that curve for gyro output.
MULTILINE
control = info

[Info: Virtual Controller]
shortdesc = <<<MULTILINE
VIRTUAL_STICK_CALIBRATION
MULTILINE
control = info

[Info: Max Stick Game Speed]
shortdesc = <<<MULTILINE
Max stick game speed is a concept from JSM; it's supposed to represent how fast (in degrees/s) the game allows you to look around using the stick. If you set it correctly in JSM, (game stick logic permitting) the motion of the controller will be translated 1:1 to the game. Additionally, this allows you to translate your preferred sensitivity between different games.

However! Most games have a low max speed which will clip fast movements (you know this if you've used mouse input on your Titan), the TitanTwo does not report gyro data to the script in degrees/s, and the specific number (unique per game) is pretty difficult to determine with precision. 

What this setting does in abstract is scale your motion to the range of the virtual joystick. Lower values will reach 100% output quicker- allowing you to easily hit the fastest turn speed with minimal motion, but move too fast and the game camera won't keep up. Higher values allow more room for quicker and more aggressive motion (like quick panic flicks), but you start to lose precision for slower movements.

You can guestimate the game's value with a timer. Set inner deadzone to 100% and enable Deadzone Finder. This will cause you to spin around in game at max speed. Look down at the ground in game and find a line to pivot around. Start the timer and count the number of complete rotations your character does in a given amount of time. The longer you let the timer run, the more accurate your estimate will be. Multiply [number of rotations] * 360, and divide that by [seconds] to get your max stick game speed. If you spun around 12 times in 20 seconds, then (12 * 360) / 20 = 216.
MULTILINE
control = info

[Info: Un-Deadzone]
shortdesc = <<<MULTILINE
Each game has its own joystick inner deadzone set by the developers.
If this script knows where the deadzone is, it can use that as the starting point for gyro outpoint, effectively eliminating the inner deadzone.

The outer deadzone can be used to avoid non-linear jumps in sensitivity programmed into the game, which feel unnatural with gyro aim.

Note that outer deadzone config option is asking for the size of the deadzone, not where the deadzone starts.
If there's a jump in acceleration at 92% stick tilt, you want an 8% outer deadzone.

Deadzone Finder helps precisely find inner deadzone. Titan will tilt the joystick at the configured inner deadzone. Find the highest value of inner deadzone where the camera DOESN'T move. Start at 25% and work your way up or down from there.

Stick overrides outer deadzone: Some games have a sharp jump in acceleration when the joystick is tilted near 100%.
This is undesirable for gyro aim, but might be desirable while using the stick because it helps you turn around faster in game.
MULTILINE
control = info

[Info: Acceleration]
shortdesc = <<<MULTILINE
Define a linear acceleration between the two sensitivities at the given movement speed thresholds.
There will be no acceleration below the min threshold nor above the max threshold.
MULTILINE
control = info

[Info: Misc]
shortdesc = <<<MULTILINE
Calibrate gyro on startup: Place the controller on a flat surface and do not touch it until the LEDs stop flashing: they'll turns green when finished.
The script is averaging sensor data to filter out unwanted sensor noise: this helps fight drift.
NOTE! Steam controller will enter an idle mode after about 6 seconds. You may have to touch one of the pads to get calibration to continue. Do so very gently, so as to not accidentally add any movement during calibration.

Calibration samples: How many samples to collect during calibration. The controller's true polling rate will limit how fast samples are collected.

Tightening squishes output towards zero below the threshold, used to help prevent jitter when trying to hold still at higher sensitivities.

Smoothing helps reduce jitter below the threshold, useful for unsteady hands, or to smooth out noise with higher sensitivities.
MULTILINE
control = info

[Info: Speed Thresholds?]
shortdesc = <<<MULTILINE
Configure thresholds in values of degrees per second: how fast you are turning the controller. Unfortunately the TitanTwo doesn't present raw gyro data in this way, so the threshold number here is imperfect. I've tried to play with the numbers to make it close to reality, but you may find the settings are not exactly the same as what you'd use in JSM for PC.
Try values like 10 when trying to set a threshold that activates when moving as slow as possible. The highest sensible values is somewhere under 1000.

You can test where a threshold is by enabling acceleration with MIN_GYRO_SENS 0, MAX_GYRO_SENS 1. Then set MIN_GYRO_THRESHOLD to the desired test number, MAX_GYRO_THRESHOLD to one above that, and see how fast you must move the controller to get a response.
MULTILINE
control = info

[Credits]
shortdesc = <<<MULTILINE
Most of the concepts used and a lot of the code came from Jibb Smart's gyro wiki:
<a href=http://gyrowiki.jibbsmart.com>http://gyrowiki.jibbsmart.com</a>
As well as the JoyShockMapper project by Jibb Smart and Electronicks:
<a href=https://github.com/Electronicks/JoyShockMapper>https://github.com/Electronicks/JoyShockMapper</a>
Thank you!
MULTILINE
control = info
</cfgdesc>
*/
