#pragma METAINFO("uJSM.gpc", 0, 1, "Aelius")

/*

END USER CUSTOMIZATION GUIDE - README
* Create a mapping for GYRO_OFF() to ratchet the controller.
-- if (is_active(yourbutton)) {GYRO_OFF();}
* Initiate a recalibration with combo_run(recalibrate).
-- You may need to do this periodically.
-- Place controller on a flat and steady surface before calibrating.
-- The combo will wait two seconds to give you time to get your hands off.
* SMOOTH_BUFFER_SIZE controls how many samples the smoothing function collects.
-- More smoothing means more latency.
* HID output protocol still outputs the controller!
-- And the XIM does see it!

NOTES
- The TitanTwo maps gyro data onto a range of 0.00-102.399994 rather than reporting angular velocity.
- Beware math functions which may exceed fix32 range (check calls to pythag)

TODO - first release
current maxStickGameSpeed results in too low value for some reason, recheck
joystick clearly needs mouse's rollover code, or something
--JSM seems to have way less of this cutoff than uJSM
--maybe because the way titan presents gyro range
notes and config guide up there should be given a once over
be sure there are safeties when no config val exists in pmem
in heavybullets, jsm roughly 2x as sensitive given same settings?
add a config.h to include?
--gyro off needs to be configurable
make GYRO_OFF work as a one liner instead of this if then true else false nonsense.
xim specific axis fix?
does override outer also override virtual scale outer? it should
finish stickIsUndead bool (affects both processStick any processGyroStick)
finish processStick
document gyro space
assign keyboard keys for HID output, because titan joystick out to xim is cursed
document mappings for xim
  Right Stick X = Joystick Left Z
  Right Stick Y = Joystick Right Z
    Y is reversed!? and xim won't invert it? Well, most games offer an inverted aim option...

TODO - eventually
GYRO_SENS X Y
flickstick joystick
"tightening" is really cutoff recovery
the gyro_in_stick_strength creates an unsatisfying deadzone
--trade for pulsing joystick at low speeds?
refuse debug if running from titan?
--iirc pmem is null when running from IDE
validate accel sign against steam controller dsu
--they're different. Check worldspace code against SC signage
read out 10s digit to segdisp in liveAdjust
titan deltaTime internal? Resolve mystery once and for all.
rename camera[] to two variables that make more sense
--same with calibratedGyro
--function names could probably do with a revision
why did pythag cause a flip in world(?) space (retest with new pythag)
why do I have a mystery pitch axis flip in world space
kalman 1d?
possibly use blinkerSync to map joystick curve, predict UNPOWER setting
read out 'gyro' to seg disp
implement checks for calls that exceed data type (and definitely put the check in pythag)
revisit globally dividing gyro vals by -25
possibly leverage IC config memory for user presets
fix left stick output (hold)
user configurable smoothing buffer size in IC?
--translate flickstick joystick hold to aim? feels like regular gyro aim cuts off too fast. check how jsm feels
revisit winding flickstick
--runs get_actual; surely it can pull from another area we already poll the stick
--add haptic bump when leaving 0/deadzone
optimize variables and memory usage
--offsetSamples and the local count are SO SIMILAR
--apply simpler if logic where possible (reference blinkerSync(), liveAdjust())
--possibly convert thresholds to uint
--learn structs, use them
mouse_ring and mouse_area and scroll_wheel
figure out why higher than 2ms kills cpu
--implement function profiling
removed the "gyro on while joystick held" code, needs to be readded
logger needs variable argument list length
separate blinkersync, liveadjust to a different script. we out of bytecode!
your gyrostick code is scaling the stick output weird, and jsm seems fine?
--real stick axis can read 100 for a spell, script always has it changing
--and 100% on any axis is a narrow target
jsm gyrostick undeadzone code actually enforces a deadzone for the stick.
--apply undeadzone to stick too and give pull request for jsm
jsm is missing generic UNDEADZONE_INNER, outer, virtualscale, power
--ez pull request if worth doing
jsm default livezone size is assumed to be 1 but can be 1.1 in practice.
--implement azeron like test to find real size.
with the way I share one var for swapping left/right stick, deadzone might not apply to both

*/

#include <mouse.gph>
#include <keyboard.gph>
#include <display.gph>
#define SMOOTH_BUFFER_SIZE 32 //Steam Input's maximum is 40
#define FLICKSTICK_THRESHOLD 0.995
#define STICK_X stick[0] //Dirty hack for readability
#define STICK_Y stick[1]
#define STICK_LENGTH stick[2]
#define GYRO_X tmp1
#define GYRO_Y tmp2
#define GYRO_Z tmp3

#define OFF_GO 0  // 1byte // GYRO_OUTPUT
#define OFF_GS 1  // 1byte // GYRO_SPACE
#define OFF_OP 2  // 1byte // output_protocol
#define OFF_CC 3  // 2byte // calibrationCount aka num of cal samples
#define OFF_MS 5  // 2byte // maxStickGameSpeed aka VIRTUAL_STICK_CALIBRATION
#define OFF_OO 7  // 1bit  // outerStickOverride
#define OFF_CB 7  // 1bit  // calibrating
#define OFF_SD 7  // 1bit  // stickDisable
#define OFF_FS 7  // 1bit  // flickStick
#define OFF_SU 7  // 1bit  // stickIsUndead
#define OFF_NT 10 // 4byte // MIN_GYRO_THRESHOLD
#define OFF_XT 14 // 4byte // MAX_GYRO_THRESHOLD
#define OFF_NS 18 // 4byte // MIN_GYRO_SENS
#define OFF_XS 22 // 4byte // MAX_GYRO_SENS
#define OFF_UI 26 // 4byte // UNDEADZONE_INNER
#define OFF_UO 30 // 4byte // UNDEADZONE_OUTER
#define OFF_VS 34 // 4byte // VIRTUAL_SCALE
#define OFF_UN 38 // 4byte // UNPOWER
#define OFF_TT 42 // 4byte // gyro_tight_threshold
#define OFF_ST 46 // 4byte // GYRO_SMOOTH_THRESHOLD
#define OFF_DI 50 // 4byte // DEADZONE_INNER
#define OFF_IG 54 // 4byte // IN_GAME_SENS
#define OFF_RW 58 // 4byte // REAL_WORLD_CALIBRATION
#define OFF_DO 62 // 4byte // DEADZONE_OUTER

//Misc Globals
uint16 offsetSamples;
fix32 gyroVelocity[3];//0 is Yaw (Z), 1 is Pitch (X), 2 is Roll (Y)
fix32 accelGrav[3];// Using order Z X Y again
fix32 calibratedGyro[3];
fix32 accumulatedOffset[3];
fix32 camera[2];
fix32 stick[3];
fix32 gyroStickX;
fix32 gyroStickY;
bool configMode = FALSE;
const bool DEBUG = FALSE;
bool gyroBlocked;


//Settings with initial defaults

//gyro_output options
#define MOUSE 0
#define RIGHT_STICK 1
#define LEFT_STICK 2
uint8 gyro_output = RIGHT_STICK;

//outProtocol options
#define NO_CHANGE 0
#define USB_AUTO 1
#define USB_PS4 2
#define USB_360 3
#define USB_HID 4
#define BT_HID 5
#define BT_PS3 6
#define BT_PS4 7
#define BT_360 8
#define BT_XB1 9
#define BT_NSW 10
#define BT_WII 11
uint8 outProtocol = NO_CHANGE;

bool flickStick = FALSE;
bool calibrating = TRUE;
bool outerStickOverride = TRUE;
bool stickDisable = FALSE;
bool stickIsUndead = FALSE;

//gyro_space options
#define LOCAL 0
#define PLAYER_TURN 1
#define PLAYER_LEAN 2
#define WORLD_TURN 3
#define WORLD_LEAN 4
uint8 gyro_space = LOCAL;

uint16 maxStickGameSpeed = 160; //JSM default 360
fix32 min_gyro_sens = 1.0;
fix32 max_gyro_sens = 1.0;
fix32 unpower = 0.0;
fix32 virtual_scale = 1.0;
fix32 mouseCalibration;
//candidates for uint to save on mem
fix32 undeadzone_inner = 0.0;
fix32 undeadzone_outer = 0.0;
fix32 deadzone_inner = 0.15;
fix32 deadzone_outer = 0.1;
fix32 gyro_smooth_threshold = 0.0;
fix32 gyro_tight_threshold = 0.0;
fix32 min_gyro_threshold = 0.0;
fix32 max_gyro_threshold = 0.0;
fix32 realWorldCalibration = 40.0;
fix32 in_game_sens = 1.0;

init {
  pmem_load();

  //uint8 only
  gyro_output        = pmem_read(OFF_GO);
  gyro_space         = pmem_read(OFF_GS);
  outProtocol        = pmem_read(OFF_OP);
  //bools
  outerStickOverride = (pmem_read(OFF_OO)>>0) & 0b1;
  calibrating        = (pmem_read(OFF_CB)>>1) & 0b1;
  stickDisable       = (pmem_read(OFF_SD)>>2) & 0b1;
  flickStick         = (pmem_read(OFF_FS)>>3) & 0b1;
  stickIsUndead      = (pmem_read(OFF_SU)>>4) & 0b1;

  //fix32s & int16s
  pmem_read(OFF_UI, &undeadzone_inner);
  pmem_read(OFF_UO, &undeadzone_outer);
  pmem_read(OFF_DI, &deadzone_inner);
  pmem_read(OFF_DO, &deadzone_outer);
  pmem_read(OFF_VS, &virtual_scale);
  pmem_read(OFF_UN, &unpower);
  pmem_read(OFF_MS, &maxStickGameSpeed);
  pmem_read(OFF_NT, &min_gyro_threshold);
  pmem_read(OFF_XT, &max_gyro_threshold);
  pmem_read(OFF_NS, &min_gyro_sens);
  pmem_read(OFF_XS, &max_gyro_sens);
  pmem_read(OFF_TT, &gyro_tight_threshold);
  pmem_read(OFF_ST, &gyro_smooth_threshold);
  pmem_read(OFF_RW, &realWorldCalibration);
  pmem_read(OFF_IG, &in_game_sens);

  mouseCalibration = realWorldCalibration / in_game_sens;
  min_gyro_threshold /= 25.0;//divide thresholds by a guestimated number,
  max_gyro_threshold /= 25.0;//such that they correspond to angular velocity
  gyro_tight_threshold /= 25.0;//(using same number as accel normalized to grav)
  gyro_smooth_threshold /= 25.0;

  switch (outProtocol) {
    case 1:  port_connect(PORT_USB_C, PROTOCOL_AUTO);   break;
    case 2:  port_connect(PORT_USB_C, PROTOCOL_PS4);    break;
    case 3:  port_connect(PORT_USB_C, PROTOCOL_XB360);  break;
    case 4:  port_connect(PORT_USB_C, PROTOCOL_HID);    break;
    case 5:  port_connect(PORT_BT_C,  PROTOCOL_HID);    break;
    case 6:  port_connect(PORT_BT_C,  PROTOCOL_PS3);    break;
    case 7:  port_connect(PORT_BT_C,  PROTOCOL_PS4);    break;
    case 8:  port_connect(PORT_BT_C,  PROTOCOL_XB360);  break;
    case 9:  port_connect(PORT_BT_C,  PROTOCOL_XB1);    break;
    case 10: port_connect(PORT_BT_C,  PROTOCOL_SWITCH); break;
    case 11: port_connect(PORT_BT_C,  PROTOCOL_WII);    break;
    default: break;
  }

  if (DEBUG) {
    gyro_output = MOUSE;
    stickDisable = FALSE;
    outerStickOverride = FALSE;
    calibrating = TRUE;
    flickStick = TRUE;
    undeadzone_inner = 0.40;
    undeadzone_outer = 0.0;
    deadzone_inner = 0.15;
    deadzone_outer = 0.1;
    virtual_scale = 1.0;
    unpower = 0.0;
    maxStickGameSpeed = 360;
    min_gyro_sens = 1.0;
    max_gyro_sens = 1.0;
    gyro_tight_threshold = 0.0;
    gyro_smooth_threshold = 0.0;
    gyro_space = LOCAL;
    configMode = FALSE;
    stickIsUndead = FALSE;
    in_game_sens = 1.0;
    realWorldCalibration = 2.911;
    mouseCalibration = realWorldCalibration / in_game_sens;
  }
}

main {
  //End user take note!
  //Create your controller to mouse & keyboard binds here
  if  (gyro_output == MOUSE) {
    if (is_active(BUTTON_4)) {//R1/RB suggested as fire for gyro
      mouse_set(MBUTTON_1, TRUE);//Triggers tend to make you wobble controller
    } else if (is_release(BUTTON_4)) {
      mouse_set(MBUTTON_1, FALSE);
    }
    if (is_active(BUTTON_5)) {
      key_set(KEY_SPACEBAR, TRUE);
    } else if (is_release(BUTTON_5)) {
      key_set(KEY_SPACEBAR, FALSE);
    }
    if (is_active(BUTTON_15)) GYRO_OFF(TRUE);
    else GYRO_OFF(FALSE);
  }
  
  if (DEBUG) {
    //temp binds for testing
    if (is_active(BUTTON_4)) {
      mouse_set(MBUTTON_1, TRUE);
    } else if (is_release(BUTTON_4)) {
      mouse_set(MBUTTON_1, FALSE);
    }
    if (is_active(BUTTON_5)) {
      key_set(KEY_SPACEBAR, TRUE);
    } else if (is_release(BUTTON_5)) {
      key_set(KEY_SPACEBAR, FALSE);
    }
    if (is_active(BUTTON_15)) GYRO_OFF(TRUE);
    else GYRO_OFF(FALSE);
  }

  //Bind to enter config mode
  if (is_active(BUTTON_4)//while R1 is held...
  && event_active(BUTTON_7)//press L1...
  && (abs(get_actual(ACCEL_1_Z)) < 3.0)) {//when controller is held sideways
    configMode = configMode ? FALSE : TRUE;
    if (configMode) {
      ffb_set(FFB_1, 100.0, 50);
      printf("Entered live config",0);
    } else {
      ffb_set(FFB_2, 100.0, 250);
      printf("Exited live config & saved settings",0);
      commitSettings();
    }
  }

  if (is_active(BUTTON_4)//while R1 is held...
  && is_active(BUTTON_5)//while R2 is held...
  && event_active(BUTTON_3)) combo_run(recalibrate);//press Start to recalibrate

  if (configMode) liveAdjust();

  if (gyro_output == RIGHT_STICK || gyro_output == MOUSE) {
    STICK_X = get_actual(STICK_1_X) / 100.0;//JSM logic operates on 0-1
    STICK_Y = get_actual(STICK_1_Y) / 100.0;
  }
  if (gyro_output == LEFT_STICK) {//Left stick
    STICK_X = get_actual(STICK_2_X) / 100.0;//JSM logic operates on 0-1
    STICK_Y = get_actual(STICK_2_Y) / 100.0;
  }
  STICK_LENGTH = pythag(STICK_X, STICK_Y);


  static uint8 delay;
  delay += (uint8)elapsed_time();
  if (delay >= 2) {//loop 500Hz fastest, or Titan will be sad
    if (calibrating) {
      //True Hz detection thanks to consoletuner discord member ME.
      static fix32 old_gyros;
      fix32 f_gX = get_actual(GYRO_1_X);
      fix32 f_gY = get_actual(GYRO_1_Y);
      fix32 f_gZ = get_actual(GYRO_1_Z);
      fix32 gyros = sqrt(sq(f_gX) + sq(f_gY) + sq(f_gZ));
      //Check for new values from sensor
      if (old_gyros != gyros) {
        old_gyros = gyros;
        processInput();//collect only uinque samples in calibration
      }
    }
    accelGrav[0]    = get_actual(ACCEL_1_Z);//GPC Y and Z axis differs vs JSM
    accelGrav[1]    = get_actual(ACCEL_1_X);//What JSM expects: (I think?)
    accelGrav[2]    = get_actual(ACCEL_1_Y);//accel: Y up/down, Z front/back
    gyroVelocity[0] = get_actual(GYRO_1_Z);//gyro: Y yaw, Z roll
    gyroVelocity[1] = get_actual(GYRO_1_X);
    gyroVelocity[2] = get_actual(GYRO_1_Y);

    //Process input regardless of duplicate readings.
    //Filtering for unique samples appears to undo what is probably Titan's
    //internally managed deltaTime.
    if (!calibrating) processInput();
    if (gyro_output == MOUSE) {
      processMouse(camera[0], camera[1]);
    }
    if (gyro_output >= 1) {
      processGyroStick(STICK_X, STICK_Y); //can return bool
    }
    delay = 0;
  }

  /* set_val must be outside polling loop! Lest values bounce to 0 every cycle */

  //Controller is still passed as a joystick in HID output, it may be active
  if (!gyro_output && stickDisable) {//gyro_output is not zero (mouse)
    set_val(STICK_1_X, 0.0);//disable right joystick
    set_val(STICK_1_Y, 0.0);
  } else {//Apply controller options, even in mouse mode.
    processStick(&stick);
  }

  if  (gyro_output) {//nonzero means joystick
    if ((min_gyro_sens == 0.0 && max_gyro_sens == 0.0) && gyro_output == RIGHT_STICK) {
      //hack to help with finding deadzones more quickly
      set_val(STICK_1_X, undeadzone_inner * 100.0);
      //hack to help with finding max stick game speed
      if (!calibrating && !configMode) blinkerSync();
    } else if (gyro_output == RIGHT_STICK) {
      set_val(STICK_1_X, gyroStickX * 100.0);
      set_val(STICK_1_Y, gyroStickY * 100.0);
    } else if (gyro_output == LEFT_STICK) {
      set_val(STICK_2_X, gyroStickX * 100.0);
      set_val(STICK_2_Y, gyroStickY * 100.0);
    }
    //Hack for games with accel boost at outer zone:
    //skip outer deadzone logic for the actual joystick
    //Gyro is still subject to deadzone and thus remains linear,
    //but stick now has access to game's accel for snappy stick turning
    #define OUTER_OVERRIDE_VAL 95.0
    if (outerStickOverride) {
      if (abs(STICK_X) >= OUTER_OVERRIDE_VAL) {
        int8 signX = STICK_X > 0.0 ? 1 : -1;
        set_val(STICK_1_X, (gyroStickX + (undeadzone_outer * (fix32)signX)) * 100.0);
      }
      if (abs(STICK_Y) >= OUTER_OVERRIDE_VAL) {
        int8 signY = STICK_Y > 0.0 ? 1 : -1;
        set_val(STICK_1_Y, (gyroStickY + (undeadzone_outer * (fix32)signY)) * 100.0);
      }
    }
  }
}

void blinkerSync() {
  #define B_S 4 //rolling average array size
  static uint16 blinkHz = 1000;//start at 1 blink per 1000ms
  if (led_vmget(LED_1) == 0) {
    led_vmset(LED_1, 50, blinkHz - 50, 2);
  }

  int8 incHz;
  if (incHz =
  (event_active(BUTTON_10) ? -10 : 0) +//D-UP: faster
  (event_active(BUTTON_11) ?  10 : 0) +//D-DOWN: slower
  (event_active(BUTTON_12) ?   1 : 0) +//D-LEFT: slower
  (event_active(BUTTON_13) ?  -1 : 0)) {//D-RIGHT: faster
    blinkHz += (int16)incHz;
    printf("<br>Current interval: %dms<br>\
    Suggested VIRTUAL_STICK_CALIBRATION: %d degrees/s", blinkHz, 360000 / blinkHz);
  }
  if (event_active(BUTTON_14)) {//North: reset phase
    led_vmset(LED_1, 50, blinkHz - 50, 2);
    printf("<br>blinkHz phase reset.<br>\
    Suggested VIRTUAL_STICK_CALIBRATION: %d degrees/s", 360000 / blinkHz);
  }
  if (event_active(BUTTON_16)) {//South: calculate rolling average
    static uint16 lastTime = 0;
    static uint16 timeDiff[B_S];//store B_S samples
    static uint8 currentIndex = -1;
    currentIndex = (currentIndex + 1) % B_S;
    if (lastTime != 0) timeDiff[currentIndex] = (uint16)system_time() - lastTime;
    lastTime = system_time();
    uint8 i;
    for (blinkHz = i = 0; i < B_S; i++) {
      blinkHz += timeDiff[i];
    }
    blinkHz /= B_S;
    led_vmset(LED_1, 50, blinkHz - 50, 2);//reset phase
    printf("<br>Current interval (rolling average of 4): %dms (last 1: %dms)<br>\
    Suggested VIRTUAL_STICK_CALIBRATION: %d degrees/s", blinkHz, timeDiff[currentIndex], 360000 / blinkHz);
  }

  maxStickGameSpeed = 360000 / clamp(blinkHz, 100, 6000);//degrees per second
  if (event_active(BUTTON_3)) {//START,+,SHARE, whathaveyou button
    pmem_write(OFF_MS, maxStickGameSpeed);
    pmem_save();
    printf("Saved",0);
  }
}

combo flashBlueRed {
  led_reset();
  led_vmset(LED_1, 200, 800, -1);
  wait(0);
  wait(200);
  led_vmset(LED_2, 200, 800, -1);
}
combo flashRedBlue {
  led_reset();
  led_vmset(LED_2, 200, 800, -1);
  wait(0);
  wait(200);
  led_vmset(LED_1, 200, 800, -1);
}
combo flashBlueGreen {
  led_reset();
  led_vmset(LED_1, 200, 800, -1);
  wait(0);
  wait(200);
  led_vmset(LED_3, 200, 800, -1);
}
combo flashGreenBlue {
  led_reset();
  led_vmset(LED_3, 200, 800, -1);
  wait(0);
  wait(200);
  led_vmset(LED_1, 200, 800, -1);
}
combo flashRedGreen {
  led_reset();
  led_vmset(LED_2, 200, 800, -1);
  wait(0);
  wait(200);
  led_vmset(LED_3, 200, 800, -1);
}
combo flashGreenRed {
  led_reset();
  led_vmset(LED_3, 200, 800, -1);
  wait(0);
  wait(200);
  led_vmset(LED_2, 200, 800, -1);
}

void liveAdjust() {
  static fix32 *adjustPtr = &min_gyro_sens;//Assignment doesn't actually seem to take?
  static uint16 clampHigh;
  static uint8 incDiv;
  static uint8 settingsIndex = 0;
  static uint8 memOffset = OFF_NS;
  if (event_active(BUTTON_16)) {//South
    settingsIndex  = (settingsIndex  + 1) % 11;//change me to match total case count!
    switch (settingsIndex) {
      case 1: {//brackets because gtuner won't "reindent" switch/case alone
        adjustPtr = &min_gyro_sens;
        memOffset = OFF_NS;
        clampHigh = 10;
        incDiv = 100;
        combo_run(flashBlueRed);
        printf("Adjusting MIN_GYRO_SENS. Current: %.2f", *adjustPtr);
        break;
      }
      case 2: {
        adjustPtr = &max_gyro_sens;
        memOffset = OFF_XS;
        clampHigh = 10;
        incDiv = 100;
        combo_run(flashRedBlue);
        printf("Adjusting MAX_GYRO_SENS. Current: %.2f", *adjustPtr);
        break;
      }
      case 3: {
        adjustPtr = &min_gyro_threshold;
        memOffset = OFF_NT;
        clampHigh = 1000;
        incDiv = 1;
        combo_run(flashBlueGreen);
        printf("Adjusting MIN_GYRO_THRESHOLD. Current: %.2f", *adjustPtr);
        break;
      }
      case 4: {
        adjustPtr = &max_gyro_threshold;
        memOffset = OFF_XT;
        clampHigh = 1000;
        incDiv = 1;
        combo_run(flashGreenBlue);
        printf("Adjusting MAX_GYRO_THRESHOLD. Current: %.2f", *adjustPtr);
        break;
      }
      case 5: {
        adjustPtr = &gyro_smooth_threshold;
        memOffset = OFF_ST;
        clampHigh = 1000;
        incDiv = 1;
        led_reset();
        led_vmset(LED_1, 200, 800, -1);
        led_vmset(LED_3, 400, 600, -1);//cyan green
        printf("Adjusting GYRO_SMOOTH_THRESHOLD. Current: %.2f", *adjustPtr);
        break;
      }
      case 6: {
        adjustPtr = &gyro_tight_threshold;
        memOffset = OFF_TT;
        clampHigh = 1000;
        incDiv = 1;
        led_reset();
        led_vmset(LED_2, 200, 800, -1);
        led_vmset(LED_3, 400, 600, -1);//yellow green
        printf("Adjusting gyro_tight_threshold. Current: %.2f", *adjustPtr);
        break;
      }
      case 7: {
        adjustPtr = &unpower;
        memOffset = OFF_UN;
        clampHigh = 2;
        incDiv = 100;
        led_reset();
        led_vmset(LED_1, 200, 800, -1);
        led_vmset(LED_2, 400, 600, -1);//purple red
        printf("Adjusting UNPOWER. Current: %.2f", *adjustPtr);
        break;
      }
      case 8: {
        adjustPtr = &virtual_scale;
        memOffset = OFF_VS;
        clampHigh = 10;
        incDiv = 100;
        led_reset();
        led_vmset(LED_2, 200, 800, -1);
        led_vmset(LED_1, 400, 600, -1);//purple blue
        printf("Adjusting VIRTUAL_SCALE. Current: %.2f", *adjustPtr);
        break;
      }
      case 9: {
        adjustPtr = &gyro_space;
        memOffset = OFF_GS;
        led_reset();
        led_vmset(LED_3, 200, 800, -1);
        led_vmset(LED_1, 400, 600, -1);//cyan blue
        printf("Adjusting GYRO_SPACE.", 0);
        break;
      }
      case 10: {
        adjustPtr = &undeadzone_inner;
        memOffset = OFF_UI;
        clampHigh = 1;
        incDiv = 100;
        combo_run(flashRedGreen);
        printf("Adjusting UNDEADZONE_inner. Current: %.2f", *adjustPtr);
        break;
      }
      case 0: {//yes, this is case 0. Putting outer next to inner
        adjustPtr = &undeadzone_outer;
        memOffset = OFF_UO;
        clampHigh = 1;
        incDiv = 100;
        combo_run(flashGreenRed);
        printf("Adjusting UNDEADZONE_OUTER. Current: %.2f", *adjustPtr);
        break;
      }
    }
  }

  int8 incPtr;
  int8 *spacePtr = &gyro_space;//need to match ptr type?
  if (incPtr =
  (event_active(BUTTON_10) ?  10 : 0) +
  (event_active(BUTTON_11) ? -10 : 0) +
  (event_active(BUTTON_12) ?  -1 : 0) +
  (event_active(BUTTON_13) ?   1 : 0)) {
    if (adjustPtr == &gyro_space) {
      spacePtr = &gyro_space;
      const char *spaceOpts[] = { "LOCAL", "PLAYER_TURN", "PLAYER_LEAN", "WORLD_TURN", "WORLD_LEAN"};
      const uint8 dispSpace[] = {_L_, _P_, _P_, _W_, _W_};
      *spacePtr = incPtr >= 0 ? (*spacePtr + 1) % 5 : *spacePtr;//Usual circular mod logic
      *spacePtr = incPtr <= 0 ? (*spacePtr + 4) % 5 : *spacePtr;//same logic in reverse
      display_overlay(dispSpace[*spacePtr], 1000);
      printf(spaceOpts[*spacePtr]);
      return;
    }
    *adjustPtr = clamp(*adjustPtr + (fix32)incPtr/(fix32)incDiv, 0.0, (fix32)clampHigh);
    *adjustPtr = round(*adjustPtr * 100.0) / 100.0;//shave off thousands values that mysteriously appear
    printf("Current: %.2f", *adjustPtr);
    if (*adjustPtr == 0.0 || *adjustPtr == (fix32)clampHigh) led_vmset(LED_2, 50, 50, 10);
  }

  if (event_active(BUTTON_15)) {//East
    //reload setting stored from pmem
    if (adjustPtr == &gyro_space) {
      pmem_read(memOffset, spacePtr);
      printf("Reverted to initial value.", 0);
      return;
    }
    pmem_read(memOffset, adjustPtr);
    printf("Reverted to initial value: %.2f", *adjustPtr);
  }
}

void commitSettings() {
  pmem_write(OFF_NS, min_gyro_sens);
  pmem_write(OFF_XS, max_gyro_sens);
  pmem_write(OFF_NT, min_gyro_threshold);
  pmem_write(OFF_XT, max_gyro_threshold);
  pmem_write(OFF_TT, gyro_tight_threshold);
  pmem_write(OFF_ST, gyro_smooth_threshold);
  pmem_write(OFF_VS, virtual_scale);
  pmem_write(OFF_UN, unpower);
  pmem_write(OFF_UI, undeadzone_inner);
  pmem_write(OFF_UO, undeadzone_outer);
  pmem_write(OFF_GS, gyro_space);
  pmem_save();
  if (min_gyro_sens < max_gyro_sens) {
    printf("You have MIN_GYRO_SENS and MAX_GYRO_SENS set to different values.<br>\
    Remember, this will linearly accelerate between the two values at the configured thresholds.<br>\
    Give them both the same value to disable acceleration.");
  }
}

void processMouse(fix32 x, fix32 y) {
  static fix32 diffX, diffY;
  fix32 mouseXint, mouseYint;

  if (flickStick) x += IN_FlickStick(&stick) * mouseCalibration;

  mouseXint = round(x + diffX);//add value lost from previous rounding
  mouseYint = round(y + diffY);//then round to nearest int
  diffX = (x + diffX) - mouseXint;//store diff lost to rounding
  diffY = (y + diffY) - mouseYint;
  diffX -= 0.01 * diffX;//offset accumulation of sensor noise
  diffY -= 0.01 * diffY;
  mouse_set(MOUSE_X, (int32)mouseXint);
  mouse_set(MOUSE_Y, (int32)mouseYint);
}

void GYRO_OFF(bool val) {
  if (val) gyroBlocked = TRUE;
  else gyroBlocked = FALSE;
}

void processInput() {
  //calibrating
  if (calibrating) {
    static uint16 count = 0;
    static int16 calibrationCount = -1;
    //static uint16 calibrationCount = pmem_read(OFF_CC) <= 0 ? 1000 : 1000;//DEBUG
    if (calibrationCount == -1) pmem_read(OFF_CC, &calibrationCount);
    //calibrationCount = pmem_read(OFF_CC) > 0 ? calibrationCount : 1000;
    if (calibrationCount <= 0) calibrationCount = 1000;//default to 1000
    offsetSamples++;
    accumulatedOffset[0] += gyroVelocity[0];
    accumulatedOffset[1] += gyroVelocity[1];
    accumulatedOffset[2] += gyroVelocity[2];
    const uint8 disp[] = { _0_, _1_, _2_, _3_, _4_, _5_, _6_, _7_, _8_, _9_, _G_};
    if (count % (calibrationCount / 10) == 0) {//exec on integer progress
      if (led_vmget(LED_1) != -1) led_vmset(LED_3, 50, 250, -1);//blink green
      uint8 dispf = count / (calibrationCount / 10);//0-10
      display_overlay(disp[dispf], 1000);//0-10 on titantwo display
      printf("calibrating! %d%%", count / (calibrationCount / 100));//0-100
    }
    count++;
    if (count > calibrationCount) {
      led_reset();
      led_vmset(LED_3, 50, 50, 10);
      calibrating = FALSE;
      count = 0;
    }
  }

  calibratedGyro[0] = gyroVelocity[0] - getCalibrationOffset(0);
  calibratedGyro[1] = gyroVelocity[1] - getCalibrationOffset(1);
  calibratedGyro[2] = gyroVelocity[2] - getCalibrationOffset(2);

  //smoothing (from wiki)
  if (gyro_smooth_threshold > 0.0) {
    getTieredSmoothedInput(&calibratedGyro[0], &calibratedGyro[1], gyro_smooth_threshold / 2.0, gyro_smooth_threshold);
  }

  //tightening (from wiki)
  if (gyro_tight_threshold > 0.0) {
    getTightenedInput(&calibratedGyro[0], &calibratedGyro[1], gyro_tight_threshold);
  }
  //cutoffRecovery(&calibratedGyro[0], &calibratedGyro[1], 0.0, 0.01);

  //accelerating
  if (min_gyro_sens < max_gyro_sens) {//only when valid
    processGyroAccel(calibratedGyro[0], calibratedGyro[1], calibratedGyro[2],
    accelGrav[0], accelGrav[1], accelGrav[2],
    min_gyro_sens, max_gyro_sens, min_gyro_threshold, max_gyro_threshold);
  } else {
    processGyroInput(calibratedGyro[0], calibratedGyro[1], calibratedGyro[2],
    accelGrav[0], accelGrav[1], accelGrav[2], min_gyro_sens);
  }
}

void processGyroInput(fix32 calibratedGyro0, fix32 calibratedGyro1, fix32 calibratedGyro2,
fix32 accelGrav0, fix32 accelGrav1, fix32 accelGrav2, fix32 gyroSensitivity) {
  // gyro: [0]y [1]x [2]z == [yaw] [pitch] [roll]
  //accel: [0]y [1]x [2]z == [left/right] [up/down] [front/back]
  if (gyro_space == LOCAL) {
    camera[0] = calibratedGyro0;
    camera[1] = calibratedGyro1;
  } else {//prep for player space and world space
    fix32 gravLength = sqrt(sq(accelGrav0) + sq(accelGrav1) + sq(accelGrav2));
    fix32 normGravX = 0.0;
    fix32 normGravY = 0.0;
    fix32 normGravZ = 0.0;
    if (gravLength > 0.0) {//accel on a scale of -1:1
      normGravY = accelGrav0 * (1.0 / gravLength);
      normGravX = accelGrav1 * (1.0 / gravLength);
      normGravZ = accelGrav2 * (1.0 / gravLength);
    }
    fix32 flatness = abs(normGravY);
    fix32 upness = abs(normGravZ);
    fix32 sideReduction = clamp((max(flatness, upness) - 0.125) / 0.125, 0.0, 1.0);
    //parade of variables where GPC compiler hates what JSM source does
    fix32 worldYaw, pitchAxisX, pitchAxisY, pitchAxisZ, pitchAxisLengthSquared,
    rollAxisX, rollAxisY, rollAxisZ, rollAxisLengthSquared;
    #define gravDotPitchAxis normGravX//shave off a fix32 via macro

    if (gyro_space == PLAYER_TURN || gyro_space == PLAYER_LEAN) {
      if (gyro_space == PLAYER_TURN) {//(from JSM)
        // grav dot gyro axis (but only Y (yaw) and Z (roll))
        worldYaw = -(normGravY * calibratedGyro0
        + normGravZ * calibratedGyro2);/*sign flip appeases mystery GPC wrath*/
        int8 worldYawSign = worldYaw < 0.0 ? -1 : 1;
        #define yawRelaxFactor 2.0//shave off a fix32 via macro
        //const fix32 yawRelaxFactor = 2.0; // 60 degree buffer
        //const fix32 yawRelaxFactor = 1.41; // 45 degree buffer
        //const fix32 yawRelaxFactor = 1.15; // 30 degree buffer
        camera[0] = (fix32)worldYawSign
        * min(abs(worldYaw) * yawRelaxFactor
        , pythag(calibratedGyro0, calibratedGyro2));//TODO test with pythag
      } else {//PLAYER_LEAN (from JSM)
        // project local pitch axis (X) onto gravity plane
        // super simple since our point is only non-zero in one axis
        pitchAxisX = 1.0 - normGravX * gravDotPitchAxis;
        pitchAxisY = -normGravY * gravDotPitchAxis;
        pitchAxisZ = -normGravZ * gravDotPitchAxis;
        // normalize
        pitchAxisLengthSquared = sq(pitchAxisX) + sq(pitchAxisY) + sq(pitchAxisZ);
        if (pitchAxisLengthSquared > 0.0) {
          // world roll axis is cross (yaw, pitch)
          rollAxisX = pitchAxisY * normGravZ - pitchAxisZ * normGravY;
          rollAxisY = pitchAxisZ * normGravX - pitchAxisX * normGravZ;
          rollAxisZ = pitchAxisX * normGravY - pitchAxisY * normGravX;

          // normalize
          rollAxisLengthSquared = sq(rollAxisX) + sq(rollAxisY) + sq(rollAxisZ);
          if (rollAxisLengthSquared > 0.0) {
            rollAxisX *= 1.0 / sqrt(rollAxisLengthSquared);//lengthReciprocal
            rollAxisY *= 1.0 / sqrt(rollAxisLengthSquared);//lengthReciprocal
            rollAxisZ *= 1.0 / sqrt(rollAxisLengthSquared);//lengthReciprocal

            fix32 worldRoll = rollAxisY * calibratedGyro0 + rollAxisZ * calibratedGyro2;
            int8 worldRollSign = worldRoll < 0.0 ? -1 : 1;
            #define rollRelaxFactor 1.41 //shave off a fix32 via macro
            //const fix32 rollRelaxFactor = 2.0; // 60 degree buffer
            //const fix32 rollRelaxFactor = 1.41; // 45 degree buffer
            //const fix32 rollRelaxFactor = 1.15; // 30 degree buffer
            camera[0] = sideReduction
            * ((fix32)worldRollSign
            * min(abs(worldRoll) * rollRelaxFactor
            , pythag(calibratedGyro0, calibratedGyro2)));//TODO test with pythag
          }
        }
      }
      camera[1] = calibratedGyro1;//player space still uses local pitch

    } else {//WORLD_TURN or WORLD_LEAN (from JSM)
      //prep for world space
      // grav dot gyro axis
      worldYaw = normGravX * calibratedGyro1 + normGravY * calibratedGyro0 + normGravZ * calibratedGyro2;
      // project local pitch axis (X) onto gravity plane
      // super simple since our point is only non-zero in one axis
      pitchAxisX = 1.0 - normGravX * gravDotPitchAxis;
      pitchAxisY = -normGravY * gravDotPitchAxis;
      pitchAxisZ = -normGravZ * gravDotPitchAxis;
      // normalize
      pitchAxisLengthSquared = sq(pitchAxisX) + sq(pitchAxisY) + sq(pitchAxisZ);
      if (pitchAxisLengthSquared > 0.0) {
        pitchAxisX *= 1.0 / sqrt(pitchAxisLengthSquared);//lengthReciprocal
        pitchAxisY *= 1.0 / sqrt(pitchAxisLengthSquared);//lengthReciprocal
        pitchAxisZ *= 1.0 / sqrt(pitchAxisLengthSquared);//lengthReciprocal

        // get global pitch factor (dot)
        camera[1] = +(pitchAxisX * calibratedGyro1
        + pitchAxisY * calibratedGyro0
        + pitchAxisZ * calibratedGyro2);/*sign flip appeases mystery GPC wrath*/
        // by the way, pinch it towards the nonsense limit
        camera[1] *= sideReduction;

        if (gyro_space == WORLD_LEAN) {
          // world roll axis is cross (yaw, pitch)
          rollAxisX = pitchAxisY * normGravZ - pitchAxisZ * normGravY;
          rollAxisY = pitchAxisZ * normGravX - pitchAxisX * normGravZ;
          rollAxisZ = pitchAxisX * normGravY - pitchAxisY * normGravX;

          // normalize
          rollAxisLengthSquared = sq(rollAxisX) + sq(rollAxisY) + sq(rollAxisZ);
          if (rollAxisLengthSquared > 0.0) {
            rollAxisX *= 1.0 / sqrt(rollAxisLengthSquared);//lengthReciprocal
            rollAxisY *= 1.0 / sqrt(rollAxisLengthSquared);//lengthReciprocal
            rollAxisZ *= 1.0 / sqrt(rollAxisLengthSquared);//lengthReciprocal

            // get global roll factor (dot)
            camera[0] = rollAxisX * calibratedGyro1
            + rollAxisY * calibratedGyro0
            + rollAxisZ * calibratedGyro2;
            // by the way, pinch because we rely on a good pitch vector here
            camera[0] *= sideReduction;
          }
        }
      }

      if (gyro_space == WORLD_TURN) {
        camera[0] = -(worldYaw);/*sign flip appeases mystery GPC wrath*/
      }
    }
  }
  camera[0] *= gyroSensitivity;/*Apply sens regardless of space*/
  camera[1] *= gyroSensitivity;
  if (gyroBlocked) camera[0] = camera[1] = 0.0;
}

//accel
void processGyroAccel(fix32 calibratedGyro0, fix32 calibratedGyro1, fix32 calibratedGyro2,
fix32 accelGrav0, fix32 accelGrav1, fix32 accelGrav2,
fix32 minGyroSens, fix32 maxGyroSens, fix32 minGyroThreshold, fix32 maxGyroThreshold) {
  // apply calibration factor
  // get input velocity
  fix32 magnitude = pythag(calibratedGyro0, calibratedGyro1);
  // calculate position on min_gyro_threshold to max_gyro_threshold scale
  magnitude -= minGyroThreshold;
  if (magnitude < 0.0) {
    magnitude = 0.0;
  }
  fix32 denom = maxGyroThreshold - minGyroThreshold;
  fix32 newSensitivity;
  if (denom <= 0.0) {
    newSensitivity = magnitude > 0.0 ? 1.0 : 0.0; // if min threshold overlaps max threshold, pop up to
    // max lowSens as soon as we're above min threshold
  } else {
    newSensitivity = magnitude / denom;
  }
  if (newSensitivity > 1.0) {
    newSensitivity = 1.0;
  }
  // interpolate between low sensitivity and high sensitivity
  newSensitivity = lerp(minGyroSens, maxGyroSens, newSensitivity);
  //newSensitivityX = lerp(minGyroSensX, maxGyroSensX, newSensitivity);
  //newSensitivityY = lerp(minGyroSensY, maxGyroSensY, newSensitivity);
  processGyroInput(calibratedGyro0, calibratedGyro1, calibratedGyro2,
  accelGrav0, accelGrav1, accelGrav2, newSensitivity);
}

fix32 getCalibrationOffset(int32 n) {
  if (offsetSamples == 0) {
    return 0.0;
  }
  if (n==0) {
    return accumulatedOffset[0] / (fix32)offsetSamples;
  } else if (n==1) {
    return accumulatedOffset[1] / (fix32)offsetSamples;
  }
  return accumulatedOffset[2] / (fix32)offsetSamples;
}

void resetCalibration() {
  offsetSamples = 0;
  accumulatedOffset = 0.0;
}

combo recalibrate {
  resetCalibration();
  wait(0);
  wait(3000); //wait 3s for the user to take hands off controller
  calibrating = TRUE;
}

// smoothing buffer - adapted from blog
void getSmoothedInput(fix32 *avg) {
  static uint8 CurrentInputIndex = -1;
  CurrentInputIndex = (CurrentInputIndex + 1) % SMOOTH_BUFFER_SIZE;

  static fix32 InputBuffer0[SMOOTH_BUFFER_SIZE];
  static fix32 InputBuffer1[SMOOTH_BUFFER_SIZE];

  InputBuffer0[CurrentInputIndex] = avg[0];
  InputBuffer1[CurrentInputIndex] = avg[1];

  uint8 i;
  for (i = 0; i < SMOOTH_BUFFER_SIZE; i++) {
    avg[0] += InputBuffer0[i];
    avg[1] += InputBuffer1[i];
  }
  avg[0] /= (fix32)SMOOTH_BUFFER_SIZE;
  avg[1] /= (fix32)SMOOTH_BUFFER_SIZE;
}

void getTieredSmoothedInput(fix32 *input0, fix32 *input1, fix32 threshold1, fix32 threshold2) {
  fix32 inputMagnitude = pythag(*input0, *input1);
  fix32 directWeight = (inputMagnitude - threshold1) / (threshold2 - threshold1);
  directWeight = clamp(directWeight, 0.0, 1.0);
  fix32 avg[2];
  avg[0] = *input0 * (1.0 - directWeight);
  avg[1] = *input1 * (1.0 - directWeight);
  getSmoothedInput(&avg);
  *input0 = (*input0 * directWeight) + avg[0];
  *input1 = (*input1 * directWeight) + avg[1];
}

void getTightenedInput(fix32 *input0, fix32 *input1, fix32 threshold) {
  fix32 inputMagnitude = pythag(*input0, *input1);
  if (inputMagnitude < threshold) {
    fix32 inputScale = inputMagnitude / threshold;
    *input0 *= inputScale;
    *input1 *= inputScale;
  }
}

void cutoffRecovery(fix32 *gyroX, fix32 *gyroY, fix32 speed, fix32 recovery) {
  // now, honour gyro_cutoff_speed
  fix32 gyroLength = pythag(*gyroX, *gyroY); //TODO replace with pointer, this is probably repeated in other funcs
  //auto speed = jc->getSetting(SettingID::GYRO_CUTOFF_SPEED);
  //auto recovery = jc->getSetting(SettingID::GYRO_CUTOFF_RECOVERY);
  if (recovery > speed) {
    // we can use gyro_cutoff_speed
    fix32 gyroIgnoreFactor = (*gyroLength - speed) / (recovery - speed);
    if (gyroIgnoreFactor < 1.0) {
      if (gyroIgnoreFactor <= 0.0) {
        *gyroX = *gyroY;//= gyroLength = 0.0;
      } else {
        *gyroX *= gyroIgnoreFactor;
        *gyroY *= gyroIgnoreFactor;
        gyroLength *= gyroIgnoreFactor;
      }
    }
  }
}

fix32 ipythag(uint32 a, uint32 b) {//ipythag thanks to ME. (and wikipedia)
  a = (a*a) + (b*b);
  int32 c, d = 0x40000000;
  while (d > a) d >>= 2;
  while (d) {
    if (a >= c + d) {
      a -= c + d;
      c >>= 1;
      c += d;
    } else {
      c >>= 1;
    }
    d >>= 2;
  }

  return (fix32)c;
}

fix32 pythag(fix32 a, fix32 b) {
  if (abs((int)a) <= 128 && abs((int)b) <= 128) return sqrt(sq(a) + sq(b));
  if (abs((int)a) <= 23170 && abs((int)b) <= 23170) return ipythag((int)a, (int)b);
  printf("pythag return exceeded fix32");
  return - 1.0;
}

bool processGyroStick(fix32 stickX, fix32 stickY) {
  //GPC has all axis represented in -100 to 100
  //This is not the case with JSM
  fix32 stickLength = pythag(stickX, stickY);
  fix32 stickVelocity;
  fix32 livezoneSize = 1.0 - undeadzone_outer - undeadzone_inner;
  //in order to correctly combine gyro and stick, we need to calculate what the stick
  //aiming is supposed to be doing, add gyro result to it, and convert back to stick
  if (unpower == 0.0) {
    unpower = 1.0;
  }

  //Currently, stickIsUndead alters velocity associated with a given stick tilt.
  //JSM equates undeadzone with stick deadzone, retaining expected tilt velocity.
  //TODO maybe: Compromise between the two approaches.
  //game inner deadzone = .25, range begins at .25 (hence jsm deadzone)
  //undeadzone could employ a discontinuity to match up for _most_ of the range.
  //Add in a range from deadzone to undeadzone + fudgezone,
  //such that the stick tilt : game velocity is identical to native game behavior
  //but only after the fudgezone
  if (stickIsUndead) {
    fix32 realzoneSize = 1.0 - deadzone_outer - deadzone_inner;
    stickVelocity = pow(
    clamp((stickLength - deadzone_inner) / realzoneSize, 0.0, 1.0), unpower
    ) * (fix32)maxStickGameSpeed * virtual_scale;
  } else {
    stickVelocity = pow(
    clamp((stickLength - undeadzone_inner) / livezoneSize, 0.0, 1.0), unpower
    ) * (fix32)maxStickGameSpeed * virtual_scale;
  }

  fix32 expectedX = 0.0;
  fix32 expectedY = 0.0;
  gyroStickX = 0.0;
  gyroStickY = 0.0;

  if (stickVelocity > 0.0) {
    expectedX = (stickX / stickLength) * stickVelocity;
    expectedY = (stickY / stickLength) * stickVelocity;
  }

  //The original JSM function translates in-game turn velocity into units equivalent
  //to real world turn velocity, because a gyroscope reports real velocity.
  //TitanTwo reports everything including gyro on a scale of -100 to 100, so we need to work around this.
  expectedX += camera[0] * 3.6; //the gyro readings top out at roughly 100.
  expectedY += camera[1] * 3.6; //100 * 3.6 = 360.

  fix32 targetGyroVelocity = pythag(expectedX, expectedY);

  // map gyro velocity to achievable range in 0-1
  fix32 gyroInStickStrength = targetGyroVelocity >= (fix32)maxStickGameSpeed
  ? 1.0 : targetGyroVelocity / (fix32)maxStickGameSpeed;
  // UNPOWER curve
  if (unpower != 0.0) {
    gyroInStickStrength = pow(gyroInStickStrength, 1.0 / unpower);
  }

  // remap to between inner and outer deadzones
  if (gyroInStickStrength > 0.003) {//JSM hardcodes 0.010, too high in uJSM
                                    //TODO: what makes JSM behave different?
                                    //Probably lack of raw gyro data
    gyroInStickStrength = undeadzone_inner + gyroInStickStrength * livezoneSize;
    gyroStickX = (expectedX / targetGyroVelocity) * gyroInStickStrength;
    gyroStickY = (expectedY / targetGyroVelocity) * gyroInStickStrength;
  }

  //does this make sense in the new context of using regular deadzone?
  return stickLength > undeadzone_inner;
}

void processStick(fix32 *stick) {
  //This function only runs when gyro is not mapped to a stick
  fix32 livezoneSize = 1.0 - undeadzone_outer - undeadzone_inner;
  fix32 realzoneSize = 1.0 - deadzone_outer - deadzone_inner;

  //honor deadzones
  fix32 stickLengthScaled = clamp(
    (STICK_LENGTH - deadzone_inner) / realzoneSize,
  0.0, 1.0)
  * virtual_scale;

  stickLengthScaled = stickLengthScaled >= 1.0 ? 1.0 : stickLengthScaled;

  fix32 componentX, componentY = 0.0;
  //stick, now rescaled with deadzone and virtual_scale
  if (stickLengthScaled > 0.0) {
    componentX = (STICK_X / STICK_LENGTH) * stickLengthScaled;
    componentY = (STICK_Y / STICK_LENGTH) * stickLengthScaled;
  }

  //honor undeadzone
  if (stickIsUndead) {
    //TODO
    //something something divide by livezoneSize
  }

  set_val(STICK_1_X, componentX * 100.0);
  set_val(STICK_1_Y, componentY * 100.0);
}

fix32 IN_FlickStick(fix32 *stick) {//flickstick from yquake2 (thanks Protocultor)
  #define FLICK_TIME 1
  static uint8 flick_progress = FLICK_TIME;
  static bool is_flicking;
  static fix32 last_stick_angle;
  fix32 target_angle;
  fix32 angle_change;

  if (STICK_LENGTH > FLICKSTICK_THRESHOLD) {// flick!
    fix32 stick_angle = atan2(STICK_X, -STICK_Y);

    if (!is_flicking) {
      // Flicking begins now, with a new target
      is_flicking = TRUE;
      flick_progress = 0;
      target_angle = stick_angle;
    } else {
      // Was already flicking, just turning now
      angle_change = stick_angle - last_stick_angle;

      // angle wrap: https://stackoverflow.com/a/11498248/1130520
      angle_change = mod(angle_change + PI, 2.0 * PI);
      angle_change = angle_change < 0.0 ? angle_change + PI : angle_change - PI;
    }
    last_stick_angle = stick_angle;
  } else is_flicking = FALSE;

  // Flick Stick: flick in progress, changing the yaw angle to the target progressively
  if (flick_progress < FLICK_TIME) {
    flick_progress++;
    return rad2deg(target_angle);// * rotation_factor[flick_progress];
  }
  return rad2deg(angle_change);
}

uint32 profiler(char *func, uint32 startTime) {
  uint32 elapsed = system_time() - startTime;
  if (elapsed > 1) {
    printf(func);
    printf("took %dms to complete", elapsed);
  }
  return elapsed;
}

/* Interactive Config
I make use of empty [sections] to be heading titles in the GUI.
Then I group [detailed-config-name] elements under those empty sections.
This allows me to have nice GUI titles, while also allowing for accurate
and readable config names in IC-ByteTable.

<shortdesc>
Use your controller's gyro to aim! Supports outputting as mouse or joystick. See interactive config for help.
</shortdesc>

<keywords>
gyro mouse flickstick jsm joyshockmapper dualsense steamcontroller dualshock ds4 joycon motion
</keywords>

<cfgdesc>
[Presets]
shortdesc =
control = config
item        = Steam Controller:#03:00FA#07:02#32:00000000
item        = Deadzone Finder:#07:00#12:000000000000000000004000
item        = VIRTUAL_STICK_CALIBRATION Finder:#07:00#12:000000000000000000010000
item        = Acceleration Example:#0A:00050000025800000000800000020000
item        = Threshold Testing Example (Motion only above 500 degrees per second):#0A:01F4000001F402900000000000010000
item        = User Preset 1 (edit and add more presets in source code, line 1156):
[Layout]
[GYRO_OUTPUT]
shortdesc = <code>GYRO_OUTPUT</code>
byteoffset = 0
bitsize = 8
bitoffset = 0
control = radiobox
default = 0
item = MOUSE (requires output protocol: HID)
item = RIGHT_STICK
item = LEFT_STICK (incomplete)
group = true
[Layout Flickstick checkbox]
shortdesc = 
byteoffset = 7
bitsize = 1
bitoffset = 3
control = checkbox
default = 0
item = Flickstick (mouse-only until future update)
groupcol = true
[Layout stickDisable checkbox]
shortdesc = 
byteoffset = 7
bitsize = 1
bitoffset = 2
control = checkbox
default = 0
item = Disable right joystick in mouse mode
group = true

[Sensitivity]
[MIN_GYRO_SENS]
shortdesc = <code>MIN_GYRO_SENS</code>
byteoffset = 18
bitsize = 32
bitoffset = 0
control = spinboxf
decimals = 2
default = 00100
minimum = 00000
maximum = 10000
step = 001
group = true
[MAX_GYRO_SENS]
shortdesc = <code>MAX_GYRO_SENS</code>
byteoffset = 22
bitsize = 32
bitoffset = 0
control = spinboxf
decimals = 2
default = 00100
minimum = 00000
maximum = 10000
step = 001
group = true
[MIN_GYRO_THRESHOLD]
shortdesc = <code>MIN_GYRO_THRESHOLD</code>
byteoffset = 10
bitsize = 32
bitoffset = 0
control = spinboxf
decimals = 2
default = 000000
minimum = 000000
maximum = 100000
step = 001
group = true
[MAX_GYRO_THRESHOLD]
shortdesc = <code>MAX_GYRO_THRESHOLD</code>
byteoffset = 14
bitsize = 32
bitoffset = 0
control = spinboxf
decimals = 2
default = 000000
minimum = 000000
maximum = 100000
step = 0010
group = true
[mini info Sensitivity]
shortdesc =<<<MULTILINE
<p style="text-align:center;color:grey;"><img src="data:image/png;base64,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" ><br>SENS min=max (or max=0) disables acceleration.</p>
MULTILINE
control = info
groupcol = true

[Controller Config]
[Gyro Stick]
shortdesc = <p style="text-align:center;"><h4>Gyro Stick</h4></p>
control = info
group = true

[UNDEADZONE_INNER]
shortdesc = <code>UNDEADZONE_INNER</code>
byteoffset = 26
bitsize = 32
bitoffset = 0
control = spinboxf
default = 000
decimals = 2
step = 005
minimum = 000
maximum = 100
group = true
[SPACE UNDEADZONE_OUTER]
control = space
default = 5
group = true
[UNDEADZONE_OUTER]
shortdesc = <code>UNDEADZONE_OUTER</code>
byteoffset = 30
bitsize = 32
bitoffset = 0
control = spinboxf
default = 000
decimals = 2
step = 005
minimum = 000
maximum = 100
group = true
[SPACE UNPOWER]
control = space
default = 5
group = true
[UNPOWER]
shortdesc = <code>UNPOWER</code>
byteoffset = 38
bitsize = 32
bitoffset = 0
control = spinboxf
decimals = 2
default = 000
minimum = 000
maximum = 200
step = 010
group = true
[SPACE VIRTUAL_STICK_CALIBRATION]
control = space
default = 5
group = true
[VIRTUAL_STICK_CALIBRATION]
shortdesc = <code>VIRTUAL_STICK_CALIBRATION</code>
byteoffset = 5
bitsize = 16
bitoffset = 0
control = spinbox
default = 160
minimum = 0001
maximum = 1000
step = 000010
group = true
[Joystick]
shortdesc = <p style="text-align:center;"><h4>Joystick</h4></p>
control = info
groupcol = true
[SPACE VIRTUAL_SCALE]
control = space
default = 2
group = true
[VIRTUAL_SCALE]
shortdesc = <code>VIRTUAL_SCALE</code>
byteoffset = 34
bitsize = 32
bitoffset = 0
control = spinboxf
decimals = 2
default = 0100
minimum = 0001
maximum = 1000
step = 001
group = true
[SPACE UNDEADZONE_OUTER override]
control = space
default = 13
group = true
[UNDEADZONE_OUTER override]
shortdesc =
byteoffset = 7
bitsize = 1
bitoffset = 0
control = checkbox
default = 0
item = Joystick overrides UNDEADZONE_OUTER
group = true
[stickIsUndead]
shortdesc =
byteoffset = 7
bitsize = 1
bitoffset = 4
control = checkbox
default = 0
item = stickIsUndead (enables deadzones)
group = true
[DEADZONE_INNER]
shortdesc = <code>DEADZONE_INNER</code>
byteoffset = 50
bitsize = 32
control = spinboxf
default = 015
decimals = 2
minimum = 000
maximum = 100
group = true
[SPACE DEADZONE_OUTER]
control = space
default = 5
group = true
[DEADZONE_OUTER]
shortdesc = <code>DEADZONE_OUTER</code>
byteoffset = 62
bitsize = 32
control = spinboxf
default = 010
decimals = 2
minimum = 000
maximum = 100
group = true

[Misc]
[Calibration samples]
shortdesc = Calibration samples
byteoffset = 3
bitsize = 16
bitoffset = 0
control = dial
default = 01000
minimum = 00100
maximum = 05000
step = 50
group = true
[gyro_tight_threshold]
shortdesc = Tightening threshold
byteoffset = 42
bitsize = 32
bitoffset = 0
control = spinboxf
decimals = 2
default = 0
minimum = 000000
maximum = 100000
step = 100
groupcol = true
[GYRO_SMOOTH_THRESHOLD]
shortdesc = <code>GYRO_SMOOTH_THRESHOLD</code>
byteoffset = 46
bitsize = 32
bitoffset = 0
control = spinboxf
decimals = 2
default = 0
minimum = 000000
maximum = 100000
step = 100
group = true
[SPACE Calibrate gyro on startup]
control = space
default = 25
group = true
[Calibrate gyro on startup]
shortdesc = 
byteoffset = 7
bitsize = 1
bitoffset = 1
control = checkbox
default = 1
item = Calibrate gyro on startup
group = true
[IN_GAME_SENS]
shortdesc = <code>IN_GAME_SENS</code>
byteoffset = 54
bitsize = 32
control = spinboxf
decimals = 2
default = 000100
minimum = 000000
maximum = 100000
step = 000010
groupcol = true
[REAL_WORLD_CALIBRATION]
shortdesc = <code>REAL_WORLD_CALIBRATION</code>
byteoffset = 58
bitsize = 32
control = spinboxf
decimals = 2
default = 004000
minimum = 000000
maximum = 100000
step = 000010
group = true
[GYRO_SPACE]
shortdesc = <code>GYRO_SPACE</code>
bitsize = 8
byteoffset = 1
control = combobox
default = 0
item = LOCAL
item = PLAYER_TURN
item = PLAYER_LEAN
item = WORLD_TURN
item = WORLD_LEAN
group = true

[Output Protocol]
shortdesc = Remember this output next time you run the script
bitsize = 8
byteoffset = 2
control = combobox
default = 0
item = TitanTwo configured global default
item = PROTOCOL_AUTO
item = PROTOCOL_PS4
item = PROTOCOL_XB360
item = PROTOCOL_HID (HID required for mouse)
item = Bluetooth PROTOCOL_HID (HID required for mouse)
item = Bluetooth PROTOCOL_PS3
item = Bluetooth PROTOCOL_PS4
item = Bluetooth PROTOCOL_XB360
item = Bluetooth PROTOCOL_XB1
item = Bluetooth PROTOCOL_SWITCH
item = Bluetooth PROTOCOL_WII

[Info: uJSM?]
shortdesc = <<<MULTILINE
A significant chunk of this script was adapted from the PC software <a href=https://github.com/Electronicks/JoyShockMapper>JoyShockMapper</a>. Given that I've only implemented a subset of JSM features, and since the target platform is an embedded device (TitanTwo), I felt uJSM (micro JSM) was an appropriate name.
If you have any interest in using gyro aim on PC, go check out JoyShockMapper! I've intentionally kept all the settings in uJSM the same as they appear in JSM, so basic configuration should feel familiar :)

Anything capitalized works exactly the same in the PC JoyShockMapper. If it's not capitalized, then it's either not in JoyShockMapper, or it's configured in a different way.
MULTILINE
control = info

[Info: Mouse vs Joystick?]
shortdesc = <<<MULTILINE
Gyro is functionally equivalent to mouse, and is best experienced when mapped to a mouse.
Of course, you won't be able to use mouse mode on most console games, but mouse mode does work pretty well when paired with a XIM.

RIGHT_STICK (and LEFT_STICK) is emulating a joystick, but how this feels will vary from game to game. In fact, since gyro is basically a mouse, it will feel a lot like you're trying to map a mouse to the joystick! This code is not as comprehensive as XIM smart translators, though.

NOTE: the HID output protocol still outputs the whole controller as a joystick, and the XIM does see it! Controller remaps will still take effect. Disable the right joystick to prevent double output where it may occur.
Alternatively, you can use Gtuner to configure device options and check "Disable Joystick from Multi Interface HID output".
MULTILINE
control = info

[Info: Flickstick]
shortdesc = <<<MULTILINE
The new aim method that I believe will one day replace traditional stick aim!
From the gyro wiki: <code>"Flick stick maps the angle of one of the thumbsticks (in the following examples, the right stick) to the same angle turn in-game."</code> In other words, it gives you twinstick shooter controls in first person shooter games. It's best to see it in action: watch this introductory video to get the idea <a href="https://www.youtube.com/watch?v=GzbZq4OjEwE">https://www.youtube.com/watch?v=GzbZq4OjEwE</a>

Please also read this to configure: <a href="https://github.com/Electronicks/JoyShockMapper#5-real-world-calibration">https://github.com/Electronicks/JoyShockMapper#5-real-world-calibration</a>
MULTILINE
control = info

[Info: On the fly config]
shortdesc = <<<MULTILINE
Hold the controller in your right hand oriented left side up, with the thumbsticks facing right.
Hold R1 with pinky, then press L1 with index finger.
To prevent accidental activation, the controller must be held near perfectly sideways; keep R1 held and keep tapping L1 until the controller vibrates.
Once the controller vibrates, you're in. Repeat this to save and exit.

See Gtuner console for information.
Southmost face button cycles between config options.
DPad left right decrements and increments.
DPad down up decrements and increments with larger steps.
Eastmost face button resets unsaved changes to the current config option.
MULTILINE
control = info

[Info: VIRTUAL_SCALE]
shortdesc =<<<MULTILINE
This is simply the sensitivity of the virtual joystick. As with mouse to joystick, it's desirable for gyro to joystick to set the game sensitivity to maximum- use this to lower the sensitivity of your real joystick to usable levels.
MULTILINE
control = info

[Info: UNPOWER]
shortdesc = <<<MULTILINE
<code>UNPOWER</code>, as described by the JSM README: <code>A power curve is often applied to stick input to give players more with small movements at the cost of less precision with very large movements. If you know what the exponent is, putting it here will counter that power curve to hopefully give you linearly proportional camera control. The default value of 0 does nothing, which is effectively the same as setting it to 1, since that assumes a linear curve.</code>
MULTILINE
control = info

[Info: VIRTUAL_STICK_CALIBRATION]
shortdesc = <<<MULTILINE
<code>VIRTUAL_STICK_CALIBRATION</code> is a concept from JSM; it's supposed to represent how fast (in degrees/s) the game allows you to look around using the stick. If you set it correctly in JSM, (game stick logic permitting) the motion of the controller will be translated 1:1 to the game. Additionally, this allows you to translate your preferred sensitivity between different games.

However! Most games have a low max speed which will clip fast movements (you know this if you've used mouse input on your Titan or XIM), the TitanTwo does not report gyro data to the script in degrees/s, and the specific number (unique per game) is pretty difficult to determine with precision. 

What this setting does in abstract is scale your motion to the range of the virtual joystick. Lower values will reach 100% output quicker- allowing you to easily hit the fastest turn speed with minimal motion, but move too fast and the game camera won't keep up. Higher values allow more room for quicker and more aggressive motion (like quick panic flicks), but you start to lose precision for slower movements.

Remember to set the in game stick sensitivity to its maximum!

I've implemented a helper to guestimate the game's value with controller or Titan LED. Select the preset <code>VIRTUAL_STICK_CALIBRATION Finder</code>. This will cause you to spin around in game at the maximum speed. Look down at the ground in game and find an object that will help you track your rotations.
Press the southmost face button every time you do one full rotation. The LED will start to blink at the same rate as your rotation. If the LED blink is synchronized with a few turns, that's probably close enough.

You can also dial this in with the DPAD and the northmost face button. Left/Right to adjust the timing by 1ms, Up/Down for 10ms, and North will reset the start of the blink interval.

Press START to save the value to Titan pmem. The value is also reported in the Gtuner console.
MULTILINE
control = info

[Info: Un-Deadzone]
shortdesc = <<<MULTILINE
Each game has its own joystick inner deadzone set by the developers.
If uJSM knows where the deadzone is, it can use that as the starting point for gyro outpoint, entirely eliminating the game's inner deadzone.

<code>UNDEADZONE_OUTER</code> can be used to avoid non-linear jumps in sensitivity programmed into the game, which feel unnatural with gyro aim.

By default, this only applies to the gyro, while the joystick passes through to the game unaltered. Change that with the option <code>stickIsUndead</code>, and you can configure your own stick deadzone even when the game doesn't have an option for it.

Note that <code>UNDEADZONE_INNER</code>, <code>DEADZONE_INNER</code>, <code>UNDEADZONE_OUTER</code>, and <code>DEADZONE_OUTER</code> options are asking for the size of the deadzone, not where the deadzone starts. If there's a jump in acceleration at 92% stick tilt, you want an 8% outer undeadzone.

<code>Deadzone Finder</code> preset helps precisely find inner deadzone. When active, Titan will tilt the right joystick at the configured inner deadzone. Find the highest value of <code>UNDEADZONE_INNER</code> where the camera DOESN'T move. Start at 25% and work your way up or down from there.

<br><code>Joystick overrides UNDEADZONE_OUTER</code>: Some games have a sharp jump in acceleration when the joystick is tilted near 100%.
This is undesirable for gyro aim, but might be desirable while using the stick because it helps you turn around faster in game.
MULTILINE
control = info

[Info: Misc]
shortdesc = <<<MULTILINE
<code>Calibrate gyro on startup</code>: Place the controller on a flat surface and do not touch it until the LEDs stop flashing: they'll turns green when finished.
The script is averaging sensor data to filter out unwanted sensor noise: this helps fight drift.
NOTE! Steam controller will enter an idle mode after about 6 seconds. You may have to touch one of the pads to get calibration to continue. Do so very gently, so as to not accidentally add any movement during calibration.

<code>Calibration samples</code>: How many samples to collect during calibration. The controller's true polling rate will limit how fast samples are collected.

Tightening squishes output towards zero below the threshold, used to help prevent jitter when trying to hold still at higher sensitivities.

Smoothing helps reduce jitter below the threshold, useful for unsteady hands, or to smooth out noise with higher sensitivities. You can adjust the size of <code>SMOOTH_BUFFER_SIZE</code> from the source code. Note that smoothing necessarily adds latency, the bigger the buffer the greater the latency, and the TitanTwo does not have the resources for very high buffer values.
MULTILINE
control = info

[Info: Speed Thresholds?]
shortdesc = <<<MULTILINE
Configure thresholds in values of degrees per second: how fast you are turning the controller. Unfortunately the TitanTwo doesn't present raw gyro data in this way, so the threshold number here is imperfect. I've tried to play with the numbers to make it close to reality, but you may find the settings are not exactly the same as what you'd use in JSM for PC.
Try values near 10 when trying to set a threshold that activates when moving as slow as possible. The highest sensible values is somewhere under 1000.

You can test where a threshold is by enabling acceleration with MIN_GYRO_SENS 0, MAX_GYRO_SENS 1. Then set MIN_GYRO_THRESHOLD to the desired test number, MAX_GYRO_THRESHOLD to one above that, and see how fast you must move the controller to get a response.
MULTILINE
control = info

[Info: How do I use this with XIM?]
shortdesc = <<<MULTILINE
Plug the titan's OUTPUT into the xim's input. The XIM plugs into your PC or console.

There are some oddities I have yet to address.

Create a new config in XIM for uJSM.

The Titan <code>HID joystick</code> output is interpretted by the XIM strangely.
You'll have to map every button on the controller to the button it should be.
Then,
  Right Stick X = Joystick Left Z
  Right Stick Y = Joystick Right Z

Last, the right stick Y axis is inverted. For whatever reason, XIM's own inverted aim option won't work here.
You'll have to just invert the Y axis in the game settings. Most games have this.
MULTILINE
control = info

[Credits]
shortdesc = <<<MULTILINE
Most of the concepts used and a lot of the code came from Jibb Smart's gyro wiki:
<a href=http://gyrowiki.jibbsmart.com>http://gyrowiki.jibbsmart.com</a>
As well as the JoyShockMapper project by Jibb Smart and Electronicks:
<a href=https://github.com/Electronicks/JoyShockMapper>https://github.com/Electronicks/JoyShockMapper</a>

Also thanks to anyone who helped me along the way, special thanks to consoletuner mod <code>ME.</code> and the developer of RawAccel.
Thank you!
MULTILINE
control = info
</cfgdesc>
*/
