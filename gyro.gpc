#pragma METAINFO("Gyro", 1, 0, "Aelius")

/*
mouse_set uses int32, not precise enough. In order to be useful, we must
make magic math happen to really smooth out slow movement

TODO
fix smoothing
finish interactive config
flickstick
fix mouse by applying data to new scale starting at 1, use rawaccel to fix speed
make printfs a function or something maybe
*/

/* IC
<cfgdesc>
[Deadzone Finder]
shortdesc	 = Titan will tilt the right joystick at the configured inner deadzone. Find the highest value of inner deadzone where the camera DOESN'T move.
byteoffset = 0
bitsize	   = 1
bitoffset  = 7
control    = checkbox
default    = 0
item       = Enabled
[Deadzones]
shortdesc = Inner deadzone (0-100)
byteoffset = 1
bitsize = 8
control = spinbox
default = 0
step = 1
minimum = 0
maximum = 100
[Deadzones2]
shortdesc = Outer deadzone (0-100)
byteoffset = 2
bitsize = 8
control = spinbox
default = 0
step = 1
minimum = 0
maximum = 100
groupcol = true

[Gyro Assignment]
shortdesc = 
byteoffset = 3
bitsize = 8
control = radiobox
default = 1
item = Gyro controls mouse
item = Gyro controls right joystick
item = Gyro controls left joytick

[Misc]
shortdesc =
byteoffset = 4
bitsize = 8
control = checkbox
default = 0
item = Acceleration
[Misc2]
shortdesc =
byteoffset = 5
bitsize = 8
control = checkbox
default = 1
item = Calibrate gyro on startup
groupcol = true
[Misc3]
shortdesc = RWC/IN_GAME_SENS
byteoffset = 6
bitsize = 8
control = spinboxf
decimals = 2
default = 1000
minimum = 0000
maximum = 9999
step = 100
groupcol = true
[Misc4]
shortdesc = unpower
byteoffset = 7
bitsize = 8
control = spinboxf
decimals = 2
default = 0000
minimum = 0000
maximum = 9999
step = 100
groupcol = true
</cfgdesc>

*/

#include <mouse.gph>

uint32 offsetSamples;
uint32 deltaTime;
uint32 timer = 0;
fix32 gyroVelocity[2]; //0 is Yaw (Z), 1 is Pitch (X)
fix32 calibratedGyro[2];
fix32 gyroCalibration[2];
fix32 accumulatedOffset[2];
fix32 camera[2];

bool enableAccel = FALSE;
bool calibrating = TRUE;
bool deadZoneFinder = FALSE;
bool overwatch_hack = FALSE;
fix32 undeadzoneInner = 0.26;
fix32 undeadzoneOuter = 0.08; //0.08
fix32 maxStickGameSpeed = 33.0;//REAL_WORLD_CALIBRATION/IN_GAME_SENS
fix32 smoothThreshold = 0.0;
fix32 tightThreshold = 0.0;
fix32 slowSensitivity = 1.0;
fix32 fastSensitivity = 1.0;
fix32 slowThreshold = 1.0;
fix32 fastThreshold = 1.0;
fix32 gyroStickX = 0.0;
fix32 gyroStickY = 0.0;
fix32 unpower = 0.0;

fix32 virtualScale = 1.0;
fix32 sensitivity = 1.0;

init {
}

main {
  deltaTime += elapsed_time();
  //GPC bug? titan unresponsive when deltaTime loop is less than 4ms
  if (deltaTime >= 4) {//delay main() loop at ~250Hz
    gyroVelocity[0] = get_actual(GYRO_1_Z);
    gyroVelocity[1] = get_actual(GYRO_1_X);
    processInput(deltaTime);
    //Logic from JSM operates on a scale of 0-1
    if (processGyroStick(get_actual(STICK_1_X)/100.00, get_actual(STICK_1_Y)/100.00)) {
      //Nothing here because set_val can't be in the loop.
      //Just reminding myself that this function returns a bool
      //and the set_val was here in JSM...
    }
    deltaTime = 0;
  }
  
  //set_val must be outside the polling loop!
  //lest values bounce back to 0 every cycle
  if (deadZoneFinder == TRUE) {
    // hack to help with finding deadzones more quickly
    set_val(STICK_1_X, undeadzoneInner * 100.00);
  } else {
    set_val(STICK_1_X, gyroStickX * 100.00);
    set_val(STICK_1_Y, gyroStickY * 100.00);
  }
  
  //hack for overwatch: skip outer deadzone logic for the actual joystick
  //gyro is still subject to deadzone and thus remains linear.
  //stick now has access to overwatch's snappy stick turn logic
  if (overwatch_hack == TRUE) {
    if (get_actual(STICK_1_X) >= 92.0 || get_actual(STICK_1_X) <= -92.0)  {
      set_val(STICK_1_X, get_actual(STICK_1_X));
    }
  }
  
  //GPC bug? mouse_set only accepts int32, which is not precise enough.
  //Typecasting to int32 always rounds down, such that 0.8==0 but -0.8==-1
  //Thus _any_ noise causes drift in the negative direction,
  //but rounding filters out legitimate movement. Unsure how to proceed.
  //TODO: linear rescale to > 1.0
  /*
camera[0] = (camera[0] < 0.0) ? ceil(camera[0]) : camera[0];
camera[1] = (camera[1] < 0.0) ? ceil(camera[1]) : camera[1];
mouse_set(MOUSE_X, (int32)camera[0]);
mouse_set(MOUSE_Y, (int32)camera[1]);
  */
}

void processInput(uint32 deltaTime) {
  //calibrating
  if (calibrating ) {
    offsetSamples++;
    accumulatedOffset[0] += gyroVelocity[0];
    accumulatedOffset[1] += gyroVelocity[1];
    printf("calibrating!", 0);
    timer++;
    if (timer > 500) {
      led_set(LED_1, 50.0, 0);
      led_set(LED_2, 50.0, 0);
      led_set(LED_3, 50.0, 0);
      led_set(LED_4, 0.0, 0);
      calibrating = FALSE;
    }
  }
  
  gyroCalibration[0] = getCalibrationOffset(0);
  gyroCalibration[1] = getCalibrationOffset(1);
  calibratedGyro[0] = gyroVelocity[0] - gyroCalibration[0];
  calibratedGyro[1] = gyroVelocity[1] - gyroCalibration[1];  
  
  //smoothing
  //  if (smoothThreshold > 0.0) {
  //    calibratedGyro = getTieredSmoothedInput(calibratedGyro, smoothThreshold/2.0, smoothThreshold);
  //  }
  
  //tightening
  if (tightThreshold > 0.0) {
    calibratedGyro[0] = getTightenedInput0(calibratedGyro[0], calibratedGyro[1], tightThreshold);
    calibratedGyro[1] = getTightenedInput1(calibratedGyro[0], calibratedGyro[1], tightThreshold);
  }
  
  
  //accelerating
  if (enableAccel) {
    processGyroAccel(calibratedGyro[0], calibratedGyro[1], deltaTime, slowSensitivity,
    fastSensitivity, slowThreshold, fastThreshold);
  } else {
    processGyroInput(calibratedGyro[0], calibratedGyro[1], deltaTime, sensitivity);
  }
}

fix32 getCalibrationOffset(int32 n) {
  if (offsetSamples == 0) {
    return 0.0;
  }
  if (n==0) {
    return accumulatedOffset[0] / (fix32)offsetSamples;
  } else if (n==1) {
    return accumulatedOffset[1] / (fix32)offsetSamples;
  }
  return 0.0; //GPC won't compile if function returns are in conditionals
}

void resetCalibration() {
  offsetSamples = 0;
  accumulatedOffset = 0.0;
}

void processGyroInput(fix32 calibratedGyro0, fix32 calibratedGyro1,
uint32 deltaTime, fix32 gyroSensitivity) {
  camera[0] = calibratedGyro0 * gyroSensitivity * (fix32)deltaTime;
  camera[1] = calibratedGyro1 * gyroSensitivity * (fix32)deltaTime;
}

/*//smooth

//No idea how to translate the array length stuff to GPC

fix32 getDirectInput0(fix32 input0) {
return input0;
}
fix32 getDirectInput1(fix32 input1) {
return input1;
}

// smoothing buffer
fix32 InputBuffer;
int32 CurrentInputIndex;

fix32 getSmoothedInput0(fix32 input0) {
CurrentInputIndex = mod(CurrentInputIndex + 1, InputBuffer.Length);
InputBuffer[CurrentInputIndex] = input0;
fix32 average = 0.0;
foreach (fix32 sample in InputBuffer) {
average += sample;
}
average /= InputBuffer.Length;
return average;
}
fix32 getSmoothedInput1(fix32 input1) {
CurrentInputIndex = mod(CurrentInputIndex + 1, InputBuffer.Length);
InputBuffer[CurrentInputIndex] = input1;
fix32 average = 0.0;
foreach (fix32 sample in InputBuffer) {
average += sample;
}
average /= InputBuffer.Length;
return average;
}

fix32 getTieredSmoothedInput0(fix32 input0, fix32 input1, fix32 threshold1, fix32 threshold2) {
fix32 inputMagnitude = pythag(input0, input1);
fix32 directWeight = (inputMagnitude - threshold1) / (threshold2 - threshold1);
directWeight = clamp(directWeight, 0.0, 1.0);
return getDirectInput0(input0 * directWeight) + getSmoothedInput(input0 * (1.0 - directWeight));
}
fix32 getTieredSmoothedInput1(fix32 input0, fix32 input1, fix32 threshold1, fix32 threshold2) {
fix32 inputMagnitude = pythag(input0, input1);
fix32 directWeight = (inputMagnitude - threshold1) / (threshold2 - threshold1);
directWeight = clamp(directWeight, 0.0, 1.0);
return getDirectInput1(input1 * directWeight) + getSmoothedInput1(input1 * (1.0 - directWeight));
}
*/

//tight
fix32 getTightenedInput0(fix32 input0, fix32 input1, fix32 threshold) {
  fix32 inputMagnitude = pythag(input0, input1);
  if (inputMagnitude < threshold) {
    fix32 inputScale = inputMagnitude / threshold;
    return input0 * inputScale;
  }
  return input0;
}
fix32 getTightenedInput1(fix32 input0, fix32 input1, fix32 threshold) {
  fix32 inputMagnitude = pythag(input0, input1);
  if (inputMagnitude < threshold) {
    fix32 inputScale = inputMagnitude / threshold;
    return input1 * inputScale;
  }
  return input1;
}

//accel
void processGyroAccel(fix32 calibratedGyro0, fix32 calibratedGyro1,
uint32 deltaTime, fix32 sensitivitySlow, fix32 sensitivityFast,
fix32 slowThreshold, fix32 fastThreshold) {
  // how fast is the gyro moving?
  fix32 speed = pythag(calibratedGyro0, calibratedGyro1);
  
  // where do we stand between the slow threshold and the fast threshold?
  fix32 slowFastFactor = (speed - slowThreshold) /
  (fastThreshold - slowThreshold);
  slowFastFactor = clamp(slowFastFactor, 0.0, 1.0); //is this the right scale for gpc?
  // linearly interpolate
  fix32 newSensitivity = lerp(sensitivitySlow, slowFastFactor, sensitivityFast);
  
  // now apply this sensitivity the way we originally did
  camera[0] = calibratedGyro0 * newSensitivity * (fix32)deltaTime;
  camera[1] = calibratedGyro1 * newSensitivity * (fix32)deltaTime;
}

fix32 pythag(fix32 a, fix32 b) {
  return sqrt( sq(a) + sq(b) );
}

bool processGyroStick(fix32 stickX, fix32 stickY) {
  fix32 stickLength = pythag(stickX, stickY);
  fix32 livezoneSize = 1.0 - undeadzoneOuter - undeadzoneInner;
  //in order to correctly combine gyro and stick, we need to calculate what the stick
  //aiming is supposed to be doing, add gyro result to it, and convert back to stick
  if (unpower == 0.0) {
    unpower = 1.0;
  }
  fix32 stickVelocity = pow(clamp((stickLength - undeadzoneInner) / livezoneSize, 0.0, 1.0), unpower) * maxStickGameSpeed * virtualScale;
  fix32 expectedX = 0.0;
  fix32 expectedY = 0.0;
  gyroStickX = 0.0;
  gyroStickY = 0.0;
  
  if (stickVelocity > 0.0) {
    expectedX = stickX / stickLength * stickVelocity;
    expectedY = stickY / stickLength * stickVelocity;
  }
  
  //expectedX += gyroVelocity[0];
  //expectedY += gyroVelocity[1]; //raw data seems to work better
  expectedX += camera[0]; //honestly, I think my calibration code is whack
  expectedY += camera[1];
  
  fix32 targetGyroVelocity = pythag(expectedX, expectedY);
  // map gyro velocity to achievable range in 0-1
  fix32 gyroInStickStrength = targetGyroVelocity >= maxStickGameSpeed ? 1.0 : targetGyroVelocity / maxStickGameSpeed;
  // unpower curve
  //broken for 2+???
  if (unpower != 0.0) {
    gyroInStickStrength = pow(gyroInStickStrength, 1.0 / unpower);
  }
  
  // remap to between inner and outer deadzones
  if (gyroInStickStrength > 0.010) {
    gyroInStickStrength = undeadzoneInner + gyroInStickStrength * livezoneSize;
    gyroStickX = expectedX / targetGyroVelocity * gyroInStickStrength;
    gyroStickY = expectedY / targetGyroVelocity * gyroInStickStrength;
  }
  
  printf("camera0: %f",camera[0]);
  printf("camera1: %f",camera[1]);
  printf("gyroVelocity0: %f",gyroVelocity[0]);
  printf("gyroVelocity1: %f",gyroVelocity[1]);
  printf("stickX: %f",stickX);
  printf("stickY: %f",stickY);
  printf("expectedX: %f",expectedX);
  printf("expectedY: %f",expectedY);
  printf("gyroStickX %f", gyroStickX);
  printf("gyroStickY %f", gyroStickY);
  printf("stickLength: %f",stickLength);
  printf("stickVelocity: %f",stickVelocity);
  printf("targetGyroVelocity: %f",targetGyroVelocity);
  printf("gyroInStickStrength: %f",gyroInStickStrength);
  
  return stickLength > undeadzoneInner;
}
