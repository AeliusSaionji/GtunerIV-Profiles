#pragma METAINFO("Gyro Aim", 1, 0, "Aelius")

/*

END USER CUSTOMIZATION GUIDE - README
* Create a mapping for GYRO_OFF = TRUE to rachet the controller.
-- if (is_active(yourbutton)) {GYRO_OFF();}
* Initiate a recalibration with combo_run(recalibrate).
-- You may need to do this periodically.
-- Place controller on a flat and steady surface before calibrating.
-- The combo will wait two seconds to give you time to get your hands off.
* SMOOTH_BUFFER_SIZE controls how many samples the smoothing function collects.
-- More smoothing means more latency.
-- The TitanTwo starts to complain about memory > 70
* HID output protocol still outputs the controller!
-- And the XIM does see it!

NOTES
- The TitanTwo seems to map gyro data onto a range of 0.00-102.399994 rather than reporting angular velocity.

- Beware math functions which may exceed fix32 range (check calls to pythag)

TODO
add report latency output, note that it's unused
settings for offsetM
steam controller has latency? requires deltatime? only calibrate with the unique data but don't generally processInput there?
gyro off when using winding, but not touching stick (for touch = gyro weirdos)
implement checks for calls that exceed data type (and definitely put the check in pythag)
press start r2 r1 to start recalibrate combo
warn about steam controller sleeping during calibration
remove accel bool, exchange for remembered settings IC thing, false if 0, whatever jsm does
see if can leverage IC thing for user presets
mystery of GYRO_OFF() working for mouse OR stick but not both
fix thresholds artificially to somewhat match JSM?
--update recommendations
xim specific axis fix?
fix left stick output (hold)
add jsm config names for visibility
user configurable smoothing buffer size in IC?
user configurable mouseCalibration
flickstick mouse
flickstick joystick?
winding flickstick seems like a good idea
player space gyro
implement on demand calibrate? or just tell user to reload script
on demand adjust of sens/speed/smooth/etc? and pmem_save
optimize variables and memory usage

*/

#include <mouse.gph>
#include <keyboard.gph>
#define SMOOTH_BUFFER_SIZE 32 //Don't exceed 70
#define MOUSE_ACCUMULATOR 5
#define CALIBRATION_COUNTER 250 //lower for steam controller

//Misc Globals
uint32 offsetSamples;
uint32 counter = 0;
uint32 mouseSamples;
fix32 gyroVelocity[2]; //0 is Yaw (Z), 1 is Pitch (X)
fix32 calibratedGyro[2];
fix32 gyroCalibration[2];
fix32 accumulatedOffset[2];
fix32 accumulatedMouse[2];
fix32 camera[2];
fix32 gyroStickX;
fix32 gyroStickY;
uint32 logDelay;

//Settings
uint8 stickEmulation = 1; //0 for mouse output, 1 for right stick, 2 for left stick
uint8 outProtocol = 0;
bool enableAccel = FALSE;
bool calibrating = TRUE;
bool outerStickOverride = FALSE;
bool stickDisable = FALSE;
bool logging = TRUE;
bool deadZoneFinder = FALSE;
fix32 undeadzoneInner = 0.0;
fix32 undeadzoneOuter = 0.0;
fix32 maxStickGameSpeed = 360.0;
fix32 smoothThreshold = 0.0;
fix32 tightThreshold = 0.0;
fix32 slowSensitivity = 1.0;
fix32 fastSensitivity = 5.0;
fix32 slowThreshold = 1.0;
fix32 fastThreshold = 10.0;
fix32 unpower = 0.0;
fix32 virtualScale = 1.0;
fix32 sensitivity = 1.0;
fix32 offsetM = 0.9;

init {
  pmem_load();
  
  //ints
  stickEmulation = pmem_read(0);
  outProtocol    = pmem_read(50);
  //bools
  deadZoneFinder     = (pmem_read(25))    & 0b1;
  outerStickOverride = (pmem_read(25)>>1) & 0b1;
  enableAccel        = (pmem_read(25)>>2) & 0b1;
  calibrating        = (pmem_read(25)>>3) & 0b1;
  //flickstick       = (pmem_read(25)>>3) & 0b1;
  stickDisable       = (pmem_read(25)>>5) & 0b1;
  //fix32s
  pmem_read(17, &undeadzoneInner);
  pmem_read(21, &undeadzoneOuter);
  undeadzoneInner /= 100.0;//0-1 scale
  undeadzoneOuter /= 100.0;
  pmem_read(1,  &sensitivity);
  pmem_read(5,  &virtualScale);
  pmem_read(13, &unpower);
  pmem_read(9,  &maxStickGameSpeed);
  pmem_read(34, &slowThreshold);
  pmem_read(38, &fastThreshold);
  pmem_read(26, &slowSensitivity);
  pmem_read(30, &fastSensitivity);
  pmem_read(42, &tightThreshold);
  pmem_read(46, &smoothThreshold);
  
  switch (outProtocol) {
    case 1:  port_connect(PORT_USB_C, PROTOCOL_AUTO);   break;
    case 2:  port_connect(PORT_USB_C, PROTOCOL_PS4);    break;
    case 3:  port_connect(PORT_USB_C, PROTOCOL_XB360);  break;
    case 4:  port_connect(PORT_USB_C, PROTOCOL_HID);    break;
    case 5:  port_connect(PORT_BT_C,  PROTOCOL_HID);    break;
    case 6:  port_connect(PORT_BT_C,  PROTOCOL_PS3);    break;
    case 7:  port_connect(PORT_BT_C,  PROTOCOL_PS4);    break;
    case 8:  port_connect(PORT_BT_C,  PROTOCOL_XB360);  break;
    case 9:  port_connect(PORT_BT_C,  PROTOCOL_XB1);    break;
    case 10: port_connect(PORT_BT_C,  PROTOCOL_SWITCH); break;
    case 11: port_connect(PORT_BT_C,  PROTOCOL_WII);    break;
    default: break;
  }
}
int16 gX;
int16 gY;
int16 gZ;
main {
  if (is_active(BUTTON_15)) {
    GYRO_OFF();
  }
  if (is_active(BUTTON_4)) {
    mouse_set(MBUTTON_1, TRUE);
  } else if (is_release(BUTTON_4)) {
    mouse_set(MBUTTON_1, FALSE);
  }
  if (is_active(BUTTON_5)) {
    key_set(KEY_SPACEBAR, TRUE);
  } else if (is_release(BUTTON_5)) {
    key_set(KEY_SPACEBAR, FALSE);
  }
  
  static uint32 deltaTime;
  deltaTime += elapsed_time();
  //deltaTime detection thanks to consoletuner discord member ME.
  if (deltaTime >= 2) {//delay main() loop at least 500Hz, else GPC/Titan logic breaks
    
    static uint32 reportLatency;
    static fix32 old_gyros;
    fix32 f_gX = get_val(GYRO_1_X);
    fix32 f_gY = get_val(GYRO_1_Y);
    fix32 f_gZ = get_val(GYRO_1_Z);
    fix32 gyros = sqrt(sq(f_gX) + sq(f_gY) + sq(f_gZ));
    // To retrieve true delta time val, insure gyro values have actually updated.
    if (old_gyros != gyros) {
      old_gyros = gyros;
      gX = GetRaw(f_gX);
      gY = GetRaw(f_gY);
      gZ = GetRaw(f_gZ);
      
      /*printf("<big><b><br>\
rawX: %d<br>\
rawY: %d<br>\
rawZ: %d<br>\
      delta: %dms", gX, gY, gZ, reportLatency);*/
      
      processInput(1);
      reportLatency = 0;
    }
    reportLatency++;
    
    if (!logging) {
      logDelay++;//fast output unreadable, because the
      if (logDelay >= 33) {//gtuner gui only updates at 30fps :[
        printf("<big><br>\
        rawX: %d<br>\
        rawY: %d<br>\
        rawZ: %d<br>\
        delta: %dms", gX, gY, gZ, reportLatency);
        logDelay = 0;
      }
    }
    
    //if (deltaTime > 25) { deltaTime = 0; }//If SteamController idles, deltaTime will ++ without bounds
    
    
    gyroVelocity[0] = get_actual(GYRO_1_Z);
    gyroVelocity[1] = get_actual(GYRO_1_X);
    //gyroVelocity[0] = (fix32)gZ/-15.0;//On first blush, divide by 15 seems close to degrees/s, hopefully linear.
    //gyroVelocity[1] = (fix32)gX/-15.0;//Not sure how useful the raw data is over the regular titan input
    //processInput(deltaTime);
    if (stickEmulation == 1) {//Right stick
      //Logic from JSM operates on a scale of 0-1
      if (processGyroStick(get_actual(STICK_1_X)/100.0, get_actual(STICK_1_Y)/100.0)) {} //returns a bool
    }
    if (stickEmulation == 2) {//Left stick
      //Logic from JSM operates on a scale of 0-1
      if (processGyroStick(get_actual(STICK_2_X)/100.0, get_actual(STICK_2_Y)/100.0)) {} //returns a bool
    }
    deltaTime = 0;
  }
  
  //set_val must be outside the polling loop!
  //lest values bounce back to 0 every cycle
  
  if  (stickEmulation) {
    if (deadZoneFinder == TRUE) {
      // hack to help with finding deadzones more quickly
      set_val(STICK_1_X, undeadzoneInner * 100.0);
    } else if (stickEmulation == 1) {
      set_val(STICK_1_X, gyroStickX * 100.0);
      set_val(STICK_1_Y, gyroStickY * 100.0);
    } else if (stickEmulation == 2) {
      set_val(STICK_2_X, gyroStickX * 100.0);
      set_val(STICK_2_Y, gyroStickY * 100.0);
    }
    //Hack for games with accel boost at outer zone:
    //skip outer deadzone logic for the actual joystick
    //Gyro is still subject to deadzone and thus remains linear,
    //but stick now has access to game's accel for snappy stick turning
    if (outerStickOverride == TRUE) {
      if (get_actual(STICK_1_X) >= 95.0) {
        set_val(STICK_1_X, (gyroStickX + undeadzoneOuter) * 100.0);
      } else if (get_actual(STICK_1_X) <= -95.0) {
        set_val(STICK_1_X, (gyroStickX - undeadzoneOuter) * 100.0);
      } else if (get_actual(STICK_1_Y) >= 95.0) {
        set_val(STICK_1_Y, (gyroStickY + undeadzoneOuter) * 100.0);
      } else if (get_actual(STICK_1_Y) <= -95.0) {
        set_val(STICK_1_Y, (gyroStickY - undeadzoneOuter) * 100.0);
      }
    }
  }

  if (stickEmulation == 0) {//mouse
    //fix32 mouseCalibration = (REAL_WORLD_CALIBRATION) / os_mouse_speed / IN_GAME_SENS);
    processMouse(offsetM);
    //Controller is still passed as a joystick in HID output, it may be active
    if (stickDisable) {
      set_val(STICK_1_X, 0.0);//disable right joystick
      set_val(STICK_1_Y, 0.0);
    } else if (virtualScale != 1.0) {//Apply virtualScale aka stickSensitivity
      set_val(STICK_1_X, get_actual(STICK_1_X) * virtualScale);
      set_val(STICK_1_Y, get_actual(STICK_1_Y) * virtualScale);
    }
  }
}

//thanks to consoletuner discord member ME.
int16 GetRaw(fix32 val) {
  return (int16)ceil(lerp(-32768f, 32767f, -((val + 100f) / 200f)));
}

void processMouse(fix32 offsetM) {
  fix32 mouseX, mouseY;
  mouseSamples++;
  accumulatedMouse[0] += camera[0];
  accumulatedMouse[1] += camera[1];
  //Accumulate some samples, helps prevent deadzone for small values
  if (mouseSamples >= MOUSE_ACCUMULATOR) {
    mouseX = accumulatedMouse[0] * sensitivity;
    mouseY = accumulatedMouse[1] * sensitivity;
    mouseSamples = 0;
    accumulatedMouse[0] = 0.0;
    accumulatedMouse[1] = 0.0;
  }
  //Offset is a hack to prevent deadzone by raising the noisefloor
  mouseX = (mouseX > 0.0) ? mouseX + offsetM : mouseX - offsetM;
  mouseY = (mouseY > 0.0) ? mouseY + offsetM : mouseY - offsetM;
  
  //typecasting always rounds down; must round negatives up to prevent drift
  mouseX = (mouseX < 0.0) ? ceil(mouseX) : mouseX;//must be before mouse_set!
  mouseY = (mouseY < 0.0) ? ceil(mouseY) : mouseY;//must be before mouse_set!
  mouse_set(MOUSE_X, (int32)mouseX);//Warning! Typecast behavior rounds down!
  mouse_set(MOUSE_Y, (int32)mouseY);//Warning! Typecast behavior rounds down
}

void GYRO_OFF() {
  calibratedGyro[1] = 0.0;
  camera[0] = 0.0;
  camera[1] = 0.0;
}

void processInput(uint32 deltaTime) {
  //calibrating
  if (calibrating) {
    offsetSamples++;
    accumulatedOffset[0] += gyroVelocity[0];
    accumulatedOffset[1] += gyroVelocity[1];
    printf("calibrating!", 0);
    counter++;
    if (counter > CALIBRATION_COUNTER) {
      led_set(LED_1, 50.0, 0);
      led_set(LED_2, 50.0, 0);
      led_set(LED_3, 50.0, 0);
      led_set(LED_4, 0.0, 0);
      calibrating = FALSE;
    }
  }
  
  gyroCalibration[0] = getCalibrationOffset(0);
  gyroCalibration[1] = getCalibrationOffset(1);
  calibratedGyro[0] = (gyroVelocity[0] - gyroCalibration[0]);
  calibratedGyro[1] = (gyroVelocity[1] - gyroCalibration[1]);
  
  
  
  //smoothing (from wiki)
  if (smoothThreshold > 0.0) {
    calibratedGyro[0] = getTieredSmoothedInput0(calibratedGyro[0], calibratedGyro[1], smoothThreshold/2.0, smoothThreshold);
    calibratedGyro[1] = getTieredSmoothedInput1(calibratedGyro[0], calibratedGyro[1], smoothThreshold/2.0, smoothThreshold);
  }
  
  //cutoff/recovery... and maybe the jsm smoothing
  //calibratedGyro[0] = smoothJSM0(calibratedGyro[0], calibratedGyro[1], 0.0, 0.000001);
  //calibratedGyro[1] = smoothJSM1(calibratedGyro[0], calibratedGyro[1], 0.0, 0.000001);
  
  //tightening
  if (tightThreshold > 0.0) {
    calibratedGyro[0] = getTightenedInput0(calibratedGyro[0], calibratedGyro[1], tightThreshold);
    calibratedGyro[1] = getTightenedInput1(calibratedGyro[0], calibratedGyro[1], tightThreshold);
  }
  
  /* no good
fix32 expandThresholdStart = 0.01;
fix32 expandThresholdEnd = 2.0;
//expanding
if (expandThresholdEnd > 0.0) {
calibratedGyro[0] = getExpandedInput0(calibratedGyro[0], calibratedGyro[1], expandThresholdStart, expandThresholdEnd);
calibratedGyro[1] = getExpandedInput1(calibratedGyro[0], calibratedGyro[1], expandThresholdStart, expandThresholdEnd);
printf("c0 %f", calibratedGyro[0]);
printf("c0 %f", calibratedGyro[1]);
  }*/
  
  //accelerating
  if (enableAccel) {
    processGyroAccel(calibratedGyro[0], calibratedGyro[1], deltaTime, slowSensitivity, fastSensitivity, slowThreshold, fastThreshold);
  } else {
    processGyroInput(calibratedGyro[0], calibratedGyro[1], deltaTime, sensitivity);
  }
}

fix32 getCalibrationOffset(int32 n) {
  if (offsetSamples == 0) {
    return 0.0;
  }
  if (n==0) {
    return accumulatedOffset[0] / (fix32)offsetSamples;
  } else if (n==1) {
    return accumulatedOffset[1] / (fix32)offsetSamples;
  }
  return 0.0; //GPC won't compile if function returns are in conditionals
}

void resetCalibration() {
  offsetSamples = 0;
  accumulatedOffset = 0.0;
}

combo recalibrate {
  resetCalibration();
  wait(0);
  wait(2000); //wait 2s for the user to take hands off controller
  calibrating = TRUE;
}

void processGyroInput(fix32 calibratedGyro0, fix32 calibratedGyro1, uint32 deltaTime, fix32 gyroSensitivity) {
  camera[0] = calibratedGyro0 * gyroSensitivity * (fix32)deltaTime;
  camera[1] = calibratedGyro1 * gyroSensitivity * (fix32)deltaTime;
}

// smoothing buffer - adapted from blog
fix32 getDirectInput(fix32 input) {//What is this function even doing?
  return input;
}

fix32 InputBuffer0[SMOOTH_BUFFER_SIZE];
int32 CurrentInputIndex0;
fix32 InputBuffer1[SMOOTH_BUFFER_SIZE];
int32 CurrentInputIndex1;

fix32 getSmoothedInput0(fix32 input) {
  CurrentInputIndex0 = (int32)mod((fix32)CurrentInputIndex0 + (fix32)1, (fix32)SMOOTH_BUFFER_SIZE);
  InputBuffer0[CurrentInputIndex0] = input;
  fix32 average = 0.0;
  int32 i;
  for (i = 0; i < SMOOTH_BUFFER_SIZE; i++) {
    average += InputBuffer0[i];
  }
  average /= (fix32)SMOOTH_BUFFER_SIZE;
  return average;
}
fix32 getSmoothedInput1(fix32 input) {
  CurrentInputIndex1 = (int32)mod((fix32)CurrentInputIndex1 + (fix32)1, (fix32)SMOOTH_BUFFER_SIZE);
  InputBuffer1[CurrentInputIndex1] = input;
  fix32 average = 0.0;
  int32 i;
  for (i = 0; i < SMOOTH_BUFFER_SIZE; i++) {
    average += InputBuffer1[i];
  }
  average /= (fix32)SMOOTH_BUFFER_SIZE;
  return average;
}
fix32 getTieredSmoothedInput0(fix32 input0, fix32 input1, fix32 threshold1, fix32 threshold2) {
  fix32 inputMagnitude = pythag(input0, input1);
  fix32 directWeight = (inputMagnitude - threshold1) / (threshold2 - threshold1);
  directWeight = clamp(directWeight, 0.0, 1.0);
  return getDirectInput(input0 * directWeight) + getSmoothedInput0(input0 * (1.0 - directWeight));
}
fix32 getTieredSmoothedInput1(fix32 input0, fix32 input1, fix32 threshold1, fix32 threshold2) {
  fix32 inputMagnitude = pythag(input0, input1);
  fix32 directWeight = (inputMagnitude - threshold1) / (threshold2 - threshold1);
  directWeight = clamp(directWeight, 0.0, 1.0);
  return getDirectInput(input1 * directWeight) + getSmoothedInput1(input1 * (1.0 - directWeight));
}

fix32 smoothJSM0(fix32 gyroX, fix32 gyroY, fix32 speed, fix32 recovery) {
  
  /* fix32 gyroLength = sqrt(gyroX * gyroX + gyroY * gyroY); */
// do gyro smoothing
// convert gyro smooth time to number of samples
  /* auto numGyroSamples = jc->getSetting(SettingID::GYRO_SMOOTH_TIME) * 1000.f / tick_time.get(); */
  /* if (numGyroSamples < 1) */
  /* 	numGyroSamples = 1; // need at least 1 sample */
  /* auto threshold = jc->getSetting(SettingID::GYRO_SMOOTH_THRESHOLD); */
  /* jc->GetSmoothedGyro(gyroX, gyroY, gyroLength, threshold / 2.0f, threshold, int(numGyroSamples), gyroX, gyroY); */
  /* //COUT << "%d Samples for threshold: %0.4f\n", numGyroSamples, gyro_smooth_threshold * maxSmoothingSamples); */
  
  // now, honour gyro_cutoff_speed
  fix32 gyroLength = pythag(gyroX, gyroY);
  if (recovery > speed) {
    // we can use gyro_cutoff_speed
    fix32 gyroIgnoreFactor = (gyroLength - speed) / (recovery - speed);
    if (gyroIgnoreFactor < 1.0) {
      if (gyroIgnoreFactor <= 0.0) {
        gyroX = gyroY = gyroLength = 0.0;
      } else {
        gyroX *= gyroIgnoreFactor;
        gyroY *= gyroIgnoreFactor;
        gyroLength *= gyroIgnoreFactor;
      }
    }
  }
  else if (speed > 0.0 && gyroLength < speed) {
    // gyro_cutoff_recovery is something weird, so we just do a hard threshold
    gyroX = gyroY = gyroLength = 0.0;
  }
  return gyroX;
}
fix32 smoothJSM1(fix32 gyroX, fix32 gyroY, fix32 speed, fix32 recovery) {
  // now, honour gyro_cutoff_speed
  fix32 gyroLength = pythag(gyroX, gyroY);
  if (recovery > speed) {
    // we can use gyro_cutoff_speed
    fix32 gyroIgnoreFactor = (gyroLength - speed) / (recovery - speed);
    if (gyroIgnoreFactor < 1.0) {
      if (gyroIgnoreFactor <= 0.0) {
        gyroX = gyroY = gyroLength = 0.0;
      } else {
        gyroX *= gyroIgnoreFactor;
        gyroY *= gyroIgnoreFactor;
        gyroLength *= gyroIgnoreFactor;
      }
    }
  }
  else if (speed > 0.0 && gyroLength < speed) {
    // gyro_cutoff_recovery is something weird, so we just do a hard threshold
    gyroX = gyroY = gyroLength = 0.0;
  }
  return gyroY;
}

/* void GetSmoothedGyro(float x, float y, float length, float bottomThreshold, float topThreshold, int maxSamples, float &outX, float &outY) {
// this is basically the same as we use for smoothing flick-stick rotations, but because this deals in vectors, it's a slightly different function. Not worth abstracting until it'll be used in more ways
// which item in the circular smoothing buffer will we write over?
_frontGyroSample--;
if (_frontGyroSample < 0)
_frontGyroSample = MaxGyroSamples - 1;
float immediateFactor;
if (topThreshold <= bottomThreshold)
{
immediateFactor = length < bottomThreshold ? 0.0f : 1.0f;
}
else
{
immediateFactor = (length - bottomThreshold) / (topThreshold - bottomThreshold);
}
// clamp to [0, 1] range
if (immediateFactor < 0.0f)
{
immediateFactor = 0.0f;
}
else if (immediateFactor > 1.0f)
{
immediateFactor = 1.0f;
}
float smoothFactor = 1.0f - immediateFactor;
// now we can push the smooth sample (or as much of it as we want smoothed)
FloatXY frontSample = _gyroSamples[_frontGyroSample] = { x * smoothFactor, y * smoothFactor };
// and now calculate smoothed result
float xResult = frontSample.x() / maxSamples;
float yResult = frontSample.y() / maxSamples;
for (int i = 1; i < maxSamples; i++)
{
int rotatedIndex = (_frontGyroSample + i) % MaxGyroSamples;
frontSample = _gyroSamples[rotatedIndex];
xResult += frontSample.x() / maxSamples;
yResult += frontSample.y() / maxSamples;
}
// finally, add immediate portion
outX = xResult + x * immediateFactor;
outY = yResult + y * immediateFactor;
}*/

//tight
fix32 getTightenedInput0(fix32 input0, fix32 input1, fix32 threshold) {
  fix32 inputMagnitude = pythag(input0, input1);
  if (inputMagnitude < threshold) {
    fix32 inputScale = inputMagnitude / threshold;
    return input0 * inputScale;
  }
  return input0;
}
fix32 getTightenedInput1(fix32 input0, fix32 input1, fix32 threshold) {
  fix32 inputMagnitude = pythag(input0, input1);
  if (inputMagnitude < threshold) {
    fix32 inputScale = inputMagnitude / threshold;
    return input1 * inputScale;
  }
  return input1;
}

fix32 getExpandedInput0(fix32 input0, fix32 input1, fix32 thresholdLow, fix32 thresholdHigh) {
  fix32 inputMagnitude = pythag(input0, input1);
  if (inputMagnitude > thresholdLow && inputMagnitude < thresholdHigh) {
    fix32 inputOffset = lerp(thresholdLow, thresholdHigh, 0.5);
    return input0 + inputOffset;
  }
  return input0;
}
fix32 getExpandedInput1(fix32 input0, fix32 input1, fix32 thresholdLow, fix32 thresholdHigh) {
  fix32 inputMagnitude = pythag(input0, input1);
  if (inputMagnitude > thresholdLow && inputMagnitude < thresholdHigh) {
    fix32 inputScale = inputMagnitude * 2.0;
    fix32 inputOffset = lerp(thresholdLow, thresholdHigh, 0.5);
    return input1 + inputOffset;
  }
  return input1;
}

//accel
void processGyroAccel(fix32 calibratedGyro0, fix32 calibratedGyro1,
uint32 deltaTime, fix32 sensitivitySlow, fix32 sensitivityFast,
fix32 slowThreshold, fix32 fastThreshold) {
  // apply calibration factor
  // get input velocity
  fix32 magnitude = pythag(calibratedGyro0, calibratedGyro1);
  // calculate position on slowThreshold to fastThreshold scale
  magnitude -= slowThreshold;
  if (magnitude < 0.0) {
    magnitude = 0.0;
  }
  fix32 denom = fastThreshold - slowThreshold;
  fix32 newSensitivity;
  if (denom <= 0.0) {
    newSensitivity = magnitude > 0.0 ? 1.0 : 0.0; // if min threshold overlaps max threshold, pop up to
    // max lowSens as soon as we're above min threshold
  } else {
    newSensitivity = magnitude / denom;
  }
  if (newSensitivity > 1.0) {
    newSensitivity = 1.0;
  }
  // interpolate between low sensitivity and high sensitivity
  newSensitivity = lerp(sensitivitySlow, sensitivityFast, newSensitivity);
  camera[0] = calibratedGyro0 * newSensitivity * (fix32)deltaTime;
  camera[1] = calibratedGyro1 * newSensitivity * (fix32)deltaTime;
}


fix32 pythag(fix32 a, fix32 b) {
  return sqrt( sq(a) + sq(b) );
}

bool processGyroStick(fix32 stickX, fix32 stickY) {
  //GPC has all axis represented in -100 to 100
  //This is not the case with JSM
  fix32 stickLength = pythag(stickX, stickY);
  fix32 livezoneSize = 1.0 - undeadzoneOuter - undeadzoneInner;
  //in order to correctly combine gyro and stick, we need to calculate what the stick
  //aiming is supposed to be doing, add gyro result to it, and convert back to stick
  if (unpower == 0.0) {
    unpower = 1.0;
  }
  
  fix32 stickVelocity = pow(clamp((stickLength - undeadzoneInner) / livezoneSize, 0.0, 1.0), unpower) * maxStickGameSpeed * virtualScale;
  fix32 expectedX = 0.0;
  fix32 expectedY = 0.0;
  gyroStickX = 0.0;
  gyroStickY = 0.0;
  
  
  if (stickVelocity > 0.0) {
    expectedX = (stickX / stickLength) * stickVelocity;
    expectedY = (stickY / stickLength) * stickVelocity;
  }
  
  //The original JSM function translates in-game turn velocity into units equivalent
  //to real world turn velocity, because a gyroscope reports real velocity.
  //TitanTwo reports everything including gyro on a scale of -100 to 100, so we need to work around this.
  expectedX += camera[0]*3.6; //the gyro readings top out at roughly 100.
  expectedY += camera[1]*3.6; //100 * 3.6 = 360.
  
  fix32 targetGyroVelocity = pythag(expectedX/10.0, expectedY/10.0) * 10.0; //sq(expected) exceeds fix32 range, oops!
  
  // map gyro velocity to achievable range in 0-1
  fix32 gyroInStickStrength = targetGyroVelocity >= maxStickGameSpeed ? 1.0 : targetGyroVelocity / maxStickGameSpeed;
  // unpower curve
  if (unpower != 0.0) {
    gyroInStickStrength = pow(gyroInStickStrength, 1.0 / unpower);
  }
  
  // remap to between inner and outer deadzones
  if (gyroInStickStrength > 0.010) {
    gyroInStickStrength = undeadzoneInner + gyroInStickStrength * livezoneSize;
    gyroStickX = (expectedX / targetGyroVelocity) * gyroInStickStrength;
    gyroStickY = (expectedY / targetGyroVelocity) * gyroInStickStrength;
  }
  
  if (logging) {
    printf("<big><br>\
    camera0: %f<br>\
    camera1: %f<br>\
    gyroVelocity0: %f<br>\
    gyroVelocity1: %f<br>\
    stickX: %f<br>\
    stickY: %f<br>\
    stickLength: %f<br>\
    stickVelocity: %f<br>\
    expectedX: %f<br>\
    expectedY: %f<br>\
    targetGyroVelocity: %f<br>\
    gyroInStickStrength: %f<br>\
    gyroStickX: %f<br>\
    gyroStickY: %f", camera[0], camera[1], gyroVelocity[0], gyroVelocity[1],
    stickX, stickY, stickLength, stickVelocity, expectedX, expectedY,
    targetGyroVelocity, gyroInStickStrength, gyroStickX, gyroStickY);
  }
  
  return stickLength > undeadzoneInner;
}

/* void processRotational() {
//handleFlickStick(float calX, float calY, float lastCalX, float lastCalY, float mouseCalibrationFactor)
isMouse = FALSE;
fix32 camSpeedX = 0.0;
fix32 lastOffsetX = lastCalX;
fix32 lastOffsetY = lastCalY;
fix32 lastStickAngle = atan2f(-lastOffsetX, lastOffsetY);
fix32 angleChange = stickAngle - lastStickAngle;
// https://stackoverflow.com/a/11498248/1130520
angleChange = mod(angleChange + PI, 2.0 * PI);
if (angleChange < 0) {
angleChange += 2.0 * PI;
}
angleChange -= PI;
flick_rotation_counter += angleChange; // track all rotation for this flick
fix32 flickSpeedConstant = isMouse ? REAL_WORLD_CALIBRATION * mouseCalibrationFactor / IN_GAME_SENS : 1.0;
fix32 flickSpeed = -(angleChange * flickSpeedConstant);
int maxSmoothingSamples = min(jc->NumSamples, (int)ceil(64.0 / tick_time.get())); // target a max smoothing window size of 64ms
//fix32 stepSize = 0.01;                                                            // and we only want full on smoothing when the stick change each time we poll it is approximately the minimum stick resolution
// the fact that we're using radians makes this really easy
fix32 rotate_smooth_override = 0.0; //ROTATE_SMOOTH_OVERRIDE;
if (rotate_smooth_override < 0.0) {
//camSpeedX = jc->GetSmoothedStickRotation(flickSpeed, flickSpeedConstant * stepSize * 2.0, flickSpeedConstant * stepSize * 4.0, maxSmoothingSamples);
} else {
//camSpeedX = jc->GetSmoothedStickRotation(flickSpeed, flickSpeedConstant * rotate_smooth_override, flickSpeedConstant * rotate_smooth_override * 2.0, maxSmoothingSamples);
}

if (!isMouse) {
// convert to a velocity
camSpeedX *= 180.0 / (PI * 0.001;// * tick_time.get());
}
fix32 secondsSinceFlick = ((float)chrono::duration_cast<chrono::microseconds>(jc->time_now - jc->started_flick).count()) / 1000000.0f;
fix32 maxStickGameSpeed = jc->getSetting(SettingID::VIRTUAL_STICK_CALIBRATION);
fix32 flickTime = abs(jc->delta_flick) / (maxStickGameSpeed * PI / 180.f);

if (secondsSinceFlick <= flickTime)
{
camSpeedX -= jc->delta_flick >= 0 ? maxStickGameSpeed : -maxStickGameSpeed;
}
}
*/

/*
<shortdesc>
Use your controller's gyro to aim! Supports outputting as mouse or joystick. Supports flickstick when in mouse mode. See interactive config for help.
</shortdesc>

<keywords>
gyro mouse flickstick
</keywords>

<cfgdesc>

[Layout]
shortdesc = Gyro Assignment
byteoffset = 0
bitsize = 8
bitoffset = 0
control = radiobox
default = 0
item = Gyro controls mouse
item = Gyro controls right joystick
item = Gyro controls left joystick (incomplete)
[Layout Flickstick]
shortdesc = 
byteoffset = 25
bitsize = 1
bitoffset = 4
control = checkbox
default = 0
item = Flickstick
groupcol = true
[Layout windingStick]
shortdesc = 
byteoffset = 25
bitsize = 1
bitoffset = 6
control = checkbox
default = 0
item = Rotational stick aim
group = true
[Layout stickDisable]
shortdesc = 
byteoffset = 25
bitsize = 1
bitoffset = 5
control = checkbox
default = 0
item = Disable right joystick in mouse mode
group = true

[Sensitivities]
shortdesc = Gyro sensitivity
byteoffset = 1
bitsize = 32
bitoffset = 0
control = spinboxf
decimals = 2
default = 0100
minimum = 0001
maximum = 1000
step = 001
[Stick sensitivity]
shortdesc = Stick sensitivity
byteoffset = 5
bitsize = 32
bitoffset = 0
control = spinboxf
decimals = 2
default = 0100
minimum = 0001
maximum = 1000
step = 001
group = true
[Game sensitivity]
shortdesc = Max stick game speed (joystick mode only)
byteoffset = 9
bitsize = 32
bitoffset = 0
control = spinboxf
decimals = 2
default = 36000
minimum = 00001
maximum = 99999
step = 000010
groupcol = true
[unpower]
shortdesc = unpower (joystick mode only)
byteoffset = 13
bitsize = 32
bitoffset = 0
control = spinboxf
decimals = 2
default = 000
minimum = 000
maximum = 200
step = 010
group = true

[Un-Deadzone (joystick mode only)]
shortdesc = Inner deadzone %
byteoffset = 17
bitsize = 32
bitoffset = 0
control = spinboxf
default = 0000
decimals = 2
step = 00050
minimum = 00000
maximum = 10000
[Deadzone outer]
shortdesc = Outer deadzone %
byteoffset = 21
bitsize = 32
bitoffset = 0
control = spinboxf
default = 0000
decimals = 2
step = 00050
minimum = 00000
maximum = 10000
group = true
[Deadzone Finder checkbox]
shortdesc	 = 
byteoffset = 25
bitsize	   = 1
bitoffset  = 0
control    = checkbox
default    = 0
item       = Deadzone Finder
groupcol = true
[Outer deadzone override]
shortdesc = 
byteoffset = 25
bitsize = 1
bitoffset = 1
control = checkbox
default = 0
item = Stick overrides outer deadzone
groupcol = true

[Acceleration]
shortdesc =
byteoffset = 25
bitsize = 1
bitoffset = 2
control = checkbox
default = 0
item = Enable Acceleration
[Acceleration slow sens]
shortdesc = Slow sensitivity
byteoffset = 26
bitsize = 32
bitoffset = 0
control = spinboxf
decimals = 2
default = 00050
minimum = 00000
maximum = 10000
step = 001
groupcol = true
[Acceleration fast sens]
shortdesc = Fast sensitivity
byteoffset = 30
bitsize = 32
bitoffset = 0
control = spinboxf
decimals = 2
default = 00500
minimum = 00001
maximum = 10000
step = 001
group = true
[Acceleration slow threshold]
shortdesc = Slow threshold
byteoffset = 34
bitsize = 32
bitoffset = 0
control = spinboxf
decimals = 2
default = 000100
minimum = 000000
maximum = 100000
step = 001
groupcol = true
[Acceleration fast threshold]
shortdesc = Fast threshold
byteoffset = 38
bitsize = 32
bitoffset = 0
control = spinboxf
decimals = 2
default = 001000
minimum = 000001
maximum = 100000
step = 0010
group = true

[Misc]
shortdesc = 
byteoffset = 25
bitsize = 1
bitoffset = 3
control = checkbox
default = 1
item = Calibrate gyro on startup
[Misc: Tightening threshold]
shortdesc = Tightening threshold
byteoffset = 42
bitsize = 32
bitoffset = 0
control = spinboxf
decimals = 2
default = 0
minimum = 000000
maximum = 100000
step = 100
groupcol = true
[Misc: Smoothing threshold]
shortdesc = Smoothing threshold
byteoffset = 46
bitsize = 32
bitoffset = 0
control = spinboxf
decimals = 2
default = 0
minimum = 000000
maximum = 100000
step = 100
group = true

[Output Protocol]
shortdesc = Remember this output next time you run the script
bitsize = 8
byteoffset = 50
control = combobox
default = 0
item = TitanTwo configured global default
item = PROTOCOL_AUTO
item = PROTOCOL_PS4
item = PROTOCOL_XB360
item = PROTOCOL_HID (HID required for mouse)
item = Bluetooth PROTOCOL_HID (HID required for mouse)
item = Bluetooth PROTOCOL_PS3
item = Bluetooth PROTOCOL_PS4
item = Bluetooth PROTOCOL_XB360
item = Bluetooth PROTOCOL_XB1
item = Bluetooth PROTOCOL_SWITCH
item = Bluetooth PROTOCOL_WII

[Info: Mouse vs Joystick?]
shortdesc = <<<MULTILINE
Gyro is functionally equivalent to mouse, and is best experienced when mapped to a mouse. However, I encountered some limitations with the TitanTwo and GPC, so things here are not ideal.
Mouse mode does work pretty well when paired with a XIM, though- try it for yourself and see if it works for you.

Joystick out is emulating a joystick, but how this feels will vary from game to game. In fact, since gyro is basically a mouse, it will feel a lot like you're trying to map a mouse to the joystick!
This code is not as comprehensive as XIM smart translators - so you may prefer to use mouse mode + XIM in one game, and the built in joystick emulation in other games.

NOTE: the HID ouptut protocol still outputs the whole controller as a joystick, and the XIM does see it!
Controller remaps will still take effect. Disable the right joystick to prevent double output.
MULTILINE
control = info

[Info: Flickstick]
shortdesc = <<<MULTILINE
The new aim method that I believe will one day replace traditional stick aim!
MULTILINE
control = info

[Info: Rotational stick aim]
shortdesc = <<<MULTILINE
Since flickstick on joystick output is severely compromised, I have implemented a component of flickstick: rotation. This keeps normal left/right stick aim, but allows for fine precision aim by pushing the stick forward and moving left or right. This allows you to keep using sensitivities that would otherwise be unusably high for a stick (which is a prerequisite for XIM). Normal left/right will allow for snappy turns, rotation for precision slow aim. Disables Y axis, so you'll want to map GYRO_OFF to something to re-orient yourself vertically.
MULTILINE
control = info

[Info: Sensitivities]
shortdesc = <<<MULTILINE
Gyro Sensitivity gets multiplied against sensor data to increase or decrease the output speed.

Stick sensitivity configures the sensitivity of the joystick in the same way, independently of gyro motion.

Unpower: If a game processes the joystick with a power curve, setting the exponent of the curve here will cancel out that curve for gyro output.
MULTILINE
control = info

[Info: Max Stick Game Speed]
shortdesc = <<<MULTILINE
Max stick game speed is a concept from JSM; it's suppposed to represent how fast (in degrees/s) the game allows you to look around using the stick. If you set it correctly in JSM, (game stick logic permitting) the motion of the controller will be translated 1:1 to the game. Additionally, this allows you to translate your preferred sensitivity between different games.

However! Most games have a low max speed which will clip fast movemonts (you know this if you've used mouse input on your Titan), the TitanTwo does not report gyro data to the script in degrees/s, and the specific number (unique per game) is pretty difficult to determine with precision. 

What this setting does in abstract is scale your motion to the range of the virtual joystick. Lower values will reach 100% output quicker- allowing you to easily hit the fastest turn speed with minimal motion, but move too fast and the game camera won't keep up. Higher values allow more room for quicker and more aggressive motion (like quick panic flicks), but you start to lose precision for slower movements.

You can guestimate the game's value with a timer. Set inner deadzone to 100% and enable Deadzone Finder. This will cause you to spin around in game at max speed. Look down at the ground in game and find a line to pivot around. Start the timer and count the number of complete rotations your character does in a given amount of time. The longer you let the timer run, the more accurate your estimate will be. Multiply [number of rotations]*360, and divide that by [seconds] to get your max stick game speed. If you spun around 12 times in 20 seconds, then (12*360)/20=216.
MULTILINE
control = info

[Info: Un-Deadzone]
shortdesc = <<<MULTILINE
Each game has its own joystick inner deadzone set by the developers.
If this script knows where the deadzone is, it can use that as the starting point for gyro outpoint, effectively eliminating the inner deadzone.

The outer deadzone can be used to avoid non-linear jumps in sensitivity programmed into the game, which feel unnatural with gyro aim.

Note that outer deadzone config option is asking for the size of the deadzone, not where the deadzone starts.
If there's a jump in acceleration at 92% stick tilt, you want an 8% outer deadzone.

Deadzone Finder helps precisely find inner deadzone. Titan will tilt the joystick at the configured inner deadzone. Find the highest value of inner deadzone where the camera DOESN'T move. Start at 25% and work your way up or down from there.

Stick overrides outer deadzone: Some games have a sharp jump in acceleration when the joystick is tilted near 100%.
This is undesirable for gyro aim, but might be desirable while using the stick because it helps you turn around faster in game.
MULTILINE
control = info

[Info: Acceleration]
shortdesc = <<<MULTILINE
Define a linear acceleration between the two sensitivities at the given movement speed thresholds.
There will be no acceleration below the slow threshold or above the fast threshold.
MULTILINE
control = info

[Info: Misc]
shortdesc = <<<MULTILINE
Calibrate gyro on startup:
Place the controller on a flat surface and do not move it until the LEDs change color.
The script is averaging sensor data to filter out unwanted sensor noise; this helps fight drift.

Tightening squishes output towards zero below the threshold, used to help prevent jitter when trying to hold still at higher sensitivities.

Smoothing helps reduce jitter above the threshold, useful for unsteady hands, or to smooth out noise with higher sensitivities.
MULTILINE
control = info

[Info: Speed Thresholds?]
shortdesc = <<<MULTILINE
Normally, you configure thresholds like this in values of degrees per second: how fast you are turning the controller. Unfortunately the TitanTwo doesn't present raw gyro data in this way, so the threshold number here is more abstract.
Try values like 0.01 when trying to set a threshold that activates when moving as slow as possible. The highest sensible values is somewhere under 200.

You can test where a threshold is by enabling acceleration with slow sensitivity 0, slow threshold 0, fast sensitivity 0.01. Then set fast threshold to the desired test number and see how fast you must move the controller to get a response.
MULTILINE
control = info

[Mouse Suggested Setup]
shortdesc = <<<MULTILINE
Enable acceleration, set slow sensitivity to 5.00 and slow threshold to 0.01.
Set fast sensitivity to your desired normal sensitivity, and fast threshold to 1 or 2.

The limitation I encountered with GPC is that mouse_set does not support precise values, so there's effectively a deadzone that you will notice when trying to move very slowly.
Acceleration set up in this way minimizes the issue. Try playing with different values in the same neighborhood, as well as tightening and smoothing. See what feels best to you.
Joystick emulation doesn't have this limitation.
MULTILINE
control = info
</cfgdesc>

[Credits]
shortdesc = <<<MULTILINE
Most of the concepts used and a lot of the code came from Jibb Smart's gyro wiki:
http://gyrowiki.jibbsmart.com
As well as Jibb Smart's JoyShockMapper project:
https://github.com/Electronicks/JoyShockMapper
Thank you!
MULTILINE
control = info
</cfgdesc>
*/
