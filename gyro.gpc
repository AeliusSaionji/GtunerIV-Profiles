#pragma METAINFO("Gyro", 1, 0, "Aelius")

/*
mouse_set uses int32, not precise enough. In order to be useful, we must
make magic math happen to really smooth out slow movement
*/

uint32 offsetSamples;
uint32 deltaTime;
uint32 timer = 0;
bool enableAccel = FALSE;
bool calibrating = TRUE;
fix32 gyroVelocity[2]; //0 is Yaw (Z), 1 is Pitch (X)
fix32 calibratedGyro[2];
fix32 gyroCalibration[2];
fix32 accumulatedOffset[2];
fix32 camera[2];
fix32 smoothThreshold = 0.0;
fix32 tightThreshold = 0.0;
fix32 slowSensitivity = 0.2;
fix32 fastSensitivity = 5.0;
fix32 slowThreshold = 0.1;
fix32 fastThreshold = 1.0;
fix32 gyroStickX;
fix32 gyroStickY;
fix32 unpower = 1.0;
fix32 undeadzoneInner = 0.1;
fix32 undeadzoneOuter = 0.0;
fix32 virtualScale = 0.5;
fix32 sensitivity = 1.0;

#include <mouse.gph>

init {
}

main {
  deltaTime += elapsed_time();
  if (deltaTime >= 2) {//delay main() loop at ~500Hz
    deltaTime = 0;
    gyroVelocity[0] = get_actual(GYRO_1_Z);
    gyroVelocity[1] = get_actual(GYRO_1_X);
    processInput(deltaTime);
    //Logic from JSM operates on a scale of 0-1
    if (processGyroStick(get_actual(STICK_1_X)/100.00, get_actual(STICK_1_Y)/100.00)) {
      set_val(STICK_1_X, gyroStickX * 100.00);
      set_val(STICK_1_Y, gyroStickY * 100.00);
    }
    
    //Bug? mouse_set only accepts int32, which is not precise enough.
    //Typecasting to int32 always rounds down, such that 0.8==0 but -0.8==-1
    //Thus _any_ noise causes drift in the negative direction,
    //but rounding filters out legitimate movement. Unsure how to proceed.
    /*
camera[0] = (camera[0] < 0.0) ? ceil(camera[0]) : camera[0];
camera[1] = (camera[1] < 0.0) ? ceil(camera[1]) : camera[1];
mouse_set(MOUSE_X, (int32)camera[0]);
mouse_set(MOUSE_Y, (int32)camera[1]);
    */
  }
}

void processGyroInput(fix32 calibratedGyro0, fix32 calibratedGyro1,
uint32 deltaTime, fix32 gyroSensitivity) {
  camera[0] = calibratedGyro0 * gyroSensitivity * (fix32)deltaTime;
  camera[1] = calibratedGyro1 * gyroSensitivity * (fix32)deltaTime;
}

void processInput(uint32 deltaTime) {
  //calibrating
  if (calibrating ) {
    offsetSamples++;
    accumulatedOffset[0] += gyroVelocity[0];
    accumulatedOffset[1] += gyroVelocity[1];
    printf("calibrating!", 0);
    timer++;
    if (timer > 1000) {
      led_set(LED_1, 50.0, 0);
      led_set(LED_2, 50.0, 0);
      led_set(LED_3, 50.0, 0);
      led_set(LED_4, 0.0, 0);
      calibrating = FALSE;
    }
  }
  
  gyroCalibration[0] = getCalibrationOffset(0);
  gyroCalibration[1] = getCalibrationOffset(1);
  calibratedGyro[0] = gyroVelocity[0] - gyroCalibration[0];
  calibratedGyro[1] = gyroVelocity[1] - gyroCalibration[1];
  
  
  //smoothing
  //  if (smoothThreshold > 0.0) {
  //    calibratedGyro = getTieredSmoothedInput(calibratedGyro, smoothThreshold/2.0, smoothThreshold);
  //  }
  
  //tightening
  if (tightThreshold > 0.0) {
    calibratedGyro[0] = getTightenedInput0(calibratedGyro[0], calibratedGyro[1], tightThreshold);
    calibratedGyro[1] = getTightenedInput1(calibratedGyro[0], calibratedGyro[1], tightThreshold);
  }
  
  
  //accelerating
  if (enableAccel) {
    processGyroAccel(calibratedGyro[0], calibratedGyro[1], deltaTime, slowSensitivity,
    fastSensitivity, slowThreshold, fastThreshold);
  } else {
    processGyroInput(calibratedGyro[0], calibratedGyro[1], deltaTime, sensitivity);
  }
}

fix32 getCalibrationOffset(int32 n) {
  if (offsetSamples == 0) {
    return 0.0;
  }
  return accumulatedOffset[n] / (fix32)offsetSamples;
}

void resetCalibration() {
  offsetSamples = 0;
  accumulatedOffset = 0.0;
}

/*//smooth

//No idea how to translate the array length stuff to GPC

fix32 getDirectInput0(fix32 input0) {
return input0;
}
fix32 getDirectInput1(fix32 input1) {
return input1;
}

// smoothing buffer
fix32 InputBuffer;
int32 CurrentInputIndex;

fix32 getSmoothedInput0(fix32 input0) {
CurrentInputIndex = mod(CurrentInputIndex + 1, InputBuffer.Length);
InputBuffer[CurrentInputIndex] = input0;
fix32 average = 0.0;
foreach (fix32 sample in InputBuffer) {
average += sample;
}
average /= InputBuffer.Length;
return average;
}
fix32 getSmoothedInput1(fix32 input1) {
CurrentInputIndex = mod(CurrentInputIndex + 1, InputBuffer.Length);
InputBuffer[CurrentInputIndex] = input1;
fix32 average = 0.0;
foreach (fix32 sample in InputBuffer) {
average += sample;
}
average /= InputBuffer.Length;
return average;
}

fix32 getTieredSmoothedInput0(fix32 input0, fix32 input1, fix32 threshold1, fix32 threshold2) {
fix32 inputMagnitude = pythag(input0, input1);
fix32 directWeight = (inputMagnitude - threshold1) / (threshold2 - threshold1);
directWeight = clamp(directWeight, 0.0, 1.0);
return getDirectInput0(input0 * directWeight) + getSmoothedInput(input0 * (1.0 - directWeight));
}
fix32 getTieredSmoothedInput1(fix32 input0, fix32 input1, fix32 threshold1, fix32 threshold2) {
fix32 inputMagnitude = pythag(input0, input1);
fix32 directWeight = (inputMagnitude - threshold1) / (threshold2 - threshold1);
directWeight = clamp(directWeight, 0.0, 1.0);
return getDirectInput1(input1 * directWeight) + getSmoothedInput1(input1 * (1.0 - directWeight));
}
*/

//tight
fix32 getTightenedInput0(fix32 input0, fix32 input1, fix32 threshold) {
  fix32 inputMagnitude = pythag(input0, input1);
  if (inputMagnitude < threshold) {
    fix32 inputScale = inputMagnitude / threshold;
    return input0 * inputScale;
  }
  return input0;
}
fix32 getTightenedInput1(fix32 input0, fix32 input1, fix32 threshold) {
  fix32 inputMagnitude = pythag(input0, input1);
  if (inputMagnitude < threshold) {
    fix32 inputScale = inputMagnitude / threshold;
    return input1 * inputScale;
  }
  return input1;
}

//accel
void processGyroAccel(fix32 calibratedGyro0, fix32 calibratedGyro1,
uint32 deltaTime, fix32 sensitivitySlow, fix32 sensitivityFast,
fix32 slowThreshold, fix32 fastThreshold) {
  // how fast is the gyro moving?
  fix32 speed = pythag(calibratedGyro0, calibratedGyro1);
  
  // where do we stand between the slow threshold and the fast threshold?
  fix32 slowFastFactor = (speed - slowThreshold) /
  (fastThreshold - slowThreshold);
  slowFastFactor = clamp(slowFastFactor, 0.0, 1.0); //is this the right scale for gpc?
  // linearly interpolate
  fix32 newSensitivity = lerp(sensitivitySlow, slowFastFactor, sensitivityFast);
  
  // now apply this sensitivity the way we originally did
  camera[0] = calibratedGyro0 * newSensitivity * (fix32)deltaTime;
  camera[1] = calibratedGyro1 * newSensitivity * (fix32)deltaTime;
}

fix32 pythag(fix32 a, fix32 b) {
  return sqrt( sq(a) + sq(b) );
}

bool processGyroStick(fix32 stickX, fix32 stickY) {
  fix32 stickLength = pythag(stickX, stickY);
  fix32 maxStickGameSpeed = 40.0;//REAL_WORLD_CALIBRATION/IN_GAME_SENS
  fix32 livezoneSize = 1.0 - undeadzoneOuter - undeadzoneInner;
  //in order to correctly combine gyro and stick, we need to calculate what the stick
  //aiming is supposed to be doing, add gyro result to it, and convert back to stick
  if (unpower == 0.0) {
    unpower = 1.0;
  }
  fix32 stickVelocity = pow(clamp((stickLength - undeadzoneInner) / livezoneSize, 0.0, 1.0), unpower) * maxStickGameSpeed * virtualScale;
  fix32 expectedX = 0.0;
  fix32 expectedY = 0.0;
  if (stickVelocity > 0.0) {
    expectedX = stickX / stickLength * stickVelocity;
    expectedY = -stickY / stickLength * stickVelocity;
  }
  
  expectedX += gyroVelocity[0];
  expectedY += gyroVelocity[1];
  
  fix32 targetGyroVelocity = pythag(expectedX, expectedY);
  
  // map gyro velocity to achievable range in 0-1
  fix32 gyroInStickStrength = targetGyroVelocity >= maxStickGameSpeed ? 1.0 : targetGyroVelocity / maxStickGameSpeed;
  
  // unpower curve
  if (unpower != 0.0) {
    gyroInStickStrength = pow(gyroInStickStrength, 1.0 / unpower);
  }
  
  // remap to between inner and outer deadzones
  if (gyroInStickStrength > 0.010) {
    gyroInStickStrength = undeadzoneInner + gyroInStickStrength * livezoneSize;
    gyroStickX = expectedX / targetGyroVelocity * gyroInStickStrength;
    gyroStickY = expectedY / targetGyroVelocity * gyroInStickStrength;
  }
  /* mystery stuff
if (jc->_context->_vigemController)
{
if (stickLength <= undeadzoneInner)
{
if (gyroInStickStrength == 0.0)
{
// hack to help with finding deadzones more quickly
jc->_context->_vigemController->setStick(undeadzoneInner, 0.0, isLeft);
}
else
{
jc->_context->_vigemController->setStick(gyroStickX, -gyroStickY, isLeft);
}
}
else
{
jc->_context->_vigemController->setStick(gyroStickX, -gyroStickY, isLeft);
}
}

jc->processed_gyro_stick |= gyroMatchesStickMode;
  */
  return stickLength > undeadzoneInner;
}