#pragma METAINFO("Gyro Aim", 1, 0, "Aelius")

/*
<shortdesc>
Use your controller's gyro to aim! Supports outputting as mouse or joystick. Supports flickstick when in mouse mode. See interactive config for help.
</shortdesc>

<keywords>
gyro mouse flickstick
</keywords>
*/

/* TODO
fix smoothing
fix unpower
finish interactive config
flickstick
player space gyro
fix mouse by applying data to new scale starting at 1, use rawaccel to fix speed
make printfs a function or something maybe
make sure it actually works when calibrate is off
implement on demand calibrate? or just tell user to reload script
*/

/* IC

<cfgdesc>

[Gyro Assignment]
shortdesc = 
byteoffset = 0
bitsize = 8
bitoffset = 0
control = radiobox
default = 0
item = Gyro controls mouse
item = Gyro controls right joystick
item = Gyro controls left joytick

[Sensitivities]
shortdesc = Gyro sensitivity
byteoffset = 1
bitsize = 16
bitoffset = 0
control = spinboxf
decimals = 2
default = 100
minimum = 001
maximum = 999
step = 001
[Stick sensitivity]
shortdesc = Stick sensitivity
byteoffset = 3
bitsize = 16
bitoffset = 0
control = spinboxf
decimals = 2
default = 100
minimum = 001
maximum = 999
step = 001
group = true
[Misc3]
shortdesc = Max stick game speed
byteoffset = 5
bitsize = 16
bitoffset = 0
control = slider
default = 40
minimum = 1
maximum = 500
step = 5
groupcol = true
[Misc4]
shortdesc = unpower
byteoffset = 7
bitsize = 8
bitoffset = 0
control = spinboxf
decimals = 2
default = 000
minimum = 000
maximum = 255
step = 100
group = true

[Un-Deadzone]
shortdesc = Inner deadzone %
byteoffset = 8
bitsize = 8
bitoffset = 0
control = spinbox
default = 0
decimals = 2
step = 1
minimum = 00
maximum = 95
[Deadzone outer]
shortdesc = Outer deadzone %
byteoffset = 9
bitsize = 8
bitoffset = 0
control = spinbox
default = 0
step = 1
minimum = 00
maximum = 95
group = true
[Deadzone Finder checkbox]
shortdesc	 =
byteoffset = 22
bitsize	   = 1
bitoffset  = 0
control    = checkbox
default    = 0
item       = Deadzone Finder
groupcol = true
[Outer deadzone override]
shortdesc =
byteoffset = 22
bitsize = 1
bitoffset = 1
control = checkbox
default = 0
item = Stick overrides outer deadzone
groupcol = true

[Acceleration]
shortdesc =
byteoffset = 22
bitsize = 1
bitoffset = 2
control = checkbox
default = 0
item = Enable Acceleration
[Acceleration slow sens]
shortdesc = Slow sensitivity
byteoffset = 10
bitsize = 16
bitoffset = 0
control = spinboxf
decimals = 2
default = 100
minimum = 001
maximum = 999
step = 001
groupcol = true
[Acceleration fast sens]
shortdesc = Fast sensitivity
byteoffset = 12
bitsize = 16
bitoffset = 0
control = spinboxf
decimals = 2
default = 500
minimum = 001
maximum = 999
step = 001
group = true
[Acceleration slow threshold]
shortdesc = Slow threshold
byteoffset = 14
bitsize = 16
bitoffset = 0
control = spinboxf
decimals = 2
default = 0100
minimum = 0001
maximum = 9999
step = 001
groupcol = true
[Acceleration fast threshold]
shortdesc = Fast threshold
byteoffset = 16
bitsize = 16
bitoffset = 0
control = spinboxf
decimals = 2
default = 1000
minimum = 0001
maximum = 9999
step = 0010
group = true

[Misc]
shortdesc =
byteoffset = 22
bitsize = 1
bitoffset = 3
control = checkbox
default = 1
item = Calibrate gyro on startup

[Misc5]
shortdesc = Tightening threshold
byteoffset = 18
bitsize = 16
bitoffset = 0
control = spinboxf
decimals = 2
default = 0
minimum = 00000
maximum = 65535
step = 100
groupcol = true
[Misc6]
shortdesc = Smoothing threshold
byteoffset = 20
bitsize = 16
bitoffset = 0
control = spinboxf
decimals = 2
default = 0
minimum = 00000
maximum = 65535
step = 100
group = true

[Info: Mouse vs Joystick]
shortdesc = <<<MULTILINE
Gyro is functionally equivalent to mouse, and this script is best used in mouse mode where possible.
While I have included joystick emulation, it may not feel ideal.
In fact, since gyro is a mouse, it will feel a lot like you're trying to map a mouse to the joystick!
For joystick only games, it would make a lot of sense to output as mouse into a Xim, so that you can use a Xim smart translator.
This is effectively what the Xim Nexus is!
MULTILINE
control = info

[Info: Sensitivities]
shortdesc = <<<MULTILINE
Gyro Sensitivity gets multiplied against sensor data to increase or decrease the output speed.

Stick sensitivity configures the sensitivity of the joystick in the same way, independently of gyro motion.

Max stick game speed represents the fastest you can look around in game; the higher the number, the faster you can move the controller without input being clipped.

Unpower: If a game processes the joystick with a power curve, setting the exponent of the curve here will cancel out that curve for gyro output.
MULTILINE
control = info

[Info: Un-Deadzone]
shortdesc = <<<MULTILINE
Each game has its own joystick inner deadzone set by the developers.
If this script knows where the deadzone is, we can use that as the starting point for gyro outpoint, effectively eliminating the inner deadzone.

The outer deadzone can be used to avoid non-linear jumps in sensitivity programmed into the game,
which feel unnatural with gyro aim.

Note that outer deadzone config option is asking for the size of the deadzone, not where the deadzone starts.
If there's a jump in acceleration at 92% stick tilt, you want an 8% outer deadzone.

Deadzone Finder helps precisely find inner deadzone. Titan will tilt the joystick at the configured inner deadzone.
Find the highest value of inner deadzone where the camera DOESN'T move.

Some games have a sharp jump in acceleration when the joystick is tilted near 100%.
This is undesirable for gyro aim, but might be desirable while using the stick because it helps you turn around faster in game.
MULTILINE
control = info

[Info: Calibrate gyro on startup]
shortdesc = <<<MULTILINE
Place the controller on a flat surface and do not move it until the LEDs change color.
The script is averaging sensor data to filter out unwanted sensor noise; this helps fight drift.
MULTILINE
control = info
</cfgdesc>

[Credits]
shortdesc = <<<MULTILINE
Most of the concepts used and a lot of the code came from Jibb Smart's gyro wiki:
http://gyrowiki.jibbsmart.com
As well as Jibb Smart's JoyShockMapper project:
https://github.com/Electronicks/JoyShockMapper
Thank you!
MULTILINE
control = info
</cfgdesc>
*/
#include <mouse.gph>

uint32 offsetSamples;
uint32 deltaTime;
uint32 timer = 0;
fix32 gyroVelocity[2]; //0 is Yaw (Z), 1 is Pitch (X)
fix32 calibratedGyro[2];
fix32 gyroCalibration[2];
fix32 accumulatedOffset[2];
fix32 camera[2];
fix32 gyroStickX;
fix32 gyroStickY;

bool stickEmulation = TRUE; //FALSE for mouse output
bool enableAccel = FALSE;
bool calibrating = TRUE;
bool outerStickOverride = TRUE;
bool logging = FALSE;
bool deadZoneFinder = FALSE;
fix32 undeadzoneInner = 0.0;
fix32 undeadzoneOuter = 0.0;

fix32 maxStickGameSpeed = 20.0;//REAL_WORLD_CALIBRATION/IN_GAME_SENS, apparently?

fix32 smoothThreshold = 0.0;
fix32 tightThreshold = 0.0;

fix32 slowSensitivity = 1.0;
fix32 fastSensitivity = 1.0;
fix32 slowThreshold = 1.0;
fix32 fastThreshold = 1.0;

fix32 unpower = 0.0;

fix32 virtualScale = 1.0;
fix32 sensitivity = 1.0;

init {
  pmem_load();
  deadZoneFinder = (pmem_read(22)) & 0b1;
  outerStickOverride = (pmem_read(22)>>1) & 0b1;
  enableAccel = (pmem_read(22)>>2) & 0b1;
  calibrating = (pmem_read(22)>>3) & 0b1;

  unpower = pmem_read_int16tofix32(7)/100.0;
  undeadzoneInner = pmem_read_int16tofix32(8)/100.0;
  undeadzoneOuter = pmem_read_int16tofix32(9)/100.0;
  
  maxStickGameSpeed = pmem_read_int16tofix32(5)*256.0;
  
  sensitivity = pmem_read_int16tofix32(1);
  printf("%f", maxStickGameSpeed);


}

// read fix16 from pmem position ( read int16 and return it as fix32 )
fix32 pmem_read_int16tofix32 (uint8 pmem_location) {
  int16 valInt16;
  pmem_read(pmem_location, &valInt16);
  return (fix32)valInt16 / 256.0;
}

main {
  deltaTime += elapsed_time();
  //GPC bug? titan unresponsive when deltaTime loop is less than 4ms, or if loop absent
  if (deltaTime >= 4) {//delay main() loop at ~250Hz
    gyroVelocity[0] = get_actual(GYRO_1_Z);
    gyroVelocity[1] = get_actual(GYRO_1_X);
    processInput(deltaTime);
    if (stickEmulation) {
      //Logic from JSM operates on a scale of 0-1
      if (processGyroStick(get_actual(STICK_1_X)/100.00, get_actual(STICK_1_Y)/100.00)) {
        //Nothing here because set_val can't be in the loop.
        //Just reminding myself that this function returns a bool
        //and the set_val was here in JSM...
      }
    }
    deltaTime = 0;
  }
  
  //set_val must be outside the polling loop!
  //lest values bounce back to 0 every cycle
  
  if  (stickEmulation) {
    if (deadZoneFinder == TRUE) {
      // hack to help with finding deadzones more quickly
      set_val(STICK_1_X, undeadzoneInner * 100.00);
    } else {
      set_val(STICK_1_X, gyroStickX * 100.00);
      set_val(STICK_1_Y, gyroStickY * 100.00);
    }
    //hack for overwatch/misc: skip outer deadzone logic for the actual joystick
    //gyro is still subject to deadzone and thus remains linear.
    //stick now has access to overwatch's snappy stick turn logic
    if (outerStickOverride == TRUE) {
      if (get_actual(STICK_1_X) >= 92.0 || get_actual(STICK_1_X) <= -92.0)  {
        set_val(STICK_1_X, get_actual(STICK_1_X));
        //set_val(STICK_1_Y, get_actual(STICK_1_Y));
      }
    }
  }
  
  //GPC bug? mouse_set only accepts int32, which is not precise enough.
  //Typecasting to int32 always rounds down, such that 0.8==0 but -0.8==-1
  //Thus _any_ noise causes drift in the negative direction,
  //but rounding filters out legitimate movement. Unsure how to proceed.
  //TODO: linear rescale to > 1.0
  camera[0] = (camera[0] < 0.0) ? ceil(camera[0]) : camera[0];
  camera[1] = (camera[1] < 0.0) ? ceil(camera[1]) : camera[1];
  mouse_set(MOUSE_X, (int32)camera[0]);
  mouse_set(MOUSE_Y, (int32)camera[1]);
}

void processInput(uint32 deltaTime) {
  //calibrating
  if (calibrating) {
    offsetSamples++;
    accumulatedOffset[0] += gyroVelocity[0];
    accumulatedOffset[1] += gyroVelocity[1];
    printf("calibrating!", 0);
    timer++;
    if (timer > 500) {
      led_set(LED_1, 50.0, 0);
      led_set(LED_2, 50.0, 0);
      led_set(LED_3, 50.0, 0);
      led_set(LED_4, 0.0, 0);
      calibrating = FALSE;
    }
  }
  
  gyroCalibration[0] = getCalibrationOffset(0);
  gyroCalibration[1] = getCalibrationOffset(1);
  calibratedGyro[0] = gyroVelocity[0] - gyroCalibration[0];
  calibratedGyro[1] = gyroVelocity[1] - gyroCalibration[1];  
  
  //smoothing
  //  if (smoothThreshold > 0.0) {
  //    calibratedGyro = getTieredSmoothedInput(calibratedGyro, smoothThreshold/2.0, smoothThreshold);
  //  }
  
  //tightening
  if (tightThreshold > 0.0) {
    calibratedGyro[0] = getTightenedInput0(calibratedGyro[0], calibratedGyro[1], tightThreshold);
    calibratedGyro[1] = getTightenedInput1(calibratedGyro[0], calibratedGyro[1], tightThreshold);
  }
  
  
  //accelerating
  if (enableAccel) {
    processGyroAccel(calibratedGyro[0], calibratedGyro[1], deltaTime, slowSensitivity,
    fastSensitivity, slowThreshold, fastThreshold);
  } else {
    processGyroInput(calibratedGyro[0], calibratedGyro[1], deltaTime, sensitivity);
  }
}

fix32 getCalibrationOffset(int32 n) {
  if (offsetSamples == 0) {
    return 0.0;
  }
  if (n==0) {
    return accumulatedOffset[0] / (fix32)offsetSamples;
  } else if (n==1) {
    return accumulatedOffset[1] / (fix32)offsetSamples;
  }
  return 0.0; //GPC won't compile if function returns are in conditionals
}

void resetCalibration() {
  offsetSamples = 0;
  accumulatedOffset = 0.0;
}

void processGyroInput(fix32 calibratedGyro0, fix32 calibratedGyro1,
uint32 deltaTime, fix32 gyroSensitivity) {
  camera[0] = calibratedGyro0 * gyroSensitivity * (fix32)deltaTime;
  camera[1] = calibratedGyro1 * gyroSensitivity * (fix32)deltaTime;
}

/*//smooth

//No idea how to translate the array length stuff to GPC

fix32 getDirectInput0(fix32 input0) {
return input0;
}
fix32 getDirectInput1(fix32 input1) {
return input1;
}

// smoothing buffer
fix32 InputBuffer;
int32 CurrentInputIndex;

fix32 getSmoothedInput0(fix32 input0) {
CurrentInputIndex = mod(CurrentInputIndex + 1, InputBuffer.Length);
InputBuffer[CurrentInputIndex] = input0;
fix32 average = 0.0;
foreach (fix32 sample in InputBuffer) {
average += sample;
}
average /= InputBuffer.Length;
return average;
}
fix32 getSmoothedInput1(fix32 input1) {
CurrentInputIndex = mod(CurrentInputIndex + 1, InputBuffer.Length);
InputBuffer[CurrentInputIndex] = input1;
fix32 average = 0.0;
foreach (fix32 sample in InputBuffer) {
average += sample;
}
average /= InputBuffer.Length;
return average;
}

fix32 getTieredSmoothedInput0(fix32 input0, fix32 input1, fix32 threshold1, fix32 threshold2) {
fix32 inputMagnitude = pythag(input0, input1);
fix32 directWeight = (inputMagnitude - threshold1) / (threshold2 - threshold1);
directWeight = clamp(directWeight, 0.0, 1.0);
return getDirectInput0(input0 * directWeight) + getSmoothedInput(input0 * (1.0 - directWeight));
}
fix32 getTieredSmoothedInput1(fix32 input0, fix32 input1, fix32 threshold1, fix32 threshold2) {
fix32 inputMagnitude = pythag(input0, input1);
fix32 directWeight = (inputMagnitude - threshold1) / (threshold2 - threshold1);
directWeight = clamp(directWeight, 0.0, 1.0);
return getDirectInput1(input1 * directWeight) + getSmoothedInput1(input1 * (1.0 - directWeight));
}
*/

//tight
fix32 getTightenedInput0(fix32 input0, fix32 input1, fix32 threshold) {
  fix32 inputMagnitude = pythag(input0, input1);
  if (inputMagnitude < threshold) {
    fix32 inputScale = inputMagnitude / threshold;
    return input0 * inputScale;
  }
  return input0;
}
fix32 getTightenedInput1(fix32 input0, fix32 input1, fix32 threshold) {
  fix32 inputMagnitude = pythag(input0, input1);
  if (inputMagnitude < threshold) {
    fix32 inputScale = inputMagnitude / threshold;
    return input1 * inputScale;
  }
  return input1;
}

//accel
void processGyroAccel(fix32 calibratedGyro0, fix32 calibratedGyro1,
uint32 deltaTime, fix32 sensitivitySlow, fix32 sensitivityFast,
fix32 slowThreshold, fix32 fastThreshold) {
  // how fast is the gyro moving?
  fix32 speed = pythag(calibratedGyro0, calibratedGyro1);
  
  // where do we stand between the slow threshold and the fast threshold?
  fix32 slowFastFactor = (speed - slowThreshold) /
  (fastThreshold - slowThreshold);
  slowFastFactor = clamp(slowFastFactor, 0.0, 1.0); //is this the right scale for gpc?
  // linearly interpolate
  fix32 newSensitivity = lerp(sensitivitySlow, slowFastFactor, sensitivityFast);
  
  // now apply this sensitivity the way we originally did
  camera[0] = calibratedGyro0 * newSensitivity * (fix32)deltaTime;
  camera[1] = calibratedGyro1 * newSensitivity * (fix32)deltaTime;
}

fix32 pythag(fix32 a, fix32 b) {
  return sqrt( sq(a) + sq(b) );
}

bool processGyroStick(fix32 stickX, fix32 stickY) {
  fix32 stickLength = pythag(stickX, stickY);
  fix32 livezoneSize = 1.0 - undeadzoneOuter - undeadzoneInner;
  //in order to correctly combine gyro and stick, we need to calculate what the stick
  //aiming is supposed to be doing, add gyro result to it, and convert back to stick
  if (unpower == 0.0) {
    unpower = 1.0;
  }
  fix32 stickVelocity = pow(clamp((stickLength - undeadzoneInner) / livezoneSize, 0.0, 1.0), unpower) * maxStickGameSpeed * virtualScale;
  fix32 expectedX = 0.0;
  fix32 expectedY = 0.0;
  gyroStickX = 0.0;
  gyroStickY = 0.0;
  
  if (stickVelocity > 0.0) {
    expectedX = stickX / stickLength * stickVelocity;
    expectedY = stickY / stickLength * stickVelocity;
  }
  
  //expectedX += gyroVelocity[0];
  //expectedY += gyroVelocity[1]; //raw data seems to work better
  expectedX += camera[0]; //honestly, I think my calibration code is whack
  expectedY += camera[1];
  
  fix32 targetGyroVelocity = pythag(expectedX, expectedY);
  // map gyro velocity to achievable range in 0-1
  fix32 gyroInStickStrength = targetGyroVelocity >= maxStickGameSpeed ? 1.0 : targetGyroVelocity / maxStickGameSpeed;
  // unpower curve
  //broken for 2+???
  if (unpower != 0.0) {
    gyroInStickStrength = pow(gyroInStickStrength, 1.0 / unpower);
  }
  
  // remap to between inner and outer deadzones
  if (gyroInStickStrength > 0.010) {
    gyroInStickStrength = undeadzoneInner + gyroInStickStrength * livezoneSize;
    gyroStickX = expectedX / targetGyroVelocity * gyroInStickStrength;
    gyroStickY = expectedY / targetGyroVelocity * gyroInStickStrength;
  }
  
  if (logging) {
    printf("camera0: %f",camera[0]);
    printf("camera1: %f",camera[1]);
    printf("gyroVelocity0: %f",gyroVelocity[0]);
    printf("gyroVelocity1: %f",gyroVelocity[1]);
    printf("stickX: %f",stickX);
    printf("stickY: %f",stickY);
    printf("expectedX: %f",expectedX);
    printf("expectedY: %f",expectedY);
    printf("gyroStickX %f", gyroStickX);
    printf("gyroStickY %f", gyroStickY);
    printf("stickLength: %f",stickLength);
    printf("stickVelocity: %f",stickVelocity);
    printf("targetGyroVelocity: %f",targetGyroVelocity);
    printf("gyroInStickStrength: %f",gyroInStickStrength);
  }
  
  return stickLength > undeadzoneInner;
}
