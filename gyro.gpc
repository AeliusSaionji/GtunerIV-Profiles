#pragma METAINFO("Gyro Aim", 1, 0, "Aelius")

/*

END USER CUSTOMIZATION GUIDE - README
* Initiate a recalibration with combo_run(recalibrate).
-- You may need to do this periodically.
-- Place controller on a flat and steady surface before calibrating.
-- The combo will wait two seconds to give you time to get your hands off.
* SMOOTH_BUFFER_SIZE controls how many samples the smoothing function collects.
-- More smoothing means more latency.
-- The TitanTwo starts to complain about memory > 70
* HID output protocol still outputs the controller!
-- And the XIM does see it!

NOTES
- The TitanTwo seems to map gyro data onto a range of 0.00-102.399994 rather than reporting angular velocity.
- mouse_set does not support fix32 output, and int32 is not precise enough at slow speeds.
**** mouse mouse is hurt by this limitation.

TODO

xim specific axis fix?
fix left stick output (hold)
add jsm config names for visibility
user configurable smoothing buffer size in IC?
user configurable mouseCalibration
gyro_off
flickstick mouse
flickstick joystick?
winding flickstick seems like a good idea
player space gyro
implement on demand calibrate? or just tell user to reload script
on demand adjust of sens/speed/smooth/etc? and pmem_save
optimize variables and memory usage

*/

#include <mouse.gph>
#define SMOOTH_BUFFER_SIZE 32 //Don't exceed 70

//Misc Globals
uint32 offsetSamples;
uint32 counter = 0;
fix32 gyroVelocity[2]; //0 is Yaw (Z), 1 is Pitch (X)
fix32 calibratedGyro[2];
fix32 gyroCalibration[2];
fix32 accumulatedOffset[2];
fix32 camera[2];
fix32 gyroStickX;
fix32 gyroStickY;

//Settings
uint8 stickEmulation = 0; //0 for mouse output, 1 for right stick, 2 for left stick
uint8 outProtocol = 0; //0=ignore, 1=PROTOCOL_AUTO, 2=PROTOCOL_HID
bool enableAccel = FALSE;
bool calibrating = TRUE;
bool outerStickOverride = FALSE;
bool stickDisable = FALSE;
bool logging = TRUE;
bool deadZoneFinder = FALSE;
fix32 undeadzoneInner = 0.0;
fix32 undeadzoneOuter = 0.0;
fix32 maxStickGameSpeed = 40.0;//REAL_WORLD_CALIBRATION/IN_GAME_SENS, apparently?
fix32 smoothThreshold = 0.0;
fix32 tightThreshold = 0.0;
fix32 slowSensitivity = 1.0;
fix32 fastSensitivity = 5.0;
fix32 slowThreshold = 1.0;
fix32 fastThreshold = 10.0;
fix32 unpower = 0.0;
fix32 virtualScale = 1.0;
fix32 sensitivity = 1.0;

init {
  pmem_load();
  
  //ints
  stickEmulation = pmem_read(0);
  outProtocol    = pmem_read(50);
  //bools
  deadZoneFinder     = (pmem_read(25))    & 0b1;
  outerStickOverride = (pmem_read(25)>>1) & 0b1;
  enableAccel        = (pmem_read(25)>>2) & 0b1;
  calibrating        = (pmem_read(25)>>3) & 0b1;
  stickDisable       = (pmem_read(25)>>4) & 0b1;
  //fix32s
  pmem_read(17, &undeadzoneInner);
  pmem_read(21, &undeadzoneOuter);
  undeadzoneInner /= 100.0;//0-1 scale
  undeadzoneOuter /= 100.0;
  pmem_read(1,  &sensitivity);
  pmem_read(5,  &virtualScale);
  pmem_read(13, &unpower);
  pmem_read(9,  &maxStickGameSpeed);
  pmem_read(34, &slowThreshold);
  pmem_read(38, &fastThreshold);
  pmem_read(26, &slowSensitivity);
  pmem_read(30, &fastSensitivity);
  pmem_read(42, &tightThreshold);
  pmem_read(46, &smoothThreshold);
  
  switch (outProtocol) {
    case 1:  port_connect(PORT_USB_C, PROTOCOL_AUTO);   break;
    case 2:  port_connect(PORT_USB_C, PROTOCOL_PS4);    break;
    case 3:  port_connect(PORT_USB_C, PROTOCOL_XB360);  break;
    case 4:  port_connect(PORT_USB_C, PROTOCOL_HID);    break;
    case 5:  port_connect(PORT_BT_C,  PROTOCOL_HID);    break;
    case 6:  port_connect(PORT_BT_C,  PROTOCOL_PS3);    break;
    case 7:  port_connect(PORT_BT_C,  PROTOCOL_PS4);    break;
    case 8:  port_connect(PORT_BT_C,  PROTOCOL_XB360);  break;
    case 9:  port_connect(PORT_BT_C,  PROTOCOL_XB1);    break;
    case 10: port_connect(PORT_BT_C,  PROTOCOL_SWITCH); break;
    case 11: port_connect(PORT_BT_C,  PROTOCOL_WII);    break;
    default: break;
  }
}

main {
  uint32 deltaTime;
  deltaTime += elapsed_time();
  //GPC bug? titan unresponsive when deltaTime loop is less than 4ms, or if loop absent
  if (deltaTime >= 4) {//delay main() loop at ~250Hz
    //printf("X %f", camera[0]);
    //printf("Y %f", camera[1]);
    gyroVelocity[0] = get_actual(GYRO_1_Z)/2.0; //Half, because it brings us pretty close to matching JSM's virtual output.
    gyroVelocity[1] = get_actual(GYRO_1_X)/2.0;
    processInput(deltaTime);
    if (stickEmulation == 1) {//Right stick
      //Logic from JSM operates on a scale of 0-1
      if (processGyroStick(get_actual(STICK_1_X)/100.00, get_actual(STICK_1_Y)/100.0)) {} //returns a bool
    }
    if (stickEmulation == 2) {//Left stick
      //Logic from JSM operates on a scale of 0-1
      if (processGyroStick(get_actual(STICK_2_X)/100.00, get_actual(STICK_2_Y)/100.0)) {} //returns a bool
    }
    deltaTime = 0;
  }
  
  //set_val must be outside the polling loop!
  //lest values bounce back to 0 every cycle
  
  if  (stickEmulation) {
    if (deadZoneFinder == TRUE) {
      // hack to help with finding deadzones more quickly
      set_val(STICK_1_X, undeadzoneInner * 100.0);
    } else if (stickEmulation == 1) {
      set_val(STICK_1_X, gyroStickX * 100.0);
      set_val(STICK_1_Y, gyroStickY * 100.0);
    } else if (stickEmulation == 2) {
      set_val(STICK_2_X, gyroStickX * 100.0);
      set_val(STICK_2_Y, gyroStickY * 100.0);
    }
    //Hack for games with accel boost at outer zone: skip outer deadzone logic for the actual joystick
    //Gyro is still subject to deadzone and thus remains linear,
    //but stick now has access to game's accel for snappy stick turning
    if (outerStickOverride == TRUE) {
      if (get_actual(STICK_1_X) >= 95.0) {
        set_val(STICK_1_X, (gyroStickX + undeadzoneOuter) * 100.0);
      } else if (get_actual(STICK_1_X) <= -95.0) {
        set_val(STICK_1_X, (gyroStickX - undeadzoneOuter) * 100.0);
      } else if (get_actual(STICK_1_Y) >= 95.0) {
        set_val(STICK_1_Y, (gyroStickY + undeadzoneOuter) * 100.0);
      } else if (get_actual(STICK_1_Y) <= -95.0) {
        set_val(STICK_1_Y, (gyroStickY - undeadzoneOuter) * 100.0);
      }
    }
  }
  
  //GPC bug? mouse_set only accepts int32, which is not precise enough.
  //Typecasting to int32 always rounds down, such that 0.8==0 but -0.8==-1
  //Thus _any_ noise causes drift in the negative direction,
  //but rounding filters out legitimate movement.
  //TODO (?): linear rescale to > 1.0. End user must use rawAccel to fix.
  if (stickEmulation == 0) {//mouse
    //fix32 mouseCalibration = (REAL_WORLD_CALIBRATION) / os_mouse_speed / IN_GAME_SENS);
    fix32 mouseCalibration = 0.1;
    fix32 mouseX = camera[0] * mouseCalibration * (fix32)deltaTime;
    fix32 mouseY = (camera[1] - 1.0) * mouseCalibration * (fix32)deltaTime;
    
    mouseX = (mouseX < 0.0) ? ceil(mouseX) : mouseX;
    mouseY = (mouseY < 0.0) ? ceil(mouseY) : mouseY;
    mouse_set(MOUSE_X, (int32)mouseX);
    mouse_set(MOUSE_Y, (int32)mouseY);
    //Controller is still passed as a joystick in HID output, it may be active
    if (stickDisable) {
      set_val(STICK_1_X, 0.0);//disable right joystick
      set_val(STICK_1_Y, 0.0);
    } else if (virtualScale != 1.0) {//Apply virtualScale aka stickSensitivity
      set_val(STICK_1_X, get_actual(STICK_1_X)/virtualScale);
      set_val(STICK_1_Y, get_actual(STICK_1_Y)/virtualScale);
    }
  }
}

void processInput(uint32 deltaTime) {
  //calibrating
  if (calibrating) {
    offsetSamples++;
    accumulatedOffset[0] += gyroVelocity[0];
    accumulatedOffset[1] += gyroVelocity[1];
    printf("calibrating!", 0);
    counter++;
    if (counter > 500) {
      led_set(LED_1, 50.0, 0);
      led_set(LED_2, 50.0, 0);
      led_set(LED_3, 50.0, 0);
      led_set(LED_4, 0.0, 0);
      calibrating = FALSE;
    }
  }
  
  gyroCalibration[0] = getCalibrationOffset(0);
  gyroCalibration[1] = getCalibrationOffset(1);
  calibratedGyro[0] = (gyroVelocity[0] - gyroCalibration[0]);
  calibratedGyro[1] = (gyroVelocity[1] - gyroCalibration[1]);
  
  //smoothing
  if (smoothThreshold > 0.0) {
    calibratedGyro[0] = getTieredSmoothedInput0(calibratedGyro[0], calibratedGyro[1], smoothThreshold/2.0, smoothThreshold);
    calibratedGyro[1] = getTieredSmoothedInput1(calibratedGyro[0], calibratedGyro[1], smoothThreshold/2.0, smoothThreshold);
  }
  
  //calibratedGyro[0] = smoothJSM0(calibratedGyro[0], calibratedGyro[1]);
  //calibratedGyro[1] = smoothJSM1(calibratedGyro[0], calibratedGyro[1]);
  
  
  //tightening
  if (tightThreshold > 0.0) {
    calibratedGyro[0] = getTightenedInput0(calibratedGyro[0], calibratedGyro[1], tightThreshold);
    calibratedGyro[1] = getTightenedInput1(calibratedGyro[0], calibratedGyro[1], tightThreshold);
  }
  
  //accelerating
  if (enableAccel) {
    processGyroAccel(calibratedGyro[0], calibratedGyro[1], deltaTime, slowSensitivity, fastSensitivity, slowThreshold, fastThreshold);
  } else {
    processGyroInput(calibratedGyro[0], calibratedGyro[1], deltaTime, sensitivity);
  }
}

fix32 getCalibrationOffset(int32 n) {
  if (offsetSamples == 0) {
    return 0.0;
  }
  if (n==0) {
    return accumulatedOffset[0] / (fix32)offsetSamples;
  } else if (n==1) {
    return accumulatedOffset[1] / (fix32)offsetSamples;
  }
  return 0.0; //GPC won't compile if function returns are in conditionals
}

void resetCalibration() {
  offsetSamples = 0;
  accumulatedOffset = 0.0;
}

combo recalibrate {
  resetCalibration();
  wait(0);
  wait(2000); //wait 2s for the user to take hands off controller
  calibrating = TRUE;
}

void processGyroInput(fix32 calibratedGyro0, fix32 calibratedGyro1, uint32 deltaTime, fix32 gyroSensitivity) {
  camera[0] = calibratedGyro0 * gyroSensitivity * (fix32)deltaTime;
  camera[1] = calibratedGyro1 * gyroSensitivity * (fix32)deltaTime;
}

// smoothing buffer - adapted from blog
fix32 getDirectInput(fix32 input) {//What is this function even doing?
  return input;
}

fix32 InputBuffer0[SMOOTH_BUFFER_SIZE];
int32 CurrentInputIndex0;
fix32 InputBuffer1[SMOOTH_BUFFER_SIZE];
int32 CurrentInputIndex1;

fix32 getSmoothedInput0(fix32 input) {
  CurrentInputIndex0 = (int32)mod((fix32)CurrentInputIndex0 + (fix32)1, (fix32)SMOOTH_BUFFER_SIZE);
  InputBuffer0[CurrentInputIndex0] = input;
  fix32 average = 0.0;
  int32 i;
  for (i = 0; i < SMOOTH_BUFFER_SIZE; i++) {
    average += InputBuffer0[i];
  }
  average /= (fix32)SMOOTH_BUFFER_SIZE;
  return average;
}
fix32 getSmoothedInput1(fix32 input) {
  CurrentInputIndex1 = (int32)mod((fix32)CurrentInputIndex1 + (fix32)1, (fix32)SMOOTH_BUFFER_SIZE);
  InputBuffer1[CurrentInputIndex1] = input;
  fix32 average = 0.0;
  int32 i;
  for (i = 0; i < SMOOTH_BUFFER_SIZE; i++) {
    average += InputBuffer1[i];
  }
  average /= (fix32)SMOOTH_BUFFER_SIZE;
  return average;
}
fix32 getTieredSmoothedInput0(fix32 input0, fix32 input1, fix32 threshold1, fix32 threshold2) {
  fix32 inputMagnitude = pythag(input0, input1);
  fix32 directWeight = (inputMagnitude - threshold1) / (threshold2 - threshold1);
  directWeight = clamp(directWeight, 0.0, 1.0);
  return getDirectInput(input0 * directWeight) + getSmoothedInput0(input0 * (1.0 - directWeight));
}
fix32 getTieredSmoothedInput1(fix32 input0, fix32 input1, fix32 threshold1, fix32 threshold2) {
  fix32 inputMagnitude = pythag(input0, input1);
  fix32 directWeight = (inputMagnitude - threshold1) / (threshold2 - threshold1);
  directWeight = clamp(directWeight, 0.0, 1.0);
  return getDirectInput(input1 * directWeight) + getSmoothedInput1(input1 * (1.0 - directWeight));
}

fix32 smoothJSM0(fix32 gyroX, fix32 gyroY) {
  
  /* fix32 gyroLength = sqrt(gyroX * gyroX + gyroY * gyroY); */
// do gyro smoothing
// convert gyro smooth time to number of samples
  /* auto numGyroSamples = jc->getSetting(SettingID::GYRO_SMOOTH_TIME) * 1000.f / tick_time.get(); */
  /* if (numGyroSamples < 1) */
  /* 	numGyroSamples = 1; // need at least 1 sample */
  /* auto threshold = jc->getSetting(SettingID::GYRO_SMOOTH_THRESHOLD); */
  /* jc->GetSmoothedGyro(gyroX, gyroY, gyroLength, threshold / 2.0f, threshold, int(numGyroSamples), gyroX, gyroY); */
  /* //COUT << "%d Samples for threshold: %0.4f\n", numGyroSamples, gyro_smooth_threshold * maxSmoothingSamples); */
  
  // now, honour gyro_cutoff_speed
  fix32 gyroLength = pythag(gyroX, gyroY);
  fix32 speed = 0.0; //GYRO_CUTOFF_SPEED;
  fix32 recovery = 00.0; //GYRO_CUTOFF_RECOVERY;
  if (recovery > speed) {
    // we can use gyro_cutoff_speed
    fix32 gyroIgnoreFactor = (gyroLength - speed) / (recovery - speed);
    if (gyroIgnoreFactor < 1.0) {
      if (gyroIgnoreFactor <= 0.0) {
        gyroX = gyroY = gyroLength = 0.0;
      } else {
        gyroX *= gyroIgnoreFactor;
        gyroY *= gyroIgnoreFactor;
        gyroLength *= gyroIgnoreFactor;
      }
    }
  }
  else if (speed > 0.0 && gyroLength < speed) {
    // gyro_cutoff_recovery is something weird, so we just do a hard threshold
    gyroX = gyroY = gyroLength = 0.0;
  }
  return gyroX;
}
fix32 smoothJSM1(fix32 gyroX, fix32 gyroY) {
  // now, honour gyro_cutoff_speed
  fix32 gyroLength = pythag(gyroX, gyroY);
  fix32 speed = 0.0; //GYRO_CUTOFF_SPEED;
  fix32 recovery = 00.0; //GYRO_CUTOFF_RECOVERY;
  if (recovery > speed) {
    // we can use gyro_cutoff_speed
    fix32 gyroIgnoreFactor = (gyroLength - speed) / (recovery - speed);
    if (gyroIgnoreFactor < 1.0) {
      if (gyroIgnoreFactor <= 0.0) {
        gyroX = gyroY = gyroLength = 0.0;
      } else {
        gyroX *= gyroIgnoreFactor;
        gyroY *= gyroIgnoreFactor;
        gyroLength *= gyroIgnoreFactor;
      }
    }
  }
  else if (speed > 0.0 && gyroLength < speed) {
    // gyro_cutoff_recovery is something weird, so we just do a hard threshold
    gyroX = gyroY = gyroLength = 0.0;
  }
  return gyroY;
}

/* void GetSmoothedGyro(float x, float y, float length, float bottomThreshold, float topThreshold, int maxSamples, float &outX, float &outY) {
// this is basically the same as we use for smoothing flick-stick rotations, but because this deals in vectors, it's a slightly different function. Not worth abstracting until it'll be used in more ways
// which item in the circular smoothing buffer will we write over?
_frontGyroSample--;
if (_frontGyroSample < 0)
_frontGyroSample = MaxGyroSamples - 1;
float immediateFactor;
if (topThreshold <= bottomThreshold)
{
immediateFactor = length < bottomThreshold ? 0.0f : 1.0f;
}
else
{
immediateFactor = (length - bottomThreshold) / (topThreshold - bottomThreshold);
}
// clamp to [0, 1] range
if (immediateFactor < 0.0f)
{
immediateFactor = 0.0f;
}
else if (immediateFactor > 1.0f)
{
immediateFactor = 1.0f;
}
float smoothFactor = 1.0f - immediateFactor;
// now we can push the smooth sample (or as much of it as we want smoothed)
FloatXY frontSample = _gyroSamples[_frontGyroSample] = { x * smoothFactor, y * smoothFactor };
// and now calculate smoothed result
float xResult = frontSample.x() / maxSamples;
float yResult = frontSample.y() / maxSamples;
for (int i = 1; i < maxSamples; i++)
{
int rotatedIndex = (_frontGyroSample + i) % MaxGyroSamples;
frontSample = _gyroSamples[rotatedIndex];
xResult += frontSample.x() / maxSamples;
yResult += frontSample.y() / maxSamples;
}
// finally, add immediate portion
outX = xResult + x * immediateFactor;
outY = yResult + y * immediateFactor;
}*/

//tight
fix32 getTightenedInput0(fix32 input0, fix32 input1, fix32 threshold) {
  fix32 inputMagnitude = pythag(input0, input1);
  if (inputMagnitude < threshold) {
    fix32 inputScale = inputMagnitude / threshold;
    return input0 * inputScale;
  }
  return input0;
}
fix32 getTightenedInput1(fix32 input0, fix32 input1, fix32 threshold) {
  fix32 inputMagnitude = pythag(input0, input1);
  if (inputMagnitude < threshold) {
    fix32 inputScale = inputMagnitude / threshold;
    return input1 * inputScale;
  }
  return input1;
}

//accel
void processGyroAccel(fix32 calibratedGyro0, fix32 calibratedGyro1,
uint32 deltaTime, fix32 sensitivitySlow, fix32 sensitivityFast,
fix32 slowThreshold, fix32 fastThreshold) {
  // apply calibration factor
  // get input velocity
  fix32 magnitude = pythag(calibratedGyro0, calibratedGyro1);
  // calculate position on slowThreshold to fastThreshold scale
  magnitude -= slowThreshold;
  if (magnitude < 0.0) {
    magnitude = 0.0;
  }
  fix32 denom = fastThreshold - slowThreshold;
  fix32 newSensitivity;
  if (denom <= 0.0) {
    newSensitivity = magnitude > 0.0 ? 1.0 : 0.0; // if min threshold overlaps max threshold, pop up to
    // max lowSens as soon as we're above min threshold
  } else {
    newSensitivity = magnitude / denom;
  }
  if (newSensitivity > 1.0) {
    newSensitivity = 1.0;
  }
  // interpolate between low sensitivity and high sensitivity
  newSensitivity = lerp(sensitivitySlow, sensitivityFast, newSensitivity);
  camera[0] = calibratedGyro0 * newSensitivity * (fix32)deltaTime;
  camera[1] = calibratedGyro1 * newSensitivity * (fix32)deltaTime;
}


fix32 pythag(fix32 a, fix32 b) {
  return sqrt( sq(a) + sq(b) );
}

bool processGyroStick(fix32 stickX, fix32 stickY) {
  //GPC has all axis represented in -100 to 100
  //This is not the case with JSM
  fix32 stickLength = pythag(stickX, stickY);
  fix32 livezoneSize = 1.0 - undeadzoneOuter - undeadzoneInner;
  //in order to correctly combine gyro and stick, we need to calculate what the stick
  //aiming is supposed to be doing, add gyro result to it, and convert back to stick
  if (unpower == 0.0) {
    unpower = 1.0;
  }
  maxStickGameSpeed = 100.0;
  fix32 stickVelocity = pow(clamp((stickLength - undeadzoneInner) / livezoneSize, 0.0, 1.0), unpower) * maxStickGameSpeed * virtualScale;
  fix32 expectedX = 0.0;
  fix32 expectedY = 0.0;
  gyroStickX = 0.0;
  gyroStickY = 0.0;
  
  if (stickVelocity > 0.0) {
    expectedX = stickX / stickLength * stickVelocity;
    expectedY = stickY / stickLength * stickVelocity;
  }
  
  expectedX += camera[0];
  expectedY += camera[1];
  
  fix32 targetGyroVelocity = pythag(expectedX, expectedY);
  // map gyro velocity to achievable range in 0-1
  fix32 gyroInStickStrength = targetGyroVelocity >= maxStickGameSpeed ? 1.0 : targetGyroVelocity / maxStickGameSpeed;
  // unpower curve
  if (unpower != 0.0) {
    gyroInStickStrength = pow(gyroInStickStrength, 1.0 / unpower);
  }
  
  // remap to between inner and outer deadzones
  if (gyroInStickStrength > 0.010) {
    gyroInStickStrength = undeadzoneInner + gyroInStickStrength * livezoneSize;
    gyroStickX = expectedX / targetGyroVelocity * gyroInStickStrength;
    gyroStickY = expectedY / targetGyroVelocity * gyroInStickStrength;
  }
  
  if (logging) {
    printf("camera0:             %f", camera[0]);
    printf("camera1:             %f", camera[1]);
    printf("gyroVelocity0:       %f", gyroVelocity[0]);
    printf("gyroVelocity1:       %f", gyroVelocity[1]);
    printf("stickX:              %f", stickX);
    printf("stickY:              %f", stickY);
    printf("expectedX:           %f", expectedX);
    printf("expectedY:           %f", expectedY);
    printf("gyroStickX:          %f", gyroStickX);
    printf("gyroStickY:          %f", gyroStickY);
    printf("stickLength:         %f", stickLength);
    printf("stickVelocity:       %f", stickVelocity);
    printf("targetGyroVelocity:  %f", targetGyroVelocity);
    printf("gyroInStickStrength: %f", gyroInStickStrength);
  }
  
  return stickLength > undeadzoneInner;
}

/* void processRotational() {
//handleFlickStick(float calX, float calY, float lastCalX, float lastCalY, float mouseCalibrationFactor)
isMouse = FALSE;
fix32 camSpeedX = 0.0;
fix32 lastOffsetX = lastCalX;
fix32 lastOffsetY = lastCalY;
fix32 lastStickAngle = atan2f(-lastOffsetX, lastOffsetY);
fix32 angleChange = stickAngle - lastStickAngle;
// https://stackoverflow.com/a/11498248/1130520
angleChange = mod(angleChange + PI, 2.0 * PI);
if (angleChange < 0) {
angleChange += 2.0 * PI;
}
angleChange -= PI;
flick_rotation_counter += angleChange; // track all rotation for this flick
fix32 flickSpeedConstant = isMouse ? REAL_WORLD_CALIBRATION * mouseCalibrationFactor / IN_GAME_SENS : 1.0;
fix32 flickSpeed = -(angleChange * flickSpeedConstant);
int maxSmoothingSamples = min(jc->NumSamples, (int)ceil(64.0 / tick_time.get())); // target a max smoothing window size of 64ms
//fix32 stepSize = 0.01;                                                            // and we only want full on smoothing when the stick change each time we poll it is approximately the minimum stick resolution
// the fact that we're using radians makes this really easy
fix32 rotate_smooth_override = 0.0; //ROTATE_SMOOTH_OVERRIDE;
if (rotate_smooth_override < 0.0) {
//camSpeedX = jc->GetSmoothedStickRotation(flickSpeed, flickSpeedConstant * stepSize * 2.0, flickSpeedConstant * stepSize * 4.0, maxSmoothingSamples);
} else {
//camSpeedX = jc->GetSmoothedStickRotation(flickSpeed, flickSpeedConstant * rotate_smooth_override, flickSpeedConstant * rotate_smooth_override * 2.0, maxSmoothingSamples);
}

if (!isMouse) {
// convert to a velocity
camSpeedX *= 180.0 / (PI * 0.001;// * tick_time.get());
}
fix32 secondsSinceFlick = ((float)chrono::duration_cast<chrono::microseconds>(jc->time_now - jc->started_flick).count()) / 1000000.0f;
fix32 maxStickGameSpeed = jc->getSetting(SettingID::VIRTUAL_STICK_CALIBRATION);
fix32 flickTime = abs(jc->delta_flick) / (maxStickGameSpeed * PI / 180.f);

if (secondsSinceFlick <= flickTime)
{
camSpeedX -= jc->delta_flick >= 0 ? maxStickGameSpeed : -maxStickGameSpeed;
}
}
*/

/*
<shortdesc>
Use your controller's gyro to aim! Supports outputting as mouse or joystick. Supports flickstick when in mouse mode. See interactive config for help.
</shortdesc>

<keywords>
gyro mouse flickstick
</keywords>

<cfgdesc>

[Layout]
shortdesc = Gyro Assignment
byteoffset = 0
bitsize = 8
bitoffset = 0
control = radiobox
default = 0
item = Gyro controls mouse
item = Gyro controls right joystick
item = Gyro controls left joystick (incomplete)
[Layout Flickstick]
shortdesc = 
byteoffset = 25
bitsize = 1
bitoffset = 4
control = checkbox
default = 0
item = Flickstick
groupcol = true
[Layout windingStick]
shortdesc = 
byteoffset = 25
bitsize = 1
bitoffset = 6
control = checkbox
default = 0
item = Rotational stick aim
group = true
[Layout stickDisable]
shortdesc = 
byteoffset = 25
bitsize = 1
bitoffset = 5
control = checkbox
default = 0
item = Disable right joystick in mouse mode
group = true

[Sensitivities]
shortdesc = Gyro sensitivity
byteoffset = 1
bitsize = 32
bitoffset = 0
control = spinboxf
decimals = 2
default = 0100
minimum = 0001
maximum = 1000
step = 001
[Stick sensitivity]
shortdesc = Stick sensitivity
byteoffset = 5
bitsize = 32
bitoffset = 0
control = spinboxf
decimals = 2
default = 0100
minimum = 0001
maximum = 1000
step = 001
group = true
[Game sensitivity]
shortdesc = Max stick game speed (joystick mode only)
byteoffset = 9
bitsize = 32
bitoffset = 0
control = spinboxf
decimals = 2
default = 36000
minimum = 00001
maximum = 50000
step = 000010
groupcol = true
[unpower]
shortdesc = unpower (joystick mode only)
byteoffset = 13
bitsize = 32
bitoffset = 0
control = spinboxf
decimals = 2
default = 000
minimum = 000
maximum = 200
step = 100
group = true

[Un-Deadzone (joystick mode only)]
shortdesc = Inner deadzone %
byteoffset = 17
bitsize = 32
bitoffset = 0
control = spinboxf
default = 0000
decimals = 2
step = 0050
minimum = 0000
maximum = 9500
[Deadzone outer]
shortdesc = Outer deadzone %
byteoffset = 21
bitsize = 32
bitoffset = 0
control = spinboxf
default = 0000
decimals = 2
step = 0050
minimum = 0000
maximum = 9500
group = true
[Deadzone Finder checkbox]
shortdesc	 = 
byteoffset = 25
bitsize	   = 1
bitoffset  = 0
control    = checkbox
default    = 0
item       = Deadzone Finder
groupcol = true
[Outer deadzone override]
shortdesc = 
byteoffset = 25
bitsize = 1
bitoffset = 1
control = checkbox
default = 0
item = Stick overrides outer deadzone
groupcol = true

[Acceleration]
shortdesc =
byteoffset = 25
bitsize = 1
bitoffset = 2
control = checkbox
default = 0
item = Enable Acceleration
[Acceleration slow sens]
shortdesc = Slow sensitivity
byteoffset = 26
bitsize = 32
bitoffset = 0
control = spinboxf
decimals = 2
default = 00050
minimum = 00000
maximum = 10000
step = 001
groupcol = true
[Acceleration fast sens]
shortdesc = Fast sensitivity
byteoffset = 30
bitsize = 32
bitoffset = 0
control = spinboxf
decimals = 2
default = 00500
minimum = 00001
maximum = 10000
step = 001
group = true
[Acceleration slow threshold]
shortdesc = Slow threshold
byteoffset = 34
bitsize = 32
bitoffset = 0
control = spinboxf
decimals = 2
default = 000100
minimum = 000000
maximum = 100000
step = 001
groupcol = true
[Acceleration fast threshold]
shortdesc = Fast threshold
byteoffset = 38
bitsize = 32
bitoffset = 0
control = spinboxf
decimals = 2
default = 001000
minimum = 000001
maximum = 100000
step = 0010
group = true

[Misc]
shortdesc = 
byteoffset = 25
bitsize = 1
bitoffset = 3
control = checkbox
default = 1
item = Calibrate gyro on startup
[Misc: Tightening threshold]
shortdesc = Tightening threshold
byteoffset = 42
bitsize = 32
bitoffset = 0
control = spinboxf
decimals = 2
default = 0
minimum = 000000
maximum = 100000
step = 100
groupcol = true
[Misc: Smoothing threshold]
shortdesc = Smoothing threshold
byteoffset = 46
bitsize = 32
bitoffset = 0
control = spinboxf
decimals = 2
default = 0
minimum = 000000
maximum = 100000
step = 100
group = true

[Output Protocol]
shortdesc = Remember this output next time you run the script
bitsize = 8
byteoffset = 50
control = combobox
default = 0
item = No change
item = PROTOCOL_AUTO
item = PROTOCOL_PS4
item = PROTOCOL_XB360
item = PROTOCOL_HID (HID required for mouse)
item = BT PROTOCOL_HID (HID required for mouse)
item = BT PROTOCOL_PS3
item = BT PROTOCOL_PS4
item = BT PROTOCOL_XB360
item = BT PROTOCOL_XB1
item = BT PROTOCOL_SWITCH
item = BT PROTOCOL_WII

[Info: Mouse vs Joystick?]
shortdesc = <<<MULTILINE
Gyro is functionally equivalent to mouse, and is best experienced when mapped to a mouse. However, I encountered some limitations with the TitanTwo and GPC, so things here are not ideal.
Mouse mode does work pretty well when paired with a XIM, though- try it for yourself and see if it works for you.

Joystick out is emulating a joystick, but how this feels will vary from game to game. In fact, since gyro is basically a mouse, it will feel a lot like you're trying to map a mouse to the joystick!
This code is not as comprehensive as XIM smart translators - so you may prefer to use mouse mode + XIM in one game, and the built in joystick emulation in other games.

NOTE: the HID ouptut protocol still outputs the whole controller as a joystick, and the XIM does see it!
Controller remaps will still take effect. Disable the right joystick to prevent double output.
MULTILINE
control = info

[Info: Flickstick]
shortdesc = <<<MULTILINE
The new aim method that I believe will one day replace traditional stick aim!
MULTILINE
control = info

[Info: Rotational stick aim]
shortdesc = <<<MULTILINE
Since flickstick on joystick output is severely compromised, I have implemented a component of flickstick: rotation. This keeps normal left/right stick aim, but allows for fine precision aim by pushing the stick forward and moving left or right. This allows you to keep using sensitivities that would otherwise be unusably high for a stick (which is a prerequisite for XIM). Normal left/right will allow for snappy turns, rotation for precision slow aim. Disables Y axis, so you'll want to map GYRO_OFF to something to re-orient yourself vertically.
MULTILINE
control = info

[Info: Sensitivities]
shortdesc = <<<MULTILINE
Gyro Sensitivity gets multiplied against sensor data to increase or decrease the output speed.

Stick sensitivity configures the sensitivity of the joystick in the same way, independently of gyro motion.

Max stick game speed represents the fastest you can look around in game; the higher the number, the faster you can move the controller without input being clipped.
However, higher numbers decrease the resolution of slower inputs.

Unpower: If a game processes the joystick with a power curve, setting the exponent of the curve here will cancel out that curve for gyro output.
MULTILINE
control = info

[Info: Un-Deadzone]
shortdesc = <<<MULTILINE
Each game has its own joystick inner deadzone set by the developers.
If this script knows where the deadzone is, it can use that as the starting point for gyro outpoint, effectively eliminating the inner deadzone.

The outer deadzone can be used to avoid non-linear jumps in sensitivity programmed into the game, which feel unnatural with gyro aim.

Note that outer deadzone config option is asking for the size of the deadzone, not where the deadzone starts.
If there's a jump in acceleration at 92% stick tilt, you want an 8% outer deadzone.

Deadzone Finder helps precisely find inner deadzone. Titan will tilt the joystick at the configured inner deadzone.
Find the highest value of inner deadzone where the camera DOESN'T move.

Stick overrides outer deadzone: Some games have a sharp jump in acceleration when the joystick is tilted near 100%.
This is undesirable for gyro aim, but might be desirable while using the stick because it helps you turn around faster in game.
MULTILINE
control = info

[Info: Acceleration]
shortdesc = <<<MULTILINE
Define a linear acceleration between the two sensitivities at the given movement speed thresholds.
There will be no acceleration below the slow threshold or above the fast threshold.
MULTILINE
control = info

[Info: Misc]
shortdesc = <<<MULTILINE
Calibrate gyro on startup:
Place the controller on a flat surface and do not move it until the LEDs change color.
The script is averaging sensor data to filter out unwanted sensor noise; this helps fight drift.

Tightening squishes output towards zero below the threshold, used to help prevent jitter when trying to hold still at higher sensitivities.

Smoothing helps reduce jitter above the threshold, useful for unsteady hands, or to smooth out noise with higher sensitivities.
MULTILINE
control = info

[Info: Speed Thresholds?]
shortdesc = <<<MULTILINE
Normally, you configure thresholds like this in values of degrees per second: how fast you are turning the controller. Unfortunately the TitanTwo doesn't present raw gyro data in this way, so the threshold number here is more abstract.
Try values like 0.01 when trying to set a threshold that activates when moving as slow as possible. The highest sensible values is somewhere under 200.

You can test where a threshold is by enabling acceleration with slow sensitivity 0, slow threshold 0, fast sensitivity 0.01. Then set fast threshold to the desired test number and see how fast you must move the controller to get a response.
MULTILINE
control = info

[Mouse Suggested Setup]
shortdesc = <<<MULTILINE
Enable acceleration, set slow sensitivity to 5.00 and slow threshold to 0.01.
Set fast sensitivity to your desired normal sensitivity, and fast threshold to 1 or 2.

The limitation I encountered with GPC is that mouse_set does not support precise values, so there's effectively a deadzone that you will notice when trying to move very slowly.
Acceleration set up in this way minimizes the issue. Try playing with different values in the same neighborhood, as well as tightening and smoothing. See what feels best to you.
Joystick emulation doesn't have this limitation.
MULTILINE
control = info
</cfgdesc>

[Credits]
shortdesc = <<<MULTILINE
Most of the concepts used and a lot of the code came from Jibb Smart's gyro wiki:
http://gyrowiki.jibbsmart.com
As well as Jibb Smart's JoyShockMapper project:
https://github.com/Electronicks/JoyShockMapper
Thank you!
MULTILINE
control = info
</cfgdesc>
*/
